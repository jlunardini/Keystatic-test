import React, { useState, useRef, useEffect, useMemo, useContext, createContext, useCallback, useReducer } from 'react';
import { ActionButton, Button, ButtonGroup } from '@keystar/ui/button';
import { Icon } from '@keystar/ui/icon';
import { fileX2Icon } from '@keystar/ui/icon/icons/fileX2Icon';
import { githubIcon } from '@keystar/ui/icon/icons/githubIcon';
import { Flex, Grid, Box } from '@keystar/ui/layout';
import { Heading, Text } from '@keystar/ui/typography';
import { useLocalizedStringFormatter } from '@react-aria/i18n';
import { alertCircleIcon } from '@keystar/ui/icon/icons/alertCircleIcon';
import { listXIcon } from '@keystar/ui/icon/icons/listXIcon';
import { searchIcon } from '@keystar/ui/icon/icons/searchIcon';
import { searchXIcon } from '@keystar/ui/icon/icons/searchXIcon';
import { TextLink, makeLinkComponent, useLinkComponent, LinkComponentContext, DefaultLinkComponent } from '@keystar/ui/link';
import { ProgressCircle } from '@keystar/ui/progress';
import { SearchField } from '@keystar/ui/search-field';
import { StatusLight } from '@keystar/ui/status-light';
import { useMediaQuery, breakpointQueries, css, tokenSchema, injectGlobal, containerQueries, classNames, transition } from '@keystar/ui/style';
import { TableView, TableHeader, Column, TableBody, Row, Cell } from '@keystar/ui/table';
import { assert } from 'emery';
import { l as localizedMessages } from '../../dist/languages-a1bf9185.esm.js';
import { u as useRouter, P as PageRoot, a as PageHeader, b as useTree, g as getCollectionPath, i as isLocalConfig, c as getEntriesInCollectionWithTreeKey, B as BranchInfoContext, d as useRepositoryId, R as Ref_base, p as parseRepoConfig, s as serializeRepoConfig, e as getAuth, G as GitHubAppShellQuery, f as getDirectoriesForTreeKey, o as object, h as getTreeKey, j as useData, L as LOADING, k as getTreeNodeAtPath, l as getEntryDataFilepath, m as isGitHubConfig, n as parseProps, t as toFormattedFormDataError, q as blobSha, K as KEYSTATIC_CLOUD_API_URL, r as KEYSTATIC_CLOUD_HEADERS, v as getSyncAuth, w as redirectToCloudAuth, C as CloudAppShellQuery, x as useBaseCommit, y as useSetTreeSha, z as RepoWithWriteAccessContext, A as updateTreeWithChanges, D as hydrateTreeCacheWithEntries, E as fetchGitHubTreeData, F as treeSha, H as serializeProps, I as getSlugFromState, J as getCollectionFormat, M as getSlugGlobForCollection, N as getCollectionItemPath, O as mergeDataStates, Q as PageBody, S as containerWidthForEntryLayout, T as createGetPreviewProps, U as useBranchInfo, V as useEventCallback, W as clientSideValidateProp, X as FormForEntry, Y as getDataFileExtension, Z as getRepoUrl, _ as getInitialPropsValue, $ as useChanged, a0 as keyedEntries, a1 as pluralize, a2 as useViewer, a3 as useConfig, a4 as isCloudConfig, a5 as useAppState, a6 as ZapLogo, a7 as GitHubAppShellDataContext, a8 as useSidebar, a9 as useContentPanelState, aa as ContentPanelProvider, ab as SidebarDialog, ac as SidebarPanel, ad as AppShellErrorContext, ae as ConfigContext, af as AppStateContext, ag as SidebarProvider, ah as GitHubAppShellProvider, ai as LocalAppShellProvider, aj as getSingletonFormat, ak as getSingletonPath, al as assertValidRepoConfig, am as RouterProvider, an as GitHubAppShellDataProvider } from '../../dist/index-62e46717.esm.js';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { Breadcrumbs, Item as Item$1 } from '@keystar/ui/breadcrumbs';
import { Dialog, DialogContainer, AlertDialog, DialogTrigger } from '@keystar/ui/dialog';
import { Notice } from '@keystar/ui/notice';
import { Toaster, toastQueue } from '@keystar/ui/toast';
import '@keystar/ui/checkbox';
import { TextField } from '@keystar/ui/text-field';
import '@keystar/ui/field';
import '@keystar/ui/number-field';
import '@keystar/ui/combobox';
import 'minimatch';
import { Item as Item$2, Section } from '@react-stately/collections';
import { u as useSlugsInCollection } from '../../dist/useSlugsInCollection-ea0403e9.esm.js';
import { Picker, Item } from '@keystar/ui/picker';
import '@sindresorhus/slugify';
import '@braintree/sanitize-url';
import { Content, Footer } from '@keystar/ui/slots';
import '@keystar/ui/drag-and-drop';
import { trash2Icon } from '@keystar/ui/icon/icons/trash2Icon';
import '@keystar/ui/list-view';
import '@keystar/ui/tooltip';
import { MenuTrigger, Menu, ActionMenu } from '@keystar/ui/menu';
import '@keystar/ui/icon/icons/link2Icon';
import '@keystar/ui/icon/icons/link2OffIcon';
import '@keystar/ui/icon/icons/undo2Icon';
import 'slate-react';
import '@react-stately/overlays';
import '@keystar/ui/icon/icons/imageIcon';
import '@keystar/ui/icon/icons/pencilIcon';
import '@keystar/ui/utils';
import isHotkey from 'is-hotkey';
import { ActionGroup } from '@keystar/ui/action-group';
import { Badge } from '@keystar/ui/badge';
import { externalLinkIcon } from '@keystar/ui/icon/icons/externalLinkIcon';
import { historyIcon } from '@keystar/ui/icon/icons/historyIcon';
import { gql } from '@ts-gql/tag/no-transform';
import { useMutation, useClient, Provider as Provider$1, createClient, dedupExchange, fetchExchange } from 'urql';
import { gitBranchIcon } from '@keystar/ui/icon/icons/gitBranchIcon';
import { RadioGroup, Radio } from '@keystar/ui/radio';
import { dump } from 'js-yaml';
import { fromUint8Array } from 'js-base64';
import LRU from 'lru-cache';
import { l as loadDataFile } from '../../dist/required-files-77a6642f.esm.js';
import { VoussoirProvider, ClientSideOnlyDocumentElement } from '@keystar/ui/core';
import { cacheExchange } from '@urql/exchange-graphcache';
import { authExchange } from '@urql/exchange-auth';
import { persistedExchange } from '@urql/exchange-persisted';
import isEqual from 'fast-deep-equal';
import { Avatar } from '@keystar/ui/avatar';
import { gitBranchPlusIcon } from '@keystar/ui/icon/icons/gitBranchPlusIcon';
import { gitPullRequestIcon } from '@keystar/ui/icon/icons/gitPullRequestIcon';
import { plusIcon } from '@keystar/ui/icon/icons/plusIcon';
import { listTodoIcon } from '@keystar/ui/icon/icons/listTodoIcon';
import { logOutIcon } from '@keystar/ui/icon/icons/logOutIcon';
import { gitForkIcon } from '@keystar/ui/icon/icons/gitForkIcon';
import { monitorIcon } from '@keystar/ui/icon/icons/monitorIcon';
import { moonIcon } from '@keystar/ui/icon/icons/moonIcon';
import { sunIcon } from '@keystar/ui/icon/icons/sunIcon';
import { userIcon } from '@keystar/ui/icon/icons/userIcon';
import { SplitView, SplitPanePrimary, SplitPaneSecondary } from '@keystar/ui/split-view';
import { refreshCwIcon } from '@keystar/ui/icon/icons/refreshCwIcon';
import cookie from 'cookie';
import { z } from 'zod';
import '@markdoc/markdoc';
import 'slate';
import 'emery/assertions';
import '@keystar/ui/icon/icons/panelLeftOpenIcon';
import '@keystar/ui/icon/icons/panelLeftCloseIcon';
import '@keystar/ui/icon/icons/panelRightOpenIcon';
import '@keystar/ui/icon/icons/panelRightCloseIcon';
import '@react-aria/overlays';
import '@react-aria/utils';
import '@keystar/ui/overlays';
import '@keystar/ui/nav-list';
import '@keystar/ui/icon/icons/editIcon';
import '@keystar/ui/icon/icons/linkIcon';
import '@keystar/ui/icon/icons/unlinkIcon';
import '@keystar/ui/icon/icons/boldIcon';
import '@keystar/ui/icon/icons/chevronDownIcon';
import '@keystar/ui/icon/icons/codeIcon';
import '@keystar/ui/icon/icons/italicIcon';
import '@keystar/ui/icon/icons/maximizeIcon';
import '@keystar/ui/icon/icons/minimizeIcon';
import '@keystar/ui/icon/icons/removeFormattingIcon';
import '@keystar/ui/icon/icons/strikethroughIcon';
import '@keystar/ui/icon/icons/subscriptIcon';
import '@keystar/ui/icon/icons/superscriptIcon';
import '@keystar/ui/icon/icons/typeIcon';
import '@keystar/ui/icon/icons/underlineIcon';
import '@keystar/ui/icon/icons/alignLeftIcon';
import '@keystar/ui/icon/icons/alignRightIcon';
import '@keystar/ui/icon/icons/alignCenterIcon';
import '@keystar/ui/icon/icons/quoteIcon';
import 'match-sorter';
import '@keystar/ui/icon/icons/trashIcon';
import '@emotion/weak-memoize';
import '@keystar/ui/icon/icons/minusIcon';
import '@keystar/ui/icon/icons/columnsIcon';
import '@keystar/ui/icon/icons/listIcon';
import '@keystar/ui/icon/icons/listOrderedIcon';
import '@keystar/ui/icon/icons/fileUpIcon';
import '@keystar/ui/icon/icons/sheetIcon';
import '@keystar/ui/icon/icons/tableIcon';
import 'scroll-into-view-if-needed';
import '@react-stately/list';
import '@keystar/ui/listbox';
import 'slate-history';
import 'mdast-util-from-markdown';
import 'mdast-util-gfm-autolink-literal/from-markdown';
import 'micromark-extension-gfm-autolink-literal';
import 'mdast-util-gfm-strikethrough/from-markdown';
import 'micromark-extension-gfm-strikethrough';

// the collator enables language-sensitive string comparison
const collator = new Intl.Collator(undefined, {
  sensitivity: 'base'
});

/**
 * Creates a comparison function that should be provided to the `sort()` method
 * of your data array.
 */
function sortByDescriptor(sortDescriptor) {
  const key = sortDescriptor.column;
  assert(key != null, '`sortDescriptor.column` is required');
  return (a, b) => {
    const valueA = a[key];
    const valueB = b[key];
    const modifier = sortDescriptor.direction === 'ascending' ? 1 : -1;

    // always push `null` and `undefined` to the bottom
    if (valueA == null) return 1;
    if (valueB == null) return -1;

    // the collator is only appropriate for strings, it fails in subtle
    // ways for floats, dates, etc.
    if (typeof valueA === 'string' && typeof valueB === 'string') {
      return collator.compare(valueA, valueB) * modifier;
    }
    return compare(valueA, valueB) * modifier;
  };
}

/** Default comparison for non-string values */
function compare(a, b) {
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
}

function EmptyState(props) {
  return /*#__PURE__*/jsx(Flex, {
    alignItems: "center",
    direction: "column",
    gap: "large",
    justifyContent: "center",
    minHeight: "scale.3000",
    paddingX: {
      mobile: 'medium',
      tablet: 'xlarge',
      desktop: 'xxlarge'
    },
    children: 'children' in props ? props.children : /*#__PURE__*/jsxs(Fragment, {
      children: [props.icon && /*#__PURE__*/jsx(Icon, {
        src: props.icon,
        size: "large",
        color: "neutralEmphasis"
      }), props.title && /*#__PURE__*/jsx(Heading, {
        align: "center",
        size: "medium",
        children: props.title
      }), props.message && /*#__PURE__*/jsx(Text, {
        align: "center",
        children: props.message
      }), props.actions]
    })
  });
}

class NotFoundError extends Error {
  constructor() {
    super('Not found');
    this.name = 'NotFoundError';
  }
}
function isNotFoundError(err) {
  return typeof err === 'object' && err !== null && err instanceof NotFoundError;
}
function notFound() {
  throw new NotFoundError();
}
class NotFoundErrorBoundaryInner extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      notFound: false,
      lastHref: props.href
    };
  }
  static getDerivedStateFromError(err) {
    if (isNotFoundError(err)) {
      return {
        notFound: true
      };
    }
    throw err;
  }
  static getDerivedStateFromProps(props, state) {
    if (props.href !== state.lastHref && state.notFound) {
      return {
        notFound: false,
        lastHref: props.href
      };
    }
    return {
      notFound: state.notFound,
      lastHref: props.href
    };
  }
  render() {
    if (this.state.notFound) return this.props.fallback;
    return this.props.children;
  }
}
function NotFoundBoundary(props) {
  const router = useRouter();
  return /*#__PURE__*/jsx(NotFoundErrorBoundaryInner, {
    ...props,
    href: router.href
  });
}

function CollectionPage(props) {
  var _config$collections;
  const {
    collection,
    config
  } = props;
  const containerWidth = 'none'; // TODO: use a "large" when we have more columns
  const collectionConfig = (_config$collections = config.collections) === null || _config$collections === void 0 ? void 0 : _config$collections[collection];
  if (!collectionConfig) notFound();
  const [searchTerm, setSearchTerm] = useState('');
  let debouncedSearchTerm = useDebouncedValue(searchTerm, 300);
  return /*#__PURE__*/jsxs(PageRoot, {
    containerWidth: containerWidth,
    children: [/*#__PURE__*/jsx(CollectionPageHeader, {
      collectionLabel: collectionConfig.label,
      createHref: `${props.basePath}/collection/${encodeURIComponent(props.collection)}/create`,
      searchTerm: searchTerm,
      onSearchTermChange: setSearchTerm
    }), /*#__PURE__*/jsx(CollectionPageContent, {
      searchTerm: debouncedSearchTerm,
      ...props
    })]
  });
}
function CollectionPageHeader(props) {
  const {
    collectionLabel,
    createHref
  } = props;
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  const isAboveMobile = useMediaQuery(breakpointQueries.above.mobile);
  const [searchVisible, setSearchVisible] = useState(isAboveMobile);
  const searchRef = useRef(null);
  useEffect(() => {
    setSearchVisible(isAboveMobile);
  }, [isAboveMobile]);
  return /*#__PURE__*/jsxs(PageHeader, {
    children: [/*#__PURE__*/jsx(Heading, {
      elementType: "h1",
      id: "page-title",
      size: "small",
      flex: true,
      minWidth: 0,
      children: collectionLabel
    }), /*#__PURE__*/jsx("div", {
      role: "search",
      style: {
        display: searchVisible ? 'block' : 'none'
      },
      children: /*#__PURE__*/jsx(SearchField, {
        ref: searchRef,
        "aria-label": stringFormatter.format('search') // TODO: l10n "Search {collection}"?
        ,
        onChange: props.onSearchTermChange,
        onClear: () => {
          props.onSearchTermChange('');
          if (!isAboveMobile) {
            // the timeout ensures that the "add" button isn't pressed
            setTimeout(() => {
              setSearchVisible(false);
            }, 250);
          }
        },
        onBlur: () => {
          if (!isAboveMobile && props.searchTerm === '') {
            setSearchVisible(false);
          }
        },
        placeholder: stringFormatter.format('search'),
        value: props.searchTerm,
        width: "scale.2400"
      })
    }), /*#__PURE__*/jsx(ActionButton, {
      "aria-label": "show search",
      isHidden: searchVisible || {
        above: 'mobile'
      },
      onPress: () => {
        setSearchVisible(true);
        // NOTE: this hack is to force the search field to focus, and invoke
        // the software keyboard on mobile safari
        let tempInput = document.createElement('input');
        tempInput.style.position = 'absolute';
        tempInput.style.opacity = '0';
        document.body.appendChild(tempInput);
        tempInput.focus();
        setTimeout(() => {
          var _searchRef$current;
          (_searchRef$current = searchRef.current) === null || _searchRef$current === void 0 || _searchRef$current.focus();
          tempInput.remove();
        }, 0);
      },
      children: /*#__PURE__*/jsx(Icon, {
        src: searchIcon
      })
    }), /*#__PURE__*/jsx(Button, {
      marginStart: "auto",
      prominence: "high",
      href: createHref,
      isHidden: searchVisible ? {
        below: 'tablet'
      } : undefined,
      children: stringFormatter.format('add')
    })]
  });
}
function CollectionPageContent(props) {
  const trees = useTree();
  const tree = trees.merged.kind === 'loaded' ? trees.merged.data.current.entries.get(getCollectionPath(props.config, props.collection)) : null;
  if (trees.merged.kind === 'error') {
    return /*#__PURE__*/jsx(EmptyState, {
      icon: alertCircleIcon,
      title: "Unable to load collection",
      message: trees.merged.error.message,
      actions: /*#__PURE__*/jsx(Button, {
        tone: "accent",
        href: props.basePath,
        children: "Dashboard"
      })
    });
  }
  if (trees.merged.kind === 'loading') {
    return /*#__PURE__*/jsx(EmptyState, {
      children: /*#__PURE__*/jsx(ProgressCircle, {
        "aria-label": "Loading Entries",
        isIndeterminate: true,
        size: "large"
      })
    });
  }
  if (!tree) {
    return /*#__PURE__*/jsx(EmptyState, {
      icon: listXIcon,
      title: "Empty collection",
      message: /*#__PURE__*/jsxs(Fragment, {
        children: ["There aren't any entries yet.", ' ', /*#__PURE__*/jsx(TextLink, {
          href: `${props.basePath}/collection/${encodeURIComponent(props.collection)}/create`,
          children: "Create the first entry"
        }), ' ', "to see it here."]
      })
    });
  }
  return /*#__PURE__*/jsx(CollectionTable, {
    ...props,
    trees: trees.merged.data
  });
}
function CollectionTable(props) {
  let {
    searchTerm
  } = props;
  let isLocalMode = isLocalConfig(props.config);
  let router = useRouter();
  let [sortDescriptor, setSortDescriptor] = useState({
    column: 'name',
    direction: 'ascending'
  });
  const entriesWithStatus = useMemo(() => {
    const defaultEntries = new Map(getEntriesInCollectionWithTreeKey(props.config, props.collection, props.trees.default.tree).map(x => [x.slug, x.key]));
    return getEntriesInCollectionWithTreeKey(props.config, props.collection, props.trees.current.tree).map(entry => {
      return {
        name: entry.slug,
        status: defaultEntries.has(entry.slug) ? defaultEntries.get(entry.slug) === entry.key ? 'Unchanged' : 'Changed' : 'Added'
      };
    });
  }, [props.collection, props.config, props.trees]);
  const filteredItems = useMemo(() => {
    return entriesWithStatus.filter(item => item.name.toLowerCase().includes(searchTerm.toLowerCase()));
  }, [entriesWithStatus, searchTerm]);
  const sortedItems = useMemo(() => {
    return [...filteredItems].sort(sortByDescriptor(sortDescriptor));
  }, [filteredItems, sortDescriptor]);
  const columns = useMemo(() => {
    return isLocalMode ? [{
      name: 'Name',
      key: 'name'
    }] : [{
      name: 'Name',
      key: 'name'
    }, {
      name: 'Status',
      key: 'status',
      minWidth: 140,
      width: '20%'
    }];
  }, [isLocalMode]);
  return /*#__PURE__*/jsxs(TableView, {
    "aria-labelledby": "page-title",
    selectionMode: "none",
    onSortChange: setSortDescriptor,
    sortDescriptor: sortDescriptor,
    density: isLocalMode ? 'spacious' : 'regular',
    overflowMode: "truncate",
    prominence: "low",
    onRowAction: key => {
      router.push(getItemPath(props.basePath, props.collection, key));
    },
    renderEmptyState: () => /*#__PURE__*/jsx(EmptyState, {
      icon: searchXIcon,
      title: "No results",
      message: `No items matching "${searchTerm}" were found.`
    }),
    flex: true,
    marginTop: {
      tablet: 'large'
    },
    marginBottom: {
      mobile: 'regular',
      tablet: 'xlarge'
    },
    UNSAFE_className: css({
      marginInline: tokenSchema.size.space.regular,
      [breakpointQueries.above.mobile]: {
        marginInline: `calc(${tokenSchema.size.space.xlarge} - ${tokenSchema.size.space.medium})`
      },
      [breakpointQueries.above.tablet]: {
        marginInline: `calc(${tokenSchema.size.space.xxlarge} - ${tokenSchema.size.space.medium})`
      },
      '[role=rowheader]': {
        cursor: 'pointer'
      }
    }),
    children: [/*#__PURE__*/jsx(TableHeader, {
      columns: columns,
      children: ({
        name,
        key,
        ...options
      }) => /*#__PURE__*/jsx(Column, {
        isRowHeader: true,
        allowsSorting: true,
        ...options,
        children: name
      }, key)
    }), /*#__PURE__*/jsx(TableBody, {
      items: sortedItems,
      children: item => isLocalMode ? /*#__PURE__*/jsx(Row, {
        children: /*#__PURE__*/jsx(Cell, {
          textValue: item.name,
          children: /*#__PURE__*/jsx(Text, {
            weight: "medium",
            children: item.name
          })
        })
      }, item.name) : /*#__PURE__*/jsxs(Row, {
        children: [/*#__PURE__*/jsx(Cell, {
          textValue: item.name,
          children: /*#__PURE__*/jsx(Text, {
            weight: "medium",
            children: item.name
          })
        }), /*#__PURE__*/jsx(Cell, {
          textValue: item.status,
          children: /*#__PURE__*/jsx(StatusLight, {
            tone: statusTones[item.status],
            children: item.status
          })
        })]
      }, item.name)
    })]
  });
}
function getItemPath(basePath, collection, key) {
  return `${basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(key)}`;
}
function useDebouncedValue(value, delay = 300) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay);
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);
  return debouncedValue;
}
const statusTones = {
  Added: 'positive',
  Changed: 'accent',
  Unchanged: 'neutral'
};

function BranchPicker() {
  const {
    allBranches,
    currentBranch,
    defaultBranch
  } = useContext(BranchInfoContext);
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  const router = useRouter();
  const items = useMemo(() => {
    let defaultItems = allBranches.map(name => ({
      id: name,
      name
    }));
    if (defaultBranch) {
      return [{
        id: defaultBranch,
        name: defaultBranch,
        description: stringFormatter.format('defaultBranch')
      }, ...defaultItems.filter(i => i.name !== defaultBranch)];
    }
    return defaultItems;
  }, [allBranches, defaultBranch, stringFormatter]);
  return /*#__PURE__*/jsx(Picker, {
    "aria-label": stringFormatter.format('currentBranch'),
    items: items,
    selectedKey: currentBranch,
    onSelectionChange: key => {
      if (typeof key === 'string') {
        router.push(router.href.replace(/\/branch\/[^/]+/, '/branch/' + encodeURIComponent(key)));
      }
    }
    // styles
    ,
    prominence: "low",
    width: "auto",
    menuWidth: 288,
    UNSAFE_className: css({
      button: {
        contain: 'layout'
      }
    }),
    children: item => /*#__PURE__*/jsxs(Item, {
      textValue: item.name,
      children: [/*#__PURE__*/jsx(Icon, {
        src: gitBranchIcon
      }), /*#__PURE__*/jsx(Text, {
        truncate: true,
        children: item.name
      }), 'description' in item && /*#__PURE__*/jsx(Text, {
        slot: "description",
        children: item.description
      })]
    }, item.id)
  });
}
function CreateBranchDialog(props) {
  const branchInfo = useContext(BranchInfoContext);
  const isDefaultBranch = branchInfo.defaultBranch === branchInfo.currentBranch;
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  const [{
    error,
    fetching
  }, createBranch] = useCreateBranchMutation();
  const repositoryId = useRepositoryId();
  const createBranchSubmitButtonId = 'create-branch-submit-button';
  const [branchName, setBranchName] = useState('');
  const [baseBranch, setBaseBranch] = useState(branchInfo.defaultBranch);
  return /*#__PURE__*/jsx(Dialog, {
    size: "small",
    children: /*#__PURE__*/jsxs("form", {
      style: {
        display: 'contents'
      },
      onSubmit: async event => {
        var _result$data;
        if (event.target !== event.currentTarget) return;
        event.preventDefault();
        const name = `refs/heads/${branchName}`;
        const result = await createBranch({
          input: {
            name,
            oid: branchInfo.branchNameToBaseCommit.get(baseBranch),
            repositoryId
          }
        });
        if ((_result$data = result.data) !== null && _result$data !== void 0 && (_result$data = _result$data.createRef) !== null && _result$data !== void 0 && _result$data.__typename) {
          props.onCreate(branchName);
        }
      },
      children: [/*#__PURE__*/jsx(Heading, {
        children: stringFormatter.format('newBranch')
      }), /*#__PURE__*/jsx(Content, {
        children: isDefaultBranch ? /*#__PURE__*/jsx(TextField, {
          value: branchName,
          onChange: setBranchName,
          label: stringFormatter.format('branchName')
          // description="Your new branch will be based on the currently checked out branch, which is the default branch for this repository."
          ,
          autoFocus: true,
          errorMessage: error === null || error === void 0 ? void 0 : error.message
        }) : /*#__PURE__*/jsxs(Grid, {
          gap: "xlarge",
          children: [/*#__PURE__*/jsx(TextField, {
            label: stringFormatter.format('branchName'),
            value: branchName,
            onChange: setBranchName,
            autoFocus: true,
            errorMessage: error === null || error === void 0 ? void 0 : error.message
          }), /*#__PURE__*/jsxs(RadioGroup, {
            label: stringFormatter.format('basedOn'),
            value: baseBranch,
            onChange: setBaseBranch,
            children: [/*#__PURE__*/jsxs(Radio, {
              value: branchInfo.defaultBranch,
              children: [/*#__PURE__*/jsxs(Text, {
                children: [branchInfo.defaultBranch, /*#__PURE__*/jsx(Text, {
                  visuallyHidden: true,
                  children: "."
                })]
              }), /*#__PURE__*/jsx(Text, {
                slot: "description",
                children: stringFormatter.format('theDefaultBranchInYourRepository')
              })]
            }), /*#__PURE__*/jsxs(Radio, {
              value: branchInfo.currentBranch,
              children: [/*#__PURE__*/jsxs(Text, {
                children: [branchInfo.currentBranch, /*#__PURE__*/jsx(Text, {
                  visuallyHidden: true,
                  children: "."
                })]
              }), /*#__PURE__*/jsx(Text, {
                slot: "description",
                children: stringFormatter.format('theCurrentlyCheckedOutBranch')
              })]
            })]
          })]
        })
      }), /*#__PURE__*/jsx(Footer, {
        UNSAFE_style: {
          justifyContent: 'flex-end'
        },
        children: fetching && /*#__PURE__*/jsx(ProgressCircle, {
          "aria-labelledby": createBranchSubmitButtonId,
          isIndeterminate: true,
          size: "small"
        })
      }), /*#__PURE__*/jsxs(ButtonGroup, {
        children: [/*#__PURE__*/jsx(Button, {
          onPress: props.onDismiss,
          isDisabled: fetching,
          children: stringFormatter.format('cancel')
        }), /*#__PURE__*/jsx(Button, {
          isDisabled: fetching,
          prominence: "high",
          type: "submit",
          id: createBranchSubmitButtonId,
          children: stringFormatter.format('create')
        })]
      })]
    })
  });
}

// Data
// -----------------------------------------------------------------------------

function useCreateBranchMutation() {
  return useMutation(gql`
      mutation CreateBranch($input: CreateRefInput!) {
        createRef(input: $input) {
          __typename
          ref {
            ...Ref_base
          }
        }
      }
      ${Ref_base}
    `);
}

const AppSlugContext = /*#__PURE__*/createContext(undefined);
const AppSlugProvider = AppSlugContext.Provider;
function InstallGitHubApp(props) {
  var _URL$searchParams$get;
  const router = useRouter();
  const appSlugFromContext = useContext(AppSlugContext);
  const appSlug = (_URL$searchParams$get = new URL(router.href, 'https://example.com').searchParams.get('slug')) !== null && _URL$searchParams$get !== void 0 ? _URL$searchParams$get : appSlugFromContext === null || appSlugFromContext === void 0 ? void 0 : appSlugFromContext.value;
  const parsedRepo = parseRepoConfig(props.config.storage.repo);
  return /*#__PURE__*/jsxs(Flex, {
    direction: "column",
    gap: "regular",
    children: [/*#__PURE__*/jsxs(Flex, {
      alignItems: "end",
      gap: "regular",
      children: [/*#__PURE__*/jsx(TextField, {
        label: "Repo Name",
        width: "100%",
        isReadOnly: true,
        value: parsedRepo.name
      }), /*#__PURE__*/jsx(ActionButton, {
        onPress: () => {
          navigator.clipboard.writeText(parsedRepo.name);
        },
        children: "Copy Repo Name"
      })]
    }), appSlug ? /*#__PURE__*/jsx(Button, {
      prominence: "high",
      href: `https://github.com/apps/${appSlug}/installations/new`,
      children: "Install GitHub App"
    }) : /*#__PURE__*/jsx(Notice, {
      tone: "caution",
      children: appSlugFromContext ? /*#__PURE__*/jsxs(Text, {
        children: ["The ", /*#__PURE__*/jsx("code", {
          children: appSlugFromContext.envName
        }), " environment variable wasn't provided so we can't link to the GitHub app installation page. You should find the App on GitHub and add the repo yourself."]
      }) : /*#__PURE__*/jsx(Text, {
        children: "Find the App on GitHub and add the repo."
      })
    })]
  });
}

function ForkRepoDialog(props) {
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  const client = useClient();
  const [state, setState] = useState({
    kind: 'idle'
  });
  useEffect(() => {
    const listener = async event => {
      if (event.key === 'ks-refetch-installations' && event.newValue === 'true') {
        localStorage.removeItem('ks-refetch-installations');
        try {
          var _res$data;
          const auth = await getAuth(props.config);
          if (!auth) throw new Error('Unauthorized');
          const res = await client.query(GitHubAppShellQuery, parseRepoConfig(props.config.storage.repo)).toPromise();
          if ((_res$data = res.data) !== null && _res$data !== void 0 && (_res$data = _res$data.repository) !== null && _res$data !== void 0 && (_res$data = _res$data.forks.nodes) !== null && _res$data !== void 0 && _res$data.some(x => (x === null || x === void 0 ? void 0 : x.viewerPermission) === 'ADMIN' || (x === null || x === void 0 ? void 0 : x.viewerPermission) === 'WRITE' || (x === null || x === void 0 ? void 0 : x.viewerPermission) === 'MAINTAIN')) {
            await new Promise(resolve => setTimeout(resolve, 100));
            props.onCreate();
          }
        } catch (err) {
          setState({
            kind: 'error',
            error: err
          });
        }
      }
    };
    addEventListener('storage', listener);
    return () => removeEventListener('storage', listener);
  }, [client, props]);
  const appSlug = useContext(AppSlugContext);
  return /*#__PURE__*/jsxs(Dialog, {
    size: "small",
    isDismissable: true,
    onDismiss: () => {
      props.onDismiss();
    },
    children: [/*#__PURE__*/jsx(Heading, {
      children: "Fork Repo"
    }), state.kind === 'error' ? /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Content, {
        children: /*#__PURE__*/jsx(Notice, {
          tone: "critical",
          children: state.error.message
        })
      }), /*#__PURE__*/jsx(ButtonGroup, {
        children: /*#__PURE__*/jsx(Button, {
          onPress: props.onDismiss,
          children: stringFormatter.format('cancel')
        })
      })]
    }) : /*#__PURE__*/jsx(Fragment, {
      children: /*#__PURE__*/jsx(Content, {
        children: /*#__PURE__*/jsxs(Flex, {
          gap: "large",
          direction: "column",
          marginBottom: "large",
          children: [/*#__PURE__*/jsx(Text, {
            children: "You don't have permission to write to this repo so to save your changes, you need to fork the repo."
          }), /*#__PURE__*/jsxs(Text, {
            children: ["To start,", ' ', /*#__PURE__*/jsx(TextLink, {
              href: `https://github.com/${serializeRepoConfig(props.config.storage.repo)}/fork`,
              target: "_blank",
              rel: "noopener noreferrer",
              children: "fork the repo on GitHub"
            }), ". Then, come back to this page and", ' ', /*#__PURE__*/jsx(TextLink, {
              href: `https://github.com/apps/${appSlug === null || appSlug === void 0 ? void 0 : appSlug.value}/installations/new?state=close`,
              target: "_blank",
              rel: "noopener noreferrer",
              children: "install the Keystatic GitHub App on your fork."
            })]
          })]
        })
      })
    })]
  });
}

function parseEntry(args, files) {
  const dataFilepath = getEntryDataFilepath(args.dirpath, args.format);
  const data = files.get(dataFilepath);
  if (!data) {
    throw new Error(`Could not find data file at ${dataFilepath}`);
  }
  const {
    loaded,
    extraFakeFile
  } = loadDataFile(data, args.format);
  const filesWithFakeFile = new Map(files);
  if (extraFakeFile) {
    filesWithFakeFile.set(`${args.dirpath}/${extraFakeFile.path}`, extraFakeFile.contents);
  }
  const rootSchema = object(args.schema);
  let initialState;
  try {
    initialState = parseProps(rootSchema, loaded, [], [], (schema, value, path, pathWithArrayFieldSlugs) => {
      var _args$slug;
      if (path.length === 1 && path[0] === ((_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.field)) {
        if (schema.formKind !== 'slug') {
          throw new Error(`slugField is not a slug field`);
        }
        return schema.parse(value, {
          slug: args.slug.slug
        });
      }
      if (schema.formKind === 'asset') {
        var _args$slug2, _args$slug3, _args$slug4;
        const suggestedFilenamePrefix = pathWithArrayFieldSlugs.join('/');
        const filepath = schema.filename(value, {
          suggestedFilenamePrefix,
          slug: (_args$slug2 = args.slug) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.slug
        });
        const asset = filepath ? filesWithFakeFile.get(`${schema.directory ? `${schema.directory}${((_args$slug3 = args.slug) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.slug) === undefined ? '' : `/${args.slug.slug}`}` : args.dirpath}/${filepath}`) : undefined;
        return schema.parse(value, {
          asset,
          slug: (_args$slug4 = args.slug) === null || _args$slug4 === void 0 ? void 0 : _args$slug4.slug
        });
      }
      if (schema.formKind === 'content') {
        var _args$slug7;
        const rootPath = `${args.dirpath}/${pathWithArrayFieldSlugs.join('/')}`;
        const mainFilepath = rootPath + schema.contentExtension;
        const mainContents = filesWithFakeFile.get(mainFilepath);
        const otherFiles = new Map();
        const otherDirectories = new Map();
        for (const [filename] of filesWithFakeFile) {
          if (filename.startsWith(rootPath + '/')) {
            const relativePath = filename.slice(rootPath.length + 1);
            otherFiles.set(relativePath, filesWithFakeFile.get(filename));
          }
        }
        for (const dir of (_schema$directories = schema.directories) !== null && _schema$directories !== void 0 ? _schema$directories : []) {
          var _schema$directories, _args$slug5, _args$slug6;
          const dirFiles = new Map();
          const start = `${dir}${((_args$slug5 = args.slug) === null || _args$slug5 === void 0 ? void 0 : _args$slug5.slug) === undefined ? '' : `/${(_args$slug6 = args.slug) === null || _args$slug6 === void 0 ? void 0 : _args$slug6.slug}`}/`;
          for (const [filename, val] of filesWithFakeFile) {
            if (filename.startsWith(start)) {
              const relativePath = filename.slice(start.length);
              dirFiles.set(relativePath, val);
            }
          }
          if (dirFiles.size) {
            otherDirectories.set(dir, dirFiles);
          }
        }
        return schema.parse(value, {
          content: mainContents,
          other: otherFiles,
          external: otherDirectories,
          slug: (_args$slug7 = args.slug) === null || _args$slug7 === void 0 ? void 0 : _args$slug7.slug
        });
      }
      return schema.parse(value, undefined);
    }, false);
  } catch (err) {
    throw toFormattedFormDataError(err);
  }
  const initialFiles = [...files.keys()];
  return {
    initialState,
    initialFiles
  };
}
function getAllFilesInTree(tree) {
  return [...tree.values()].flatMap(val => val.children ? getAllFilesInTree(val.children) : [val.entry]);
}
function useItemData(args) {
  var _args$slug9;
  const {
    current: currentBranch
  } = useTree();
  const rootTree = currentBranch.kind === 'loaded' ? currentBranch.data.tree : undefined;
  const locationsForTreeKey = useMemo(() => {
    var _args$slug8;
    return getDirectoriesForTreeKey(object(args.schema), args.dirpath, (_args$slug8 = args.slug) === null || _args$slug8 === void 0 ? void 0 : _args$slug8.slug, args.format);
  }, [args.dirpath, args.format, args.schema, (_args$slug9 = args.slug) === null || _args$slug9 === void 0 ? void 0 : _args$slug9.slug]);
  const localTreeKey = useMemo(() => getTreeKey(locationsForTreeKey, rootTree !== null && rootTree !== void 0 ? rootTree : new Map()), [locationsForTreeKey, rootTree]);
  const tree = useMemo(() => {
    return rootTree !== null && rootTree !== void 0 ? rootTree : new Map();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [localTreeKey, locationsForTreeKey]);
  const hasLoaded = currentBranch.kind === 'loaded';
  return useData(useCallback(() => {
    var _getTreeNodeAtPath;
    if (!hasLoaded) return LOADING;
    const dataFilepathSha = (_getTreeNodeAtPath = getTreeNodeAtPath(tree, getEntryDataFilepath(args.dirpath, args.format))) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha;
    if (dataFilepathSha === undefined) {
      return 'not-found';
    }
    const _args = {
      config: args.config,
      dirpath: args.dirpath,
      format: args.format,
      schema: args.schema,
      slug: args.slug
    };
    const allBlobs = locationsForTreeKey.flatMap(dir => {
      const node = getTreeNodeAtPath(tree, dir);
      if (!node) return [];
      return node.children ? getAllFilesInTree(node.children) : [node.entry];
    }).map(entry => {
      const blob = fetchBlob(args.config, entry.sha, entry.path);
      if (blob instanceof Uint8Array) {
        return [entry.path, blob];
      }
      return blob.then(blob => [entry.path, blob]);
    });
    if (allBlobs.every(x => Array.isArray(x))) {
      const {
        initialFiles,
        initialState
      } = parseEntry(_args, new Map(allBlobs));
      return {
        initialState,
        initialFiles,
        localTreeKey
      };
    }
    return Promise.all(allBlobs).then(async data => {
      const {
        initialState,
        initialFiles
      } = parseEntry(_args, new Map(data));
      return {
        initialState,
        initialFiles,
        localTreeKey
      };
    });
  }, [hasLoaded, tree, args.dirpath, args.format, args.config, args.schema, args.slug, locationsForTreeKey, localTreeKey]));
}
const blobCache = new LRU({
  max: 200
});
async function hydrateBlobCache(contents) {
  const sha = await blobSha(contents);
  blobCache.set(sha, contents);
  return sha;
}
async function fetchGitHubBlob(config, oid) {
  const auth = await getAuth(config);
  return fetch(config.storage.kind === 'github' ? `https://api.github.com/repos/${serializeRepoConfig(config.storage.repo)}/git/blobs/${oid}` : `${KEYSTATIC_CLOUD_API_URL}/v1/github/blob/${oid}`, {
    headers: {
      Authorization: `Bearer ${auth.accessToken}`,
      Accept: 'application/vnd.github.raw',
      ...(config.storage.kind === 'cloud' ? KEYSTATIC_CLOUD_HEADERS : {})
    }
  });
}
function fetchBlob(config, oid, filepath) {
  if (blobCache.has(oid)) return blobCache.get(oid);
  const promise = (isGitHubConfig(config) || config.storage.kind === 'cloud' ? fetchGitHubBlob(config, oid) : fetch(`/api/keystatic/blob/${oid}/${filepath}`, {
    headers: {
      'no-cors': '1'
    }
  })).then(x => x.arrayBuffer()).then(x => {
    const array = new Uint8Array(x);
    blobCache.set(oid, array);
    return array;
  }).catch(err => {
    blobCache.delete(oid);
    throw err;
  });
  blobCache.set(oid, promise);
  return promise;
}

const ThemeContext = /*#__PURE__*/createContext({
  theme: 'auto',
  setTheme: () => {
    throw new Error('ThemeContext was not initialized.');
  }
});
const ThemeProvider = ThemeContext.Provider;
const STORAGE_KEY = 'keystatic-color-scheme';

// only for initializing the provider, for consumption use `useThemeContext()`
function useTheme() {
  let [theme, setThemeValue] = useState(() => {
    let storedValue = localStorage.getItem(STORAGE_KEY);
    if (storedValue === 'light' || storedValue === 'dark') {
      return storedValue;
    }
    return 'auto';
  });
  let setTheme = theme => {
    localStorage.setItem(STORAGE_KEY, theme);
    setThemeValue(theme);
  };
  return {
    theme,
    setTheme
  };
}
function useThemeContext() {
  return useContext(ThemeContext);
}

injectGlobal({
  body: {
    overflow: 'hidden'
  }
});
function createUrqlClient(config) {
  const repo = config.storage.kind === 'github' ? parseRepoConfig(config.storage.repo) : {
    owner: 'repo-owner',
    name: 'repo-name'
  };
  return createClient({
    url: config.storage.kind === 'github' ? 'https://api.github.com/graphql' : `${KEYSTATIC_CLOUD_API_URL}/v1/github/graphql`,
    requestPolicy: 'cache-and-network',
    exchanges: [dedupExchange, authExchange(async utils => {
      let authState = await getAuth(config);
      return {
        addAuthToOperation(operation) {
          authState = getSyncAuth(config);
          if (!authState) {
            return operation;
          }
          return utils.appendHeaders(operation, {
            Authorization: `Bearer ${authState.accessToken}`,
            ...(config.storage.kind === 'cloud' ? KEYSTATIC_CLOUD_HEADERS : {})
          });
        },
        didAuthError() {
          return false;
        },
        willAuthError(operation) {
          var _operation$query$defi;
          authState = getSyncAuth(config);
          if (operation.query.definitions[0].kind === 'OperationDefinition' && (_operation$query$defi = operation.query.definitions[0].name) !== null && _operation$query$defi !== void 0 && _operation$query$defi.value.includes('AppShell') && !authState) {
            if (config.storage.kind === 'github') {
              window.location.href = '/api/keystatic/github/login';
            } else {
              redirectToCloudAuth('', config);
            }
            return true;
          }
          if (!authState) {
            return true;
          }
          return false;
        },
        async refreshAuth() {
          authState = await getAuth(config);
        }
      };
    }), cacheExchange({
      updates: {
        Mutation: {
          createRef(result, args, cache, _info) {
            cache.updateQuery({
              query: config.storage.kind === 'github' ? GitHubAppShellQuery : CloudAppShellQuery,
              variables: repo
            }, data => {
              var _data$repository;
              if (data !== null && data !== void 0 && (_data$repository = data.repository) !== null && _data$repository !== void 0 && (_data$repository = _data$repository.refs) !== null && _data$repository !== void 0 && _data$repository.nodes && result.createRef && typeof result.createRef === 'object' && 'ref' in result.createRef) {
                return {
                  ...data,
                  repository: {
                    ...data.repository,
                    refs: {
                      ...data.repository.refs,
                      nodes: [...data.repository.refs.nodes, result.createRef.ref]
                    }
                  }
                };
              }
              return data;
            });
          },
          deleteRef(result, args, cache, _info) {
            cache.updateQuery({
              query: config.storage.kind === 'github' ? GitHubAppShellQuery : CloudAppShellQuery,
              variables: repo
            }, data => {
              var _data$repository2;
              if (data !== null && data !== void 0 && (_data$repository2 = data.repository) !== null && _data$repository2 !== void 0 && (_data$repository2 = _data$repository2.refs) !== null && _data$repository2 !== void 0 && _data$repository2.nodes && result.deleteRef && typeof result.deleteRef === 'object' && '__typename' in result.deleteRef && typeof args.input === 'object' && args.input !== null && 'refId' in args.input && typeof args.input.refId === 'string') {
                const refId = args.input.refId;
                return {
                  ...data,
                  repository: {
                    ...data.repository,
                    refs: {
                      ...data.repository.refs,
                      nodes: data.repository.refs.nodes.filter(x => (x === null || x === void 0 ? void 0 : x.id) !== refId)
                    }
                  }
                };
              }
              return data;
            });
          }
        }
      }
    }), ...(config.storage.kind === 'github' ? [] : [persistedExchange({
      enableForMutation: true,
      enforcePersistedQueries: true
    })]), fetchExchange]
  });
}
function Provider({
  children,
  Link,
  config
}) {
  const themeContext = useTheme();
  const UniversalLink = useMemo(() => makeLinkComponent(({
    href,
    onClick,
    rel,
    ...props
  }, ref) => {
    const shouldUseNext = href[0] === '/';
    return shouldUseNext ? /*#__PURE__*/jsx(Link, {
      href: href,
      ref: ref,
      ...props
    }) : /*#__PURE__*/jsx("a", {
      ref: ref,
      href: href,
      rel: rel || 'noreferrer noopener',
      onClick: event => {
        if (href === '' || href === '#') {
          event.preventDefault();
        }
        if (typeof onClick === 'function') {
          onClick(event);
        }
      },
      ...props
    });
  }), [Link]);
  return /*#__PURE__*/jsx(ThemeProvider, {
    value: themeContext,
    children: /*#__PURE__*/jsxs(VoussoirProvider, {
      linkComponent: UniversalLink,
      locale: config.locale || 'en-US',
      colorScheme: themeContext.theme,
      children: [/*#__PURE__*/jsx(ClientSideOnlyDocumentElement, {}), /*#__PURE__*/jsx("link", {
        href: "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap",
        rel: "stylesheet"
      }), /*#__PURE__*/jsx(Provider$1, {
        value: useMemo(() => createUrqlClient(config), [config]),
        children: children
      }), /*#__PURE__*/jsx(Toaster, {})]
    })
  });
}

const textEncoder = new TextEncoder();
const frontmatterSplit = textEncoder.encode('---\n');
function combineFrontmatterAndContents(frontmatter, contents) {
  const array = new Uint8Array(frontmatter.byteLength + contents.byteLength + frontmatterSplit.byteLength * 2);
  array.set(frontmatterSplit);
  array.set(frontmatter, frontmatterSplit.byteLength);
  array.set(frontmatterSplit, frontmatterSplit.byteLength + frontmatter.byteLength);
  array.set(contents, frontmatterSplit.byteLength * 2 + frontmatter.byteLength);
  return array;
}
function serializeEntryToFiles(args) {
  var _args$slug, _args$slug2;
  let {
    value: stateWithExtraFilesRemoved,
    extraFiles
  } = serializeProps(args.state, object(args.schema), (_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.field, (_args$slug2 = args.slug) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.value, true);
  const dataFormat = args.format.data;
  let dataContent = textEncoder.encode(dataFormat === 'json' ? JSON.stringify(stateWithExtraFilesRemoved, null, 2) + '\n' : dump(stateWithExtraFilesRemoved));
  if (args.format.contentField) {
    const filename = `${args.format.contentField.key}${args.format.contentField.config.contentExtension}`;
    let contents;
    extraFiles = extraFiles.filter(x => {
      if (x.path !== filename) return true;
      contents = x.contents;
      return false;
    });
    assert(contents !== undefined, 'Expected content field to be present');
    dataContent = combineFrontmatterAndContents(dataContent, contents);
  }
  return [{
    path: getEntryDataFilepath(args.basePath, args.format),
    contents: dataContent
  }, ...extraFiles.map(file => ({
    path: `${file.parent ? args.slug ? `${file.parent}/${args.slug.value}` : file.parent : args.basePath}/${file.path}`,
    contents: file.contents
  }))];
}
function useUpsertItem(args) {
  const [state, setState] = useState({
    kind: 'idle'
  });
  const baseCommit = useBaseCommit();
  const branchInfo = useContext(BranchInfoContext);
  const setTreeSha = useSetTreeSha();
  const [, mutate] = useMutation(createCommitMutation);
  const repoWithWriteAccess = useContext(RepoWithWriteAccessContext);
  const appSlug = useContext(AppSlugContext);
  return [state, async override => {
    try {
      if (repoWithWriteAccess === null && args.config.storage.kind === 'github' && appSlug !== null && appSlug !== void 0 && appSlug.value) {
        setState({
          kind: 'needs-fork'
        });
        return false;
      }
      setState({
        kind: 'loading'
      });
      let additions = serializeEntryToFiles({
        basePath: args.basePath,
        config: args.config,
        schema: args.schema,
        format: args.format,
        state: args.state,
        slug: args.slug
      });
      const additionPathToSha = new Map(await Promise.all(additions.map(async addition => [addition.path, await hydrateBlobCache(addition.contents)])));
      const filesToDelete = new Set(args.initialFiles);
      for (const file of additions) {
        filesToDelete.delete(file.path);
      }
      additions = additions.filter(addition => {
        const sha = additionPathToSha.get(addition.path);
        const existing = getTreeNodeAtPath(args.currentTree, addition.path);
        return (existing === null || existing === void 0 ? void 0 : existing.entry.sha) !== sha;
      });
      const deletions = [...filesToDelete].map(path => ({
        path
      }));
      const updatedTree = await updateTreeWithChanges(args.currentTree, {
        additions,
        deletions: [...filesToDelete]
      });
      await hydrateTreeCacheWithEntries(updatedTree.entries);
      if (args.config.storage.kind === 'github' || args.config.storage.kind === 'cloud') {
        var _override$branch, _override$sha, _result$error, _result$data;
        const branch = {
          branchName: (_override$branch = override === null || override === void 0 ? void 0 : override.branch) !== null && _override$branch !== void 0 ? _override$branch : branchInfo.currentBranch,
          repositoryNameWithOwner: `${repoWithWriteAccess.owner}/${repoWithWriteAccess.name}`
        };
        const runMutation = expectedHeadOid => mutate({
          input: {
            branch,
            expectedHeadOid,
            message: {
              headline: `Update ${args.basePath}`
            },
            fileChanges: {
              additions: additions.map(addition => ({
                ...addition,
                contents: fromUint8Array(addition.contents)
              })),
              deletions
            }
          }
        });
        let result = await runMutation((_override$sha = override === null || override === void 0 ? void 0 : override.sha) !== null && _override$sha !== void 0 ? _override$sha : baseCommit);
        const gqlError = (_result$error = result.error) === null || _result$error === void 0 || (_result$error = _result$error.graphQLErrors[0]) === null || _result$error === void 0 ? void 0 : _result$error.originalError;
        if (gqlError && 'type' in gqlError) {
          if (gqlError.type === 'BRANCH_PROTECTION_RULE_VIOLATION') {
            setState({
              kind: 'needs-new-branch',
              reason: 'Changes must be made via pull request to this branch. Create a new branch to save changes.'
            });
            return false;
          }
          if (gqlError.type === 'STALE_DATA') {
            var _refData$data, _args$slug3;
            // we don't want this to go into the cache yet
            // so we create a new client just for this
            const refData = await createUrqlClient(args.config).query(FetchRef, {
              owner: repoWithWriteAccess.owner,
              name: repoWithWriteAccess.name,
              ref: `refs/heads/${branchInfo.currentBranch}`
            }).toPromise();
            if (!((_refData$data = refData.data) !== null && _refData$data !== void 0 && (_refData$data = _refData$data.repository) !== null && _refData$data !== void 0 && (_refData$data = _refData$data.ref) !== null && _refData$data !== void 0 && _refData$data.target)) {
              throw new Error('Branch not found');
            }
            const tree = await fetchGitHubTreeData(refData.data.repository.ref.target.oid, args.config);
            const treeKey = getTreeKey(getDirectoriesForTreeKey(object(args.schema), args.basePath, (_args$slug3 = args.slug) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.value, args.format), tree.tree);
            if (treeKey === args.currentLocalTreeKey) {
              result = await runMutation(refData.data.repository.ref.target.oid);
            } else {
              setState({
                kind: 'needs-new-branch',
                reason: 'This entry has been updated since it was opened. Create a new branch to save changes.'
              });
              return false;
            }
          }
        }
        if (result.error) {
          throw result.error;
        }
        const target = (_result$data = result.data) === null || _result$data === void 0 || (_result$data = _result$data.createCommitOnBranch) === null || _result$data === void 0 || (_result$data = _result$data.ref) === null || _result$data === void 0 ? void 0 : _result$data.target;
        if (target) {
          setState({
            kind: 'updated'
          });
          return true;
        }
        throw new Error('Failed to update');
      } else {
        const res = await fetch('/api/keystatic/update', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'no-cors': '1'
          },
          body: JSON.stringify({
            additions: additions.map(addition => ({
              ...addition,
              contents: fromUint8Array(addition.contents)
            })),
            deletions
          })
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const newTree = await res.json();
        const {
          tree
        } = await hydrateTreeCacheWithEntries(newTree);
        setTreeSha(await treeSha(tree));
        setState({
          kind: 'updated'
        });
        return true;
      }
    } catch (err) {
      setState({
        kind: 'error',
        error: err
      });
      return false;
    }
  }, () => {
    setState({
      kind: 'idle'
    });
  }];
}
const createCommitMutation = gql`
  mutation CreateCommit($input: CreateCommitOnBranchInput!) {
    createCommitOnBranch(input: $input) {
      ref {
        id
        target {
          id
          oid
          ... on Commit {
            tree {
              id
              oid
            }
          }
        }
      }
    }
  }
`;
function useDeleteItem(args) {
  const [state, setState] = useState({
    kind: 'idle'
  });
  const baseCommit = useBaseCommit();
  const branchInfo = useContext(BranchInfoContext);
  const [, mutate] = useMutation(createCommitMutation);
  const setTreeSha = useSetTreeSha();
  const repoWithWriteAccess = useContext(RepoWithWriteAccessContext);
  const appSlug = useContext(AppSlugContext);
  return [state, async () => {
    try {
      if (repoWithWriteAccess === null && args.storage.kind === 'github' && appSlug !== null && appSlug !== void 0 && appSlug.value) {
        setState({
          kind: 'needs-fork'
        });
        return false;
      }
      setState({
        kind: 'loading'
      });
      const updatedTree = await updateTreeWithChanges(args.currentTree, {
        additions: [],
        deletions: args.initialFiles
      });
      await hydrateTreeCacheWithEntries(updatedTree.entries);
      if (args.storage.kind === 'github' || args.storage.kind === 'cloud') {
        const {
          error
        } = await mutate({
          input: {
            branch: {
              repositoryNameWithOwner: `${repoWithWriteAccess.owner}/${repoWithWriteAccess.name}`,
              branchName: branchInfo.currentBranch
            },
            message: {
              headline: `Delete ${args.basePath}`
            },
            expectedHeadOid: baseCommit,
            fileChanges: {
              deletions: args.initialFiles.map(path => ({
                path
              }))
            }
          }
        });
        if (error) {
          throw error;
        }
        setState({
          kind: 'updated'
        });
        return true;
      } else {
        const res = await fetch('/api/keystatic/update', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'no-cors': '1'
          },
          body: JSON.stringify({
            additions: [],
            deletions: args.initialFiles.map(path => ({
              path
            }))
          })
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const newTree = await res.json();
        const {
          tree
        } = await hydrateTreeCacheWithEntries(newTree);
        setTreeSha(await treeSha(tree));
        setState({
          kind: 'updated'
        });
        return true;
      }
    } catch (err) {
      setState({
        kind: 'error',
        error: err
      });
    }
  }, () => {
    setState({
      kind: 'idle'
    });
  }];
}
const FetchRef = gql`
  query FetchRef($owner: String!, $name: String!, $ref: String!) {
    repository(owner: $owner, name: $name) {
      id
      ref(qualifiedName: $ref) {
        id
        target {
          id
          oid
        }
      }
    }
  }
`;

function useHasChanged(args) {
  const initialFilesForUpdate = useMemo(() => args.initialState === null ? null : serializeProps(args.initialState, args.schema, args.slugField, args.slugField ? getSlugFromState({
    schema: args.schema.fields,
    slugField: args.slugField
  }, args.initialState) : undefined, true), [args.initialState, args.schema, args.slugField]);
  const filesForUpdate = useMemo(() => serializeProps(args.state, args.schema, args.slugField, args.slugField ? getSlugFromState({
    schema: args.schema.fields,
    slugField: args.slugField
  }, args.state) : undefined, true), [args.state, args.schema, args.slugField]);
  return useMemo(() => {
    return !isEqual(initialFilesForUpdate, filesForUpdate);
  }, [initialFilesForUpdate, filesForUpdate]);
}

function ItemPage(props) {
  const {
    collection,
    config,
    itemSlug,
    initialFiles,
    initialState,
    localTreeKey,
    currentTree
  } = props;
  const router = useRouter();
  const [forceValidation, setForceValidation] = useState(false);
  const collectionConfig = config.collections[collection];
  const schema = useMemo(() => object(collectionConfig.schema), [collectionConfig.schema]);
  const [{
    state,
    localTreeKey: localTreeKeyInState
  }, setState] = useState({
    state: initialState,
    localTreeKey
  });
  if (localTreeKeyInState !== localTreeKey) {
    setState({
      state: initialState,
      localTreeKey
    });
  }
  const previewProps = useMemo(() => createGetPreviewProps(schema, stateUpdater => {
    setState(state => ({
      localTreeKey: state.localTreeKey,
      state: stateUpdater(state.state)
    }));
  }, () => undefined), [schema])(state);
  const hasChanged = useHasChanged({
    initialState,
    schema,
    state,
    slugField: collectionConfig.slugField
  });
  const baseCommit = useBaseCommit();
  const slug = getSlugFromState(collectionConfig, state);
  const formatInfo = getCollectionFormat(config, collection);
  const currentBasePath = getCollectionItemPath(config, collection, itemSlug);
  const futureBasePath = getCollectionItemPath(config, collection, slug);
  const branchInfo = useBranchInfo();
  const [updateResult, _update, resetUpdateItem] = useUpsertItem({
    state,
    initialFiles,
    config,
    schema: collectionConfig.schema,
    basePath: futureBasePath,
    format: formatInfo,
    currentLocalTreeKey: localTreeKey,
    currentTree,
    slug: {
      field: collectionConfig.slugField,
      value: slug
    }
  });
  const update = useEventCallback(_update);
  const [deleteResult, deleteItem, resetDeleteItem] = useDeleteItem({
    initialFiles,
    storage: config.storage,
    basePath: currentBasePath,
    currentTree
  });
  const onReset = () => {
    setState({
      state: initialState,
      localTreeKey
    });
  };
  const onView = () => {
    assert(isGitHubConfig(config));
    let filePath = formatInfo.dataLocation === 'index' ? `/tree/${branchInfo.currentBranch}/${currentBasePath}` : `/blob/${branchInfo.currentBranch}/${currentBasePath}${getDataFileExtension(formatInfo)}`;
    window.open(`${getRepoUrl(branchInfo)}${filePath}`, '_blank', 'noopener,noreferrer');
  };
  const onDelete = async () => {
    if (await deleteItem()) {
      router.push(`${props.basePath}/collection/${encodeURIComponent(collection)}`);
    }
  };
  const onUpdate = useCallback(async () => {
    if (!clientSideValidateProp(schema, state, props.slugInfo)) {
      setForceValidation(true);
      return;
    }
    const slug = getSlugFromState(collectionConfig, state);
    const hasUpdated = await update();
    if (hasUpdated && slug !== itemSlug) {
      router.replace(`${props.basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(slug)}`);
    }
  }, [collection, collectionConfig, itemSlug, props.basePath, props.slugInfo, router, schema, state, update]);
  const formID = 'item-edit-form';

  // allow shortcuts "cmd+s" and "ctrl+s" to save
  useEffect(() => {
    const listener = event => {
      if (updateResult.kind === 'loading') {
        return;
      }
      if (isHotkey('mod+s', event)) {
        event.preventDefault();
        onUpdate();
      }
    };
    document.addEventListener('keydown', listener);
    return () => document.removeEventListener('keydown', listener);
  }, [updateResult.kind, onUpdate]);
  return /*#__PURE__*/jsx(Fragment, {
    children: /*#__PURE__*/jsxs(ItemPageShell, {
      headerActions: /*#__PURE__*/jsx(HeaderActions, {
        config: config,
        formID: formID,
        isLoading: updateResult.kind === 'loading',
        hasChanged: hasChanged,
        onDelete: onDelete,
        onReset: onReset,
        onView: onView
      }),
      ...props,
      children: [updateResult.kind === 'error' && /*#__PURE__*/jsx(Notice, {
        tone: "critical",
        children: updateResult.error.message
      }), deleteResult.kind === 'error' && /*#__PURE__*/jsx(Notice, {
        tone: "critical",
        children: deleteResult.error.message
      }), /*#__PURE__*/jsx(Box, {
        id: formID,
        height: "100%",
        minHeight: 0,
        minWidth: 0,
        elementType: "form",
        onSubmit: event => {
          if (event.target !== event.currentTarget) return;
          event.preventDefault();
          onUpdate();
        },
        children: /*#__PURE__*/jsx(FormForEntry, {
          previewProps: previewProps,
          forceValidation: forceValidation,
          entryLayout: collectionConfig.entryLayout,
          formatInfo: formatInfo,
          slugField: props.slugInfo
        })
      }), /*#__PURE__*/jsx(DialogContainer
      // ideally this would be a popover on desktop but using a DialogTrigger wouldn't work since
      // this doesn't open on click but after doing a network request and it failing and manually wiring about a popover and modal would be a pain
      , {
        onDismiss: resetUpdateItem,
        children: updateResult.kind === 'needs-new-branch' && /*#__PURE__*/jsx(CreateBranchDuringUpdateDialog, {
          branchOid: baseCommit,
          onCreate: async newBranch => {
            const itemBasePath = `/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(collection)}/item/`;
            router.push(itemBasePath + encodeURIComponent(itemSlug));
            const slug = getSlugFromState(collectionConfig, state);
            const hasUpdated = await update({
              branch: newBranch,
              sha: baseCommit
            });
            if (hasUpdated && slug !== itemSlug) {
              router.replace(itemBasePath + encodeURIComponent(slug));
            }
          },
          reason: updateResult.reason,
          onDismiss: resetUpdateItem
        })
      }), /*#__PURE__*/jsx(DialogContainer
      // ideally this would be a popover on desktop but using a DialogTrigger
      // wouldn't work since this doesn't open on click but after doing a
      // network request and it failing and manually wiring about a popover
      // and modal would be a pain
      , {
        onDismiss: resetUpdateItem,
        children: updateResult.kind === 'needs-fork' && isGitHubConfig(props.config) && /*#__PURE__*/jsx(ForkRepoDialog, {
          onCreate: async () => {
            const slug = getSlugFromState(collectionConfig, state);
            const hasUpdated = await update();
            if (hasUpdated && slug !== itemSlug) {
              router.replace(`${props.basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(slug)}`);
            }
          },
          onDismiss: resetUpdateItem,
          config: props.config
        })
      }), /*#__PURE__*/jsx(DialogContainer
      // ideally this would be a popover on desktop but using a DialogTrigger
      // wouldn't work since this doesn't open on click but after doing a
      // network request and it failing and manually wiring about a popover
      // and modal would be a pain
      , {
        onDismiss: resetDeleteItem,
        children: deleteResult.kind === 'needs-fork' && isGitHubConfig(props.config) && /*#__PURE__*/jsx(ForkRepoDialog, {
          onCreate: async () => {
            await deleteItem();
            router.push(`${props.basePath}/collection/${encodeURIComponent(collection)}`);
          },
          onDismiss: resetDeleteItem,
          config: props.config
        })
      })]
    })
  });
}
function HeaderActions(props) {
  let {
    config,
    formID,
    hasChanged,
    isLoading,
    onDelete,
    onReset,
    onView
  } = props;
  const isBelowTablet = useMediaQuery(breakpointQueries.below.tablet);
  const isGithub = isGitHubConfig(config);
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  const [deleteAlertIsOpen, setDeleteAlertOpen] = useState(false);
  const menuActions = useMemo(() => {
    let items = [{
      key: 'reset',
      label: 'Reset changes',
      // TODO: l10n
      icon: historyIcon
    }, {
      key: 'delete',
      label: 'Delete entry',
      // TODO: l10n
      icon: trash2Icon
    }];
    if (isGithub) {
      items.push({
        key: 'view',
        label: 'View on GitHub',
        icon: externalLinkIcon
      });
    }
    return items;
  }, [isGithub]);
  const indicatorElement = (() => {
    if (isLoading) {
      return /*#__PURE__*/jsx(ProgressCircle, {
        "aria-label": "Saving changes",
        isIndeterminate: true,
        size: "small",
        alignSelf: "center"
      });
    }
    if (hasChanged) {
      return isBelowTablet ? /*#__PURE__*/jsx(Box, {
        backgroundColor: "pendingEmphasis",
        height: "scale.75",
        width: "scale.75",
        borderRadius: "full",
        children: /*#__PURE__*/jsx(Text, {
          visuallyHidden: true,
          children: "Unsaved"
        })
      }) : /*#__PURE__*/jsx(Badge, {
        tone: "pending",
        children: "Unsaved"
      });
    }
    return null;
  })();
  return /*#__PURE__*/jsxs(Fragment, {
    children: [indicatorElement, /*#__PURE__*/jsx(ActionGroup, {
      buttonLabelBehavior: "hide",
      overflowMode: "collapse",
      prominence: "low",
      density: "compact",
      maxWidth: isBelowTablet ? 'element.regular' : undefined // force switch to action menu on small devices
      ,
      items: menuActions,
      disabledKeys: hasChanged ? [] : ['reset'],
      onAction: key => {
        switch (key) {
          case 'reset':
            onReset();
            break;
          case 'delete':
            setDeleteAlertOpen(true);
            break;
          case 'view':
            onView();
            break;
        }
      },
      children: item => /*#__PURE__*/jsxs(Item$1, {
        textValue: item.label,
        children: [/*#__PURE__*/jsx(Icon, {
          src: item.icon
        }), /*#__PURE__*/jsx(Text, {
          children: item.label
        })]
      }, item.key)
    }), /*#__PURE__*/jsx(Button, {
      form: formID,
      isDisabled: isLoading,
      prominence: "high",
      type: "submit",
      children: stringFormatter.format('save')
    }), /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: () => setDeleteAlertOpen(false),
      children: deleteAlertIsOpen && /*#__PURE__*/jsx(AlertDialog, {
        title: "Delete entry",
        tone: "critical",
        cancelLabel: "Cancel",
        primaryActionLabel: "Yes, delete",
        autoFocusButton: "cancel",
        onPrimaryAction: onDelete,
        children: "Are you sure? This action cannot be undone."
      })
    })]
  });
}
function CreateBranchDuringUpdateDialog(props) {
  var _data$createRef;
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  const repositoryId = useRepositoryId();
  const [branchName, setBranchName] = useState('');
  const [{
    error,
    fetching,
    data
  }, createBranch] = useCreateBranchMutation();
  const isLoading = fetching || !!(data !== null && data !== void 0 && (_data$createRef = data.createRef) !== null && _data$createRef !== void 0 && _data$createRef.__typename);
  return /*#__PURE__*/jsx(Dialog, {
    children: /*#__PURE__*/jsxs("form", {
      style: {
        display: 'contents'
      },
      onSubmit: async event => {
        var _result$data;
        if (event.target !== event.currentTarget) return;
        event.preventDefault();
        const name = `refs/heads/${branchName}`;
        const result = await createBranch({
          input: {
            name,
            oid: props.branchOid,
            repositoryId
          }
        });
        if ((_result$data = result.data) !== null && _result$data !== void 0 && (_result$data = _result$data.createRef) !== null && _result$data !== void 0 && _result$data.__typename) {
          props.onCreate(branchName);
        }
      },
      children: [/*#__PURE__*/jsx(Heading, {
        children: stringFormatter.format('newBranch')
      }), /*#__PURE__*/jsx(Content, {
        children: /*#__PURE__*/jsx(Flex, {
          gap: "large",
          direction: "column",
          children: /*#__PURE__*/jsx(TextField, {
            value: branchName,
            onChange: setBranchName,
            label: "Branch name",
            description: props.reason,
            autoFocus: true,
            errorMessage: error === null || error === void 0 ? void 0 : error.message
          })
        })
      }), /*#__PURE__*/jsxs(ButtonGroup, {
        children: [isLoading && /*#__PURE__*/jsx(ProgressCircle, {
          isIndeterminate: true,
          size: "small",
          "aria-label": "Creating Branch"
        }), /*#__PURE__*/jsx(Button, {
          isDisabled: isLoading,
          onPress: props.onDismiss,
          children: stringFormatter.format('cancel')
        }), /*#__PURE__*/jsx(Button, {
          isDisabled: isLoading,
          prominence: "high",
          type: "submit",
          children: "Create branch and save"
        })]
      })]
    })
  });
}
function ItemPageWrapper(props) {
  var _props$config$collect;
  const collectionConfig = (_props$config$collect = props.config.collections) === null || _props$config$collect === void 0 ? void 0 : _props$config$collect[props.collection];
  if (!collectionConfig) notFound();
  const format = useMemo(() => getCollectionFormat(props.config, props.collection), [props.config, props.collection]);
  const allSlugs = useSlugsInCollection(props.collection);
  const slugInfo = useMemo(() => {
    const slugs = new Set(allSlugs);
    slugs.delete(props.itemSlug);
    return {
      slug: props.itemSlug,
      field: collectionConfig.slugField,
      slugs,
      glob: getSlugGlobForCollection(props.config, props.collection)
    };
  }, [allSlugs, collectionConfig.slugField, props.collection, props.config, props.itemSlug]);
  const itemData = useItemData({
    config: props.config,
    dirpath: getCollectionItemPath(props.config, props.collection, props.itemSlug),
    schema: collectionConfig.schema,
    format,
    slug: slugInfo
  });
  const {
    current: tree
  } = useTree();
  const combined = useMemo(() => mergeDataStates({
    item: itemData,
    tree
  }), [itemData, tree]);
  if (combined.kind === 'error') {
    return /*#__PURE__*/jsx(ItemPageShell, {
      ...props,
      children: /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Notice, {
          tone: "critical",
          children: combined.error.message
        })
      })
    });
  }
  if (combined.kind === 'loading') {
    return /*#__PURE__*/jsx(ItemPageShell, {
      ...props,
      children: /*#__PURE__*/jsx(Flex, {
        alignItems: "center",
        justifyContent: "center",
        minHeight: "scale.3000",
        children: /*#__PURE__*/jsx(ProgressCircle, {
          "aria-label": "Loading Item",
          isIndeterminate: true,
          size: "large"
        })
      })
    });
  }
  if (combined.data.item === 'not-found') {
    return /*#__PURE__*/jsx(ItemPageShell, {
      ...props,
      children: /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Notice, {
          tone: "caution",
          children: "Entry not found."
        })
      })
    });
  }
  return /*#__PURE__*/jsx(ItemPage, {
    collection: props.collection,
    basePath: props.basePath,
    config: props.config,
    itemSlug: props.itemSlug,
    initialState: combined.data.item.initialState,
    initialFiles: combined.data.item.initialFiles,
    localTreeKey: combined.data.item.localTreeKey,
    currentTree: combined.data.tree.tree,
    slugInfo: slugInfo
  });
}
const ItemPageShell = props => {
  const router = useRouter();
  const collectionConfig = props.config.collections[props.collection];
  return /*#__PURE__*/jsxs(PageRoot, {
    containerWidth: containerWidthForEntryLayout(collectionConfig),
    children: [/*#__PURE__*/jsxs(PageHeader, {
      children: [/*#__PURE__*/jsxs(Breadcrumbs, {
        flex: true,
        size: "medium",
        minWidth: 0,
        onAction: key => {
          if (key === 'collection') {
            router.push(`${props.basePath}/collection/${encodeURIComponent(props.collection)}`);
          }
        },
        children: [/*#__PURE__*/jsx(Item$1, {
          children: collectionConfig.label
        }, "collection"), /*#__PURE__*/jsx(Item$1, {
          children: props.itemSlug
        }, "item")]
      }), props.headerActions]
    }), props.children]
  });
};

const emptyMap = new Map();
function CreateItem(props) {
  var _props$config$collect;
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  const router = useRouter();
  const collectionConfig = (_props$config$collect = props.config.collections) === null || _props$config$collect === void 0 ? void 0 : _props$config$collect[props.collection];
  if (!collectionConfig) notFound();
  const [forceValidation, setForceValidation] = useState(false);
  const schema = useMemo(() => object(collectionConfig.schema), [collectionConfig.schema]);
  const [state, setState] = useState(() => getInitialPropsValue(schema));
  const previewProps = useMemo(() => createGetPreviewProps(schema, setState, () => undefined), [schema])(state);
  const baseCommit = useBaseCommit();
  const tree = useTree();
  const slug = getSlugFromState(collectionConfig, state);
  const formatInfo = getCollectionFormat(props.config, props.collection);
  const [createResult, _createItem, resetCreateItemState] = useUpsertItem({
    state,
    basePath: getCollectionItemPath(props.config, props.collection, slug),
    initialFiles: undefined,
    config: props.config,
    schema: collectionConfig.schema,
    format: formatInfo,
    currentLocalTreeKey: undefined,
    currentTree: tree.current.kind === 'loaded' ? tree.current.data.tree : emptyMap,
    slug: {
      field: collectionConfig.slugField,
      value: slug
    }
  });
  const createItem = useEventCallback(_createItem);
  let collectionPath = `${props.basePath}/collection/${encodeURIComponent(props.collection)}`;
  const slugsArr = useSlugsInCollection(props.collection);
  const currentSlug = createResult.kind === 'updated' || createResult.kind === 'loading' ? slug : undefined;
  const slugInfo = useMemo(() => {
    const slugs = new Set(slugsArr);
    if (currentSlug) {
      slugs.delete(currentSlug);
    }
    return {
      field: collectionConfig.slugField,
      slugs,
      glob: getSlugGlobForCollection(props.config, props.collection)
    };
  }, [slugsArr, currentSlug, collectionConfig.slugField, props.config, props.collection]);
  const onCreate = async () => {
    if (!clientSideValidateProp(schema, state, slugInfo)) {
      setForceValidation(true);
      return;
    }
    if (await createItem()) {
      const slug = getSlugFromState(collectionConfig, state);
      router.push(`${collectionPath}/item/${encodeURIComponent(slug)}`);
      toastQueue.positive('Entry created', {
        timeout: 5000
      }); // TODO: l10n
    }
  };

  // note we're still "loading" when it's already been created
  // since we're waiting to go to the item page
  const isLoading = createResult.kind === 'loading' || createResult.kind === 'updated';
  const formID = 'item-create-form';
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsxs(PageRoot, {
      containerWidth: containerWidthForEntryLayout(collectionConfig),
      children: [/*#__PURE__*/jsxs(PageHeader, {
        children: [/*#__PURE__*/jsxs(Breadcrumbs, {
          size: "medium",
          flex: true,
          minWidth: 0,
          onAction: key => {
            if (key === 'collection') {
              router.push(collectionPath);
            }
          },
          children: [/*#__PURE__*/jsx(Item$1, {
            children: collectionConfig.label
          }, "collection"), /*#__PURE__*/jsx(Item$1, {
            children: stringFormatter.format('add')
          }, "current")]
        }), isLoading && /*#__PURE__*/jsx(ProgressCircle, {
          "aria-label": "Creating entry",
          isIndeterminate: true,
          size: "small"
        }), /*#__PURE__*/jsx(Button, {
          isDisabled: isLoading,
          prominence: "high",
          type: "submit",
          form: formID,
          marginStart: "auto",
          children: stringFormatter.format('create')
        })]
      }), /*#__PURE__*/jsxs(Flex, {
        id: formID,
        elementType: "form",
        onSubmit: event => {
          if (event.target !== event.currentTarget) return;
          event.preventDefault();
          onCreate();
        },
        direction: "column",
        gap: "xxlarge",
        height: "100%",
        minHeight: 0,
        minWidth: 0,
        children: [createResult.kind === 'error' && /*#__PURE__*/jsx(Notice, {
          tone: "critical",
          children: createResult.error.message
        }), /*#__PURE__*/jsx(FormForEntry, {
          previewProps: previewProps,
          forceValidation: forceValidation,
          entryLayout: collectionConfig.entryLayout,
          formatInfo: formatInfo,
          slugField: slugInfo
        })]
      })]
    }), /*#__PURE__*/jsx(DialogContainer
    // ideally this would be a popover on desktop but using a DialogTrigger
    // wouldn't work since this doesn't open on click but after doing a
    // network request and it failing and manually wiring about a popover
    // and modal would be a pain
    , {
      onDismiss: resetCreateItemState,
      children: createResult.kind === 'needs-new-branch' && /*#__PURE__*/jsx(CreateBranchDuringUpdateDialog, {
        branchOid: baseCommit,
        onCreate: async newBranch => {
          router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(props.collection)}/create`);
          if (await createItem({
            branch: newBranch,
            sha: baseCommit
          })) {
            const slug = getSlugFromState(collectionConfig, state);
            router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(props.collection)}/item/${encodeURIComponent(slug)}`);
          }
        },
        reason: createResult.reason,
        onDismiss: resetCreateItemState
      })
    }), /*#__PURE__*/jsx(DialogContainer
    // ideally this would be a popover on desktop but using a DialogTrigger
    // wouldn't work since this doesn't open on click but after doing a
    // network request and it failing and manually wiring about a popover
    // and modal would be a pain
    , {
      onDismiss: resetCreateItemState,
      children: createResult.kind === 'needs-fork' && isGitHubConfig(props.config) && /*#__PURE__*/jsx(ForkRepoDialog, {
        onCreate: async () => {
          if (await createItem()) {
            const slug = getSlugFromState(collectionConfig, state);
            router.push(`${collectionPath}/item/${encodeURIComponent(slug)}`);
          }
        },
        onDismiss: resetCreateItemState,
        config: props.config
      })
    })]
  });
}

const DashboardSection = ({
  children,
  title
}) => {
  return /*#__PURE__*/jsxs(Flex, {
    elementType: "section",
    direction: "column",
    gap: "medium",
    children: [/*#__PURE__*/jsx(Text, {
      casing: "uppercase",
      color: "neutralTertiary",
      size: "small",
      weight: "bold",
      elementType: "h2",
      children: title
    }), children]
  });
};
const DashboardGrid = props => {
  return /*#__PURE__*/jsx("div", {
    className: css({
      display: 'grid',
      gap: tokenSchema.size.space.large,
      gridAutoRows: tokenSchema.size.element.xlarge,
      [containerQueries.above.mobile]: {
        gridTemplateColumns: '1fr 1fr'
      },
      [containerQueries.above.tablet]: {
        gridTemplateColumns: '1fr 1fr 1fr'
      }
    }),
    ...props
  });
};
const DashboardCard = props => {
  let Link = useLinkComponent(null);
  return /*#__PURE__*/jsxs(Flex, {
    alignItems: "center",
    backgroundColor: "canvas",
    padding: "large",
    position: "relative",
    children: [/*#__PURE__*/jsxs(Flex, {
      direction: "column",
      gap: "medium",
      flex: true,
      children: [/*#__PURE__*/jsx(Heading, {
        elementType: "h3",
        size: "small",
        truncate: true,
        children: /*#__PURE__*/jsx(Link, {
          href: props.href,
          className: classNames(css({
            color: tokenSchema.color.foreground.neutral,
            outline: 'none',
            '&:hover': {
              color: tokenSchema.color.foreground.neutralEmphasis,
              '::before': {
                backgroundColor: tokenSchema.color.alias.backgroundIdle,
                borderColor: tokenSchema.color.border.neutral
              }
            },
            '&:active': {
              '::before': {
                backgroundColor: tokenSchema.color.alias.backgroundHovered,
                borderColor: tokenSchema.color.alias.borderHovered
              }
            },
            '&:focus-visible::before': {
              outline: `${tokenSchema.size.alias.focusRing} solid ${tokenSchema.color.alias.focusRing}`,
              outlineOffset: tokenSchema.size.alias.focusRingGap
            },
            // fill the available space so that the card is clickable
            '::before': {
              border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.muted}`,
              borderRadius: tokenSchema.size.radius.medium,
              content: '""',
              position: 'absolute',
              inset: 0,
              transition: transition(['background-color', 'border-color'])
            }
          })),
          children: props.label
        })
      }), props.children]
    }), props.endElement]
  });
};

function useLocalizedString() {
  let stringFormatter = useLocalizedStringFormatter(localizedMessages);
  return stringFormatter;
}

function BranchSection(props) {
  let branchInfo = useBranchInfo();
  let router = useRouter();
  let localizedString = useLocalizedString();
  if (isLocalConfig(props.config)) {
    return null;
  }
  let repoURL = getRepoUrl(branchInfo);
  let isDefaultBranch = branchInfo.currentBranch === branchInfo.defaultBranch;
  return /*#__PURE__*/jsxs(DashboardSection, {
    title: localizedString.format('currentBranch'),
    children: [/*#__PURE__*/jsxs(Flex, {
      alignItems: "center",
      gap: "regular",
      border: "muted",
      borderRadius: "medium",
      backgroundColor: "canvas",
      padding: "large",
      children: [/*#__PURE__*/jsx(Icon, {
        src: gitBranchIcon,
        color: "neutralTertiary"
      }), /*#__PURE__*/jsx(Text, {
        size: "medium",
        weight: "semibold",
        children: branchInfo.currentBranch
      })]
    }), /*#__PURE__*/jsxs(Flex, {
      gap: "regular",
      wrap: true,
      children: [/*#__PURE__*/jsxs(DialogTrigger, {
        children: [/*#__PURE__*/jsxs(ActionButton, {
          children: [/*#__PURE__*/jsx(Icon, {
            src: gitBranchPlusIcon
          }), /*#__PURE__*/jsx(Text, {
            children: localizedString.format('newBranch')
          })]
        }), close => /*#__PURE__*/jsx(CreateBranchDialog, {
          onDismiss: close,
          onCreate: branchName => {
            close();
            router.push(router.href.replace(/\/branch\/[^/]+/, '/branch/' + encodeURIComponent(branchName)));
          }
        })]
      }), !isDefaultBranch && /*#__PURE__*/jsxs(ActionButton, {
        href: `${repoURL}/pull/new/${branchInfo.currentBranch}`,
        target: "_blank",
        children: [/*#__PURE__*/jsx(Icon, {
          src: gitPullRequestIcon
        }), /*#__PURE__*/jsx(Text, {
          children: localizedString.format('createPullRequest')
        })]
      })]
    })]
  });
}

function CollectionSection(props) {
  var _props$config$collect;
  let localizedString = useLocalizedString();
  let changed = useChanged();
  let collections = keyedEntries((_props$config$collect = props.config.collections) !== null && _props$config$collect !== void 0 ? _props$config$collect : {});
  return /*#__PURE__*/jsx(DashboardSection, {
    title: "Collections",
    children: /*#__PURE__*/jsx(DashboardGrid, {
      children: collections.map(collection => {
        var _counts$totalCount;
        let counts = changed.collections.get(collection.key);
        let totalCount = (_counts$totalCount = counts === null || counts === void 0 ? void 0 : counts.totalCount) !== null && _counts$totalCount !== void 0 ? _counts$totalCount : 0;
        let changes = counts ? counts.added.size + counts.changed.size + counts.removed.size : 0;
        return /*#__PURE__*/jsx(DashboardCard, {
          label: collection.label,
          href: `${props.basePath}/collection/${encodeURIComponent(collection.key)}`,
          endElement: /*#__PURE__*/jsxs(Flex, {
            gap: "medium",
            alignItems: "center",
            children: [changes > 0 && /*#__PURE__*/jsx(Badge, {
              tone: "accent",
              children: pluralize(changes, {
                singular: 'change',
                plural: 'changes'
              })
            }), /*#__PURE__*/jsx(ActionButton, {
              "aria-label": localizedString.format('add'),
              href: `${props.basePath}/collection/${encodeURIComponent(collection.key)}/create`,
              children: /*#__PURE__*/jsx(Icon, {
                src: plusIcon
              })
            })]
          }),
          children: /*#__PURE__*/jsx(Text, {
            color: "neutralSecondary",
            children: pluralize(totalCount, {
              singular: 'entry',
              plural: 'entries'
            })
          })
        }, collection.key);
      })
    })
  });
}

function SingletonSection(props) {
  var _props$config$singlet;
  let changed = useChanged();
  let singletons = keyedEntries((_props$config$singlet = props.config.singletons) !== null && _props$config$singlet !== void 0 ? _props$config$singlet : {});
  if (singletons.length === 0) {
    return null;
  }
  return /*#__PURE__*/jsx(DashboardSection, {
    title: "Singletons",
    children: /*#__PURE__*/jsx(DashboardGrid, {
      children: singletons.map(singleton => {
        let changes = changed.singletons.has(singleton.key);
        return /*#__PURE__*/jsx(DashboardCard, {
          label: singleton.label,
          href: `${props.basePath}/singleton/${encodeURIComponent(singleton.key)}`,
          endElement: changes ? /*#__PURE__*/jsx(Badge, {
            tone: "accent",
            children: "Changed"
          }) : /*#__PURE__*/jsx(Badge, {
            children: "Unchanged"
          })
        }, singleton.key);
      })
    })
  });
}

function DashboardPage(props) {
  var _user$name, _user$name2;
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  const user = useViewer();
  return /*#__PURE__*/jsxs(PageRoot, {
    containerWidth: "large",
    children: [/*#__PURE__*/jsx(PageHeader, {
      children: /*#__PURE__*/jsx(Heading, {
        elementType: "h1",
        id: "page-title",
        size: "small",
        children: stringFormatter.format('dashboard')
      })
    }), /*#__PURE__*/jsx(PageBody, {
      isScrollable: true,
      children: /*#__PURE__*/jsxs(Flex, {
        direction: "column",
        gap: "xxlarge",
        children: [user && /*#__PURE__*/jsxs(Flex, {
          alignItems: "center",
          gap: "medium",
          isHidden: {
            below: 'tablet'
          },
          children: [/*#__PURE__*/jsx(Avatar, {
            src: user.avatarUrl,
            name: (_user$name = user.name) !== null && _user$name !== void 0 ? _user$name : undefined,
            size: "large"
          }), /*#__PURE__*/jsxs(Heading, {
            size: "medium",
            elementType: "p",
            UNSAFE_style: {
              fontWeight: tokenSchema.typography.fontWeight.bold
            },
            children: ["Hello, ", (_user$name2 = user.name) !== null && _user$name2 !== void 0 ? _user$name2 : user.login, "!"]
          })]
        }), /*#__PURE__*/jsx(BranchSection, {
          config: props.config
        }), /*#__PURE__*/jsx(CollectionSection, {
          basePath: props.basePath,
          config: props.config
        }), /*#__PURE__*/jsx(SingletonSection, {
          basePath: props.basePath,
          config: props.config
        })]
      })
    })]
  });
}

const TopBar = () => {
  let config = useConfig();
  if (isCloudConfig(config)) {
    return /*#__PURE__*/jsx(CloudHeader, {
      config: config
    });
  }
  if (isGitHubConfig(config)) {
    return /*#__PURE__*/jsx(GithubHeader, {
      config: config
    });
  }
  if (isLocalConfig(config)) {
    return /*#__PURE__*/jsx(LocalHeader, {});
  }
  throw new Error('Unknown config type.');
};

// Cloud
// -----------------------------------------------------------------------------

function CloudHeader({
  config
}) {
  return /*#__PURE__*/jsxs(HeaderOuter, {
    children: [/*#__PURE__*/jsx(BrandButton, {}), /*#__PURE__*/jsx(Text, {
      color: "neutralEmphasis",
      weight: "semibold",
      marginX: "regular",
      truncate: true,
      isHidden: {
        below: 'tablet'
      },
      children: config.cloud.project
    }), /*#__PURE__*/jsx(Slash, {}), /*#__PURE__*/jsx(BranchPicker, {}), /*#__PURE__*/jsx(GitMenu, {}), /*#__PURE__*/jsx(Box, {
      flex: "1"
    }), /*#__PURE__*/jsx(ThemeMenu, {})]
  });
}

// Github
// -----------------------------------------------------------------------------

function GithubHeader({
  config
}) {
  return /*#__PURE__*/jsxs(HeaderOuter, {
    children: [/*#__PURE__*/jsx(BrandButton, {}), /*#__PURE__*/jsx(Button, {
      href: `https://github.com/${serializeRepoConfig(config.storage.repo)}`,
      target: "_blank",
      rel: "noopener noreferrer",
      prominence: "low",
      isHidden: {
        below: 'tablet'
      },
      UNSAFE_className: css({
        paddingInline: tokenSchema.size.space.regular
      }),
      children: serializeRepoConfig(config.storage.repo)
    }), /*#__PURE__*/jsx(Slash, {}), /*#__PURE__*/jsx(BranchPicker, {}), /*#__PURE__*/jsx(GitMenu, {}), /*#__PURE__*/jsx(Box, {
      flex: "1"
    }), /*#__PURE__*/jsx(ThemeMenu, {}), /*#__PURE__*/jsx(UserMenu, {})]
  });
}

// Local
// -----------------------------------------------------------------------------

function LocalHeader() {
  return /*#__PURE__*/jsxs(HeaderOuter, {
    children: [/*#__PURE__*/jsx(BrandButton, {}), /*#__PURE__*/jsx(Text, {
      color: "neutralEmphasis",
      weight: "semibold",
      children: "Keystatic"
    }), /*#__PURE__*/jsx(Box, {
      flex: "1"
    }), /*#__PURE__*/jsx(ThemeMenu, {})]
  });
}

// =============================================================================
// Misc.
// =============================================================================

function BrandButton() {
  let {
    basePath
  } = useAppState();
  return /*#__PURE__*/jsx(Button, {
    "aria-label": "dashboard",
    prominence: "low",
    href: basePath,
    UNSAFE_style: {
      marginInlineStart: `calc(${tokenSchema.size.space.regular} * -1)`,
      padding: 0
    },
    children: /*#__PURE__*/jsx(ZapLogo, {})
  });
}
function Slash() {
  return /*#__PURE__*/jsx(Text, {
    "aria-hidden": true,
    color: "neutralTertiary",
    role: "presentation",
    isHidden: {
      below: 'tablet'
    },
    UNSAFE_className: css({
      userSelect: 'none'
    }),
    children: "/"
  });
}
function HeaderOuter({
  children
}) {
  return /*#__PURE__*/jsx(Flex, {
    elementType: "header"
    // styles
    ,
    alignItems: "center",
    borderBottom: "muted",
    flexShrink: 0,
    gap: "small",
    height: {
      mobile: 'element.large',
      tablet: 'scale.700'
    },
    paddingX: {
      mobile: 'medium',
      tablet: 'xlarge'
    },
    paddingEnd: {
      desktop: 'xxlarge'
    },
    children: children
  });
}

// Theme controls
// -----------------------------------------------------------------------------

const THEME_MODE = {
  light: {
    icon: sunIcon,
    label: 'Light'
  },
  dark: {
    icon: moonIcon,
    label: 'Dark'
  },
  auto: {
    icon: monitorIcon,
    label: 'System'
  }
};
const themeItems = Object.entries(THEME_MODE).map(([id, {
  icon,
  label
}]) => ({
  id,
  icon,
  label
}));
function ThemeMenu() {
  let {
    theme,
    setTheme
  } = useThemeContext();
  let matchesDark = useMediaQuery('(prefers-color-scheme: dark)');
  let icon = THEME_MODE[theme].icon;
  if (theme === 'auto') {
    icon = matchesDark ? moonIcon : sunIcon;
  }
  return /*#__PURE__*/jsxs(MenuTrigger, {
    children: [/*#__PURE__*/jsx(ActionButton, {
      "aria-label": "Theme",
      prominence: "low",
      UNSAFE_className: css({
        borderRadius: '50%',
        padding: 0
      }),
      children: /*#__PURE__*/jsx(Icon, {
        src: icon
      })
    }), /*#__PURE__*/jsx(Menu, {
      items: themeItems,
      onSelectionChange: ([key]) => setTheme(key),
      disallowEmptySelection: true,
      selectedKeys: [theme],
      selectionMode: "single",
      children: item => /*#__PURE__*/jsxs(Item$2, {
        textValue: item.label,
        children: [/*#__PURE__*/jsx(Icon, {
          src: item.icon
        }), /*#__PURE__*/jsx(Text, {
          children: item.label
        })]
      })
    })]
  });
}

// User controls
// -----------------------------------------------------------------------------

function UserMenu() {
  var _user$name, _user$name2, _user$name3;
  let user = useViewer();
  let config = useConfig();
  const menuItems = useMemo(() => {
    let items = [{
      id: 'logout',
      label: 'Log out',
      icon: logOutIcon
    }];
    if (isCloudConfig(config)) {
      items.unshift({
        id: 'manage',
        label: 'Manage account',
        icon: userIcon
      });
    }
    return items;
  }, [config]);
  if (!user) {
    return null;
  }
  return /*#__PURE__*/jsxs(MenuTrigger, {
    children: [/*#__PURE__*/jsx(ActionButton, {
      "aria-label": "User menu",
      prominence: "low",
      UNSAFE_className: css({
        borderRadius: '50%',
        padding: 0
      }),
      children: /*#__PURE__*/jsx(Avatar, {
        src: user.avatarUrl,
        name: (_user$name = user.name) !== null && _user$name !== void 0 ? _user$name : undefined,
        size: "small"
      })
    }), /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsxs(Flex, {
        borderBottom: "muted",
        gap: "regular",
        marginX: "regular",
        paddingY: "regular",
        paddingEnd: "xxlarge",
        alignItems: "center",
        UNSAFE_className: css({
          userSelect: 'none'
        }),
        "aria-hidden": true,
        children: [/*#__PURE__*/jsx(Avatar, {
          src: user.avatarUrl,
          name: (_user$name2 = user.name) !== null && _user$name2 !== void 0 ? _user$name2 : undefined,
          size: "small"
        }), /*#__PURE__*/jsxs(Flex, {
          direction: "column",
          gap: "small",
          children: [/*#__PURE__*/jsx(Text, {
            size: "small",
            weight: "semibold",
            color: "neutralEmphasis",
            children: (_user$name3 = user.name) !== null && _user$name3 !== void 0 ? _user$name3 : user.login
          }), /*#__PURE__*/jsx(Text, {
            size: "small",
            color: "neutralTertiary",
            children: user.login
          })]
        })]
      }), /*#__PURE__*/jsx(Menu, {
        items: menuItems,
        minWidth: "scale.2400",
        onAction: key => {
          switch (key) {
            case 'manage':
              openBlankTargetSafely('https://keystatic.cloud/account');
              break;
            case 'logout':
              switch (config.storage.kind) {
                case 'github':
                  window.location.href = '/api/keystatic/github/logout';
                  break;
                case 'cloud':
                  localStorage.removeItem('keystatic-cloud-access-token');
                  window.location.reload();
                  break;
              }
          }
        },
        children: item => /*#__PURE__*/jsxs(Item$2, {
          textValue: item.label,
          children: [/*#__PURE__*/jsx(Icon, {
            src: item.icon
          }), /*#__PURE__*/jsx(Text, {
            children: item.label
          })]
        })
      })]
    })]
  });
}

// Git controls
// -----------------------------------------------------------------------------

function GitMenu() {
  var _appShellData$data, _appShellData$data$re;
  const stringFormatter = useLocalizedStringFormatter(localizedMessages);
  const data = useContext(BranchInfoContext);
  const [newBranchDialogVisible, toggleNewBranchDialog] = useReducer(v => !v, false);
  const [deleteBranchDialogVisible, toggleDeleteBranchDialog] = useReducer(v => !v, false);
  const [, deleteBranch] = useMutation(gql`
      mutation DeleteBranch($refId: ID!) {
        deleteRef(input: { refId: $refId }) {
          __typename
        }
      }
    `);
  const appShellData = useContext(GitHubAppShellDataContext);
  const fork = (appShellData === null || appShellData === void 0 || (_appShellData$data = appShellData.data) === null || _appShellData$data === void 0 ? void 0 : _appShellData$data.repository) && 'forks' in appShellData.data.repository && ((_appShellData$data$re = appShellData.data.repository.forks.nodes) === null || _appShellData$data$re === void 0 ? void 0 : _appShellData$data$re[0]);
  const gitMenuItems = useMemo(() => {
    let isDefaultBranch = data.currentBranch === data.defaultBranch;
    let items = [];
    let branchSection = [{
      key: 'new-branch',
      icon: gitBranchPlusIcon,
      label: stringFormatter.format('newBranch')
    }];
    let prSection = [];
    let repoSection = [{
      key: 'repo',
      icon: githubIcon,
      label: 'Github repo' // TODO: l10n
    }];

    if (!isDefaultBranch) {
      prSection.push({
        key: 'create-pull-request',
        icon: gitPullRequestIcon,
        label: stringFormatter.format('createPullRequest')
      });
      if (!data.hasPullRequests) {
        branchSection.push({
          key: 'delete-branch',
          icon: trash2Icon,
          label: stringFormatter.format('deleteBranch')
        });
      }
    }
    if (data.hasPullRequests) {
      prSection.push({
        key: 'related-pull-requests',
        icon: listTodoIcon,
        label: stringFormatter.format('viewPullRequests')
      });
    }
    if (fork) {
      repoSection.push({
        key: 'fork',
        icon: gitForkIcon,
        label: 'View fork' // TODO: l10n
      });
    }

    if (branchSection.length) {
      items.push({
        key: 'branch-section',
        label: stringFormatter.format('branches'),
        children: branchSection
      });
    }
    if (prSection.length) {
      items.push({
        key: 'pr-section',
        label: stringFormatter.format('pullRequests'),
        children: prSection
      });
    }
    if (repoSection.length) {
      items.push({
        key: 'repo-section',
        label: 'Repository',
        // TODO: l10n
        children: repoSection
      });
    }
    return items;
  }, [fork, data.currentBranch, data.defaultBranch, data.hasPullRequests, stringFormatter]);
  const router = useRouter();
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(ActionMenu, {
      "aria-label": "git actions",
      prominence: "low",
      items: gitMenuItems,
      onAction: key => {
        let repoURL = getRepoUrl(data);
        switch (key) {
          case 'new-branch':
            toggleNewBranchDialog();
            break;
          case 'delete-branch':
            {
              toggleDeleteBranchDialog();
              break;
            }
          case 'related-pull-requests':
            let query = [['is', 'pr'], ['is', 'open'], ['head', data.currentBranch]].map(([key, value]) => encodeURIComponent(`${key}:${value}`)).join('+');
            openBlankTargetSafely(`${repoURL}/pulls?q=${query}`);
            break;
          case 'create-pull-request':
            openBlankTargetSafely(`${repoURL}/pull/new/${data.currentBranch}`);
            break;
          case 'repo':
            openBlankTargetSafely(repoURL);
            break;
          case 'fork':
            assert(!!fork);
            openBlankTargetSafely(`https://github.com/${fork.owner.login}/${fork.name}`);
        }
      },
      children: item => /*#__PURE__*/jsx(Section, {
        items: item.children,
        "aria-label": item.label,
        children: item => /*#__PURE__*/jsxs(Item$2, {
          textValue: item.label,
          children: [/*#__PURE__*/jsx(Icon, {
            src: item.icon
          }), /*#__PURE__*/jsx(Text, {
            children: item.label
          })]
        }, item.key)
      }, item.key)
    }), /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: toggleNewBranchDialog,
      children: newBranchDialogVisible && /*#__PURE__*/jsx(CreateBranchDialog, {
        onDismiss: toggleNewBranchDialog,
        onCreate: branchName => {
          toggleNewBranchDialog();
          router.push(router.href.replace(/\/branch\/[^/]+/, '/branch/' + encodeURIComponent(branchName)));
        }
      })
    }), /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: toggleDeleteBranchDialog,
      children: deleteBranchDialogVisible && /*#__PURE__*/jsxs(AlertDialog, {
        title: "Delete branch",
        tone: "critical",
        cancelLabel: "Cancel",
        primaryActionLabel: "Yes, delete",
        autoFocusButton: "cancel",
        onPrimaryAction: async () => {
          await deleteBranch({
            refId: data.branchNameToId.get(data.currentBranch)
          });
          router.push(router.href.replace(/\/branch\/[^/]+/, '/branch/' + encodeURIComponent(data.defaultBranch)));
        },
        children: ["Are you sure you want to delete the \"", data.currentBranch, "\" branch? This cannot be undone."]
      })
    })]
  });
}

// ============================================================================
// Utils
// ============================================================================

function openBlankTargetSafely(url) {
  window.open(url, '_blank', 'noopener,noreferrer');
}

const MainPanelLayout = props => {
  let {
    basePath,
    children,
    config
  } = props;
  let isBelowDesktop = useMediaQuery(breakpointQueries.below.desktop);
  let sidebarState = useSidebar();
  let ref = useRef(null);
  let context = useContentPanelState(ref);
  return /*#__PURE__*/jsx(ContentPanelProvider, {
    value: context,
    children: /*#__PURE__*/jsxs(SplitView, {
      autoSaveId: "keystatic-app-split-view",
      isCollapsed: isBelowDesktop || !sidebarState.isOpen,
      onCollapseChange: sidebarState.toggle,
      defaultSize: 260,
      minSize: 180,
      maxSize: 400,
      flex: true,
      children: [isBelowDesktop ? /*#__PURE__*/jsx(SidebarDialog, {
        hrefBase: basePath,
        config: config
      }) : /*#__PURE__*/jsx(SplitPanePrimary, {
        children: /*#__PURE__*/jsx(SidebarPanel, {
          hrefBase: basePath,
          config: config
        })
      }), /*#__PURE__*/jsx(SplitPaneSecondary, {
        ref: ref,
        children: children
      })]
    })
  });
};

const AppShell = props => {
  const content = /*#__PURE__*/jsx(AppShellErrorContext.Consumer, {
    children: error => error && !(error !== null && error !== void 0 && error.graphQLErrors.some(err => {
      var _err$originalError;
      return (err === null || err === void 0 || (_err$originalError = err.originalError) === null || _err$originalError === void 0 ? void 0 : _err$originalError.type) === 'NOT_FOUND';
    })) ? /*#__PURE__*/jsx(EmptyState, {
      icon: alertCircleIcon,
      title: "Failed to load shell",
      message: error.message
    }) : props.children
  });
  const inner = /*#__PURE__*/jsx(ConfigContext.Provider, {
    value: props.config,
    children: /*#__PURE__*/jsx(AppStateContext.Provider, {
      value: {
        basePath: props.basePath
      },
      children: /*#__PURE__*/jsx(SidebarProvider, {
        children: /*#__PURE__*/jsxs(Flex, {
          direction: "column",
          height: "100vh",
          children: [/*#__PURE__*/jsx(TopBar, {}), /*#__PURE__*/jsx(MainPanelLayout, {
            basePath: props.basePath,
            config: props.config,
            children: content
          })]
        })
      })
    })
  });
  if (isGitHubConfig(props.config) || props.config.storage.kind === 'cloud') {
    return /*#__PURE__*/jsx(GitHubAppShellProvider, {
      currentBranch: props.currentBranch,
      config: props.config,
      children: inner
    });
  }
  if (isLocalConfig(props.config)) {
    return /*#__PURE__*/jsx(LocalAppShellProvider, {
      config: props.config,
      children: inner
    });
  }
  return null;
};

function SingletonPage({
  singleton,
  initialFiles,
  initialState,
  localTreeKey,
  config,
  currentTree
}) {
  const [forceValidation, setForceValidation] = useState(false);
  const singletonConfig = config.singletons[singleton];
  const schema = useMemo(() => object(singletonConfig.schema), [singletonConfig.schema]);
  const singletonPath = getSingletonPath(config, singleton);
  const router = useRouter();
  const [{
    state,
    localTreeKey: localTreeKeyInState
  }, setState] = useState(() => ({
    localTreeKey: localTreeKey,
    state: initialState === null ? getInitialPropsValue(schema) : initialState
  }));
  if (localTreeKeyInState !== localTreeKey) {
    setState({
      localTreeKey: localTreeKey,
      state: initialState === null ? getInitialPropsValue(schema) : initialState
    });
  }
  const isCreating = initialState === null;
  const hasChanged = useHasChanged({
    initialState,
    state,
    schema,
    slugField: undefined
  }) || isCreating;
  const previewProps = useMemo(() => createGetPreviewProps(schema, stateUpdater => {
    setState(state => ({
      localTreeKey: state.localTreeKey,
      state: stateUpdater(state.state)
    }));
  }, () => undefined), [schema])(state);
  const baseCommit = useBaseCommit();
  const formatInfo = getSingletonFormat(config, singleton);
  const [updateResult, _update, resetUpdateItem] = useUpsertItem({
    state,
    initialFiles,
    config,
    schema: singletonConfig.schema,
    basePath: singletonPath,
    format: formatInfo,
    currentLocalTreeKey: localTreeKey,
    currentTree,
    slug: undefined
  });
  const update = useEventCallback(_update);
  const onCreate = async () => {
    if (!clientSideValidateProp(schema, state, undefined)) {
      setForceValidation(true);
      return;
    }
    await update();
  };
  const formID = 'singleton-form';
  return /*#__PURE__*/jsxs(PageRoot, {
    containerWidth: containerWidthForEntryLayout(singletonConfig),
    children: [/*#__PURE__*/jsxs(PageHeader, {
      children: [/*#__PURE__*/jsxs(Flex, {
        alignItems: "center",
        gap: "regular",
        children: [/*#__PURE__*/jsx(Heading, {
          elementType: "h1",
          id: "page-title",
          size: "small",
          children: singletonConfig.label
        }), updateResult.kind === 'loading' ? /*#__PURE__*/jsx(ProgressCircle, {
          "aria-label": `Updating ${singletonConfig.label}`,
          isIndeterminate: true,
          size: "small",
          alignSelf: "center"
        }) : hasChanged && /*#__PURE__*/jsx(Badge, {
          tone: "pending",
          children: "Unsaved"
        })]
      }), /*#__PURE__*/jsxs(ButtonGroup, {
        marginStart: "auto",
        children: [/*#__PURE__*/jsxs(Button, {
          "aria-label": "Reset"
          // prominence="low"
          ,
          isDisabled: updateResult.kind === 'loading' || !hasChanged,
          onPress: () => {
            setState({
              localTreeKey: localTreeKey,
              state: initialState === null ? getInitialPropsValue(schema) : initialState
            });
          },
          children: [/*#__PURE__*/jsx(Icon, {
            isHidden: {
              above: 'mobile'
            },
            src: refreshCwIcon
          }), /*#__PURE__*/jsx(Text, {
            isHidden: {
              below: 'tablet'
            },
            children: "Reset"
          })]
        }), /*#__PURE__*/jsx(Button, {
          form: formID,
          isDisabled: updateResult.kind === 'loading',
          prominence: "high",
          type: "submit",
          children: isCreating ? 'Create' : 'Save'
        })]
      })]
    }), /*#__PURE__*/jsxs(Flex, {
      elementType: "form",
      id: formID,
      onSubmit: event => {
        if (event.target !== event.currentTarget) return;
        event.preventDefault();
        onCreate();
      },
      direction: "column",
      gap: "xxlarge",
      height: "100%",
      minHeight: 0,
      minWidth: 0,
      children: [updateResult.kind === 'error' && /*#__PURE__*/jsx(Notice, {
        tone: "critical",
        children: updateResult.error.message
      }), /*#__PURE__*/jsx(FormForEntry, {
        previewProps: previewProps,
        forceValidation: forceValidation,
        entryLayout: singletonConfig.entryLayout,
        formatInfo: formatInfo,
        slugField: undefined
      }), /*#__PURE__*/jsx(DialogContainer
      // ideally this would be a popover on desktop but using a DialogTrigger wouldn't work since
      // this doesn't open on click but after doing a network request and it failing and manually wiring about a popover and modal would be a pain
      , {
        onDismiss: resetUpdateItem,
        children: updateResult.kind === 'needs-new-branch' && /*#__PURE__*/jsx(CreateBranchDuringUpdateDialog, {
          branchOid: baseCommit,
          onCreate: async newBranch => {
            router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/singleton/${encodeURIComponent(singleton)}`);
            update({
              branch: newBranch,
              sha: baseCommit
            });
          },
          reason: updateResult.reason,
          onDismiss: resetUpdateItem
        })
      }), /*#__PURE__*/jsx(DialogContainer
      // ideally this would be a popover on desktop but using a DialogTrigger
      // wouldn't work since this doesn't open on click but after doing a
      // network request and it failing and manually wiring about a popover
      // and modal would be a pain
      , {
        onDismiss: resetUpdateItem,
        children: updateResult.kind === 'needs-fork' && isGitHubConfig(config) && /*#__PURE__*/jsx(ForkRepoDialog, {
          onCreate: async () => {
            update();
          },
          onDismiss: resetUpdateItem,
          config: config
        })
      })]
    })]
  });
}
function SingletonPageWrapper(props) {
  var _props$config$singlet;
  const singletonConfig = (_props$config$singlet = props.config.singletons) === null || _props$config$singlet === void 0 ? void 0 : _props$config$singlet[props.singleton];
  if (!singletonConfig) notFound();
  const header = /*#__PURE__*/jsx(PageHeader, {
    children: /*#__PURE__*/jsx(Heading, {
      elementType: "h1",
      id: "page-title",
      size: "small",
      children: singletonConfig.label
    })
  });
  const format = useMemo(() => getSingletonFormat(props.config, props.singleton), [props.config, props.singleton]);
  const itemData = useItemData({
    config: props.config,
    dirpath: getSingletonPath(props.config, props.singleton),
    schema: props.config.singletons[props.singleton].schema,
    format,
    slug: undefined
  });
  const {
    current: tree
  } = useTree();
  const combined = useMemo(() => mergeDataStates({
    tree,
    item: itemData
  }), [itemData, tree]);
  if (combined.kind === 'error') {
    return /*#__PURE__*/jsxs(PageRoot, {
      children: [header, /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Notice, {
          margin: "xxlarge",
          tone: "critical",
          children: combined.error.message
        })
      })]
    });
  }
  if (combined.kind === 'loading') {
    return /*#__PURE__*/jsxs(PageRoot, {
      children: [header, /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Flex, {
          alignItems: "center",
          justifyContent: "center",
          minHeight: "scale.3000",
          children: /*#__PURE__*/jsx(ProgressCircle, {
            "aria-label": `Loading ${singletonConfig.label}`,
            isIndeterminate: true,
            size: "large"
          })
        })
      })]
    });
  }
  return /*#__PURE__*/jsx(SingletonPage, {
    singleton: props.singleton,
    config: props.config,
    initialState: combined.data.item === 'not-found' ? null : combined.data.item.initialState,
    initialFiles: combined.data.item === 'not-found' ? [] : combined.data.item.initialFiles,
    localTreeKey: combined.data.item === 'not-found' ? undefined : combined.data.item.localTreeKey,
    currentTree: combined.data.tree.tree
  });
}

function FromTemplateDeploy(props) {
  useEffect(() => {
    const parsedCookies = cookie.parse(document.cookie);
    const repo = serializeRepoConfig(props.config.storage.repo);
    const cookieName = 'ks-template';
    if (parsedCookies[cookieName] !== repo) {
      document.cookie = cookie.serialize(cookieName, repo, {
        path: '/',
        maxAge: 60 * 60 * 24 * 30,
        expires: new Date(Date.now() + 60 * 60 * 24 * 30 * 1000),
        secure: true,
        sameSite: 'lax'
      });
    }
  }, [props.config.storage.repo]);
  return /*#__PURE__*/jsx(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: /*#__PURE__*/jsxs(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      children: [/*#__PURE__*/jsx(Heading, {
        children: "You've deployed Keystatic! \uD83C\uDF89"
      }), /*#__PURE__*/jsx(Text, {
        children: "To start using Keystatic, you need to install the GitHub app you've created."
      }), /*#__PURE__*/jsxs(Text, {
        children: ["Make sure to add the App to the", ' ', /*#__PURE__*/jsx("code", {
          children: serializeRepoConfig(props.config.storage.repo)
        }), ' ', "repository."]
      }), /*#__PURE__*/jsx(InstallGitHubApp, {
        config: props.config
      })]
    })
  });
}

function CreatedGitHubApp(props) {
  return /*#__PURE__*/jsx(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: /*#__PURE__*/jsxs(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      children: [/*#__PURE__*/jsx(Heading, {
        children: "You've installed Keystatic! \uD83C\uDF89"
      }), /*#__PURE__*/jsx(Text, {
        children: "To start using Keystatic, you need to install the GitHub app you've created."
      }), /*#__PURE__*/jsxs(Text, {
        children: ["Make sure to add the App to the", ' ', /*#__PURE__*/jsx("code", {
          children: serializeRepoConfig(props.config.storage.repo)
        }), ' ', "repository."]
      }), /*#__PURE__*/jsx(InstallGitHubApp, {
        config: props.config
      })]
    })
  });
}

function KeystaticSetup(props) {
  const [deployedURL, setDeployedURL] = useState('');
  const [organization, setOrganization] = useState('');
  return /*#__PURE__*/jsx(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: /*#__PURE__*/jsxs(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      elementType: "form",
      action: `https://github.com${organization ? `/organizations/${organization}` : ''}/settings/apps/new`,
      method: "post",
      children: [/*#__PURE__*/jsx(Flex, {
        justifyContent: "center",
        children: /*#__PURE__*/jsx(Heading, {
          children: "Keystatic Setup"
        })
      }), /*#__PURE__*/jsx(Text, {
        children: "Keystatic doesn't have the required config."
      }), /*#__PURE__*/jsx(Text, {
        children: "If you've already created your GitHub app, make sure to add the following environment variables:"
      }), /*#__PURE__*/jsxs(Box, {
        elementType: "ul",
        children: [/*#__PURE__*/jsx("li", {
          children: /*#__PURE__*/jsx("code", {
            children: "KEYSTATIC_GITHUB_CLIENT_ID"
          })
        }), /*#__PURE__*/jsx("li", {
          children: /*#__PURE__*/jsx("code", {
            children: "KEYSTATIC_GITHUB_CLIENT_SECRET"
          })
        }), /*#__PURE__*/jsx("li", {
          children: /*#__PURE__*/jsx("code", {
            children: "KEYSTATIC_SECRET"
          })
        })]
      }), /*#__PURE__*/jsx(Text, {
        children: "If you haven't created your GitHub app for Keystatic, you can create one below."
      }), /*#__PURE__*/jsx(TextField, {
        label: "Deployed App URL",
        description: "This should the root of your domain. If you're not sure where Keystatic will be deployed, leave this blank and you can update the GitHub app later.",
        value: deployedURL,
        onChange: setDeployedURL
      }), /*#__PURE__*/jsx(TextField, {
        label: "GitHub organization (if any)",
        description: "You must be an owner or GitHub App manager in the organization to create the GitHub App. Leave this blank to create the app in your personal account.",
        value: organization,
        onChange: setOrganization
      }), /*#__PURE__*/jsxs(Text, {
        children: ["After visiting GitHub to create the GitHub app, you'll be redirected back here and secrets generated from GitHub will be written to your", ' ', /*#__PURE__*/jsx("code", {
          children: ".env"
        }), " file."]
      }), /*#__PURE__*/jsx("input", {
        type: "text",
        name: "manifest",
        className: css({
          display: 'none'
        }),
        value: JSON.stringify({
          name: `${parseRepoConfig(props.config.storage.repo).owner} Keystatic`,
          url: deployedURL ? `${deployedURL}/keystatic` : `${window.location.origin}/keystatic`,
          public: true,
          redirect_url: `${window.location.origin}/api/keystatic/github/created-app`,
          callback_urls: [`${window.location.origin}/api/keystatic/github/oauth/callback`, `http://127.0.0.1/api/keystatic/github/oauth/callback`, ...(deployedURL ? [`${deployedURL}/api/keystatic/github/oauth/callback`] : [])],
          request_oauth_on_install: true,
          default_permissions: {
            contents: 'write',
            metadata: 'read',
            pull_requests: 'read'
          }
        })
      }), /*#__PURE__*/jsx(Button, {
        prominence: "high",
        type: "submit",
        children: "Create GitHub App"
      })]
    })
  });
}

function RepoNotFound(props) {
  const repo = serializeRepoConfig(props.config.storage.repo);
  return /*#__PURE__*/jsx(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: /*#__PURE__*/jsxs(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      children: [/*#__PURE__*/jsx(Flex, {
        justifyContent: "center",
        children: /*#__PURE__*/jsx(Heading, {
          children: "Repo not found"
        })
      }), /*#__PURE__*/jsxs(Text, {
        children: ["Keystatic is configured for the", ' ', /*#__PURE__*/jsx("a", {
          href: `https://github.com/${repo}`,
          children: repo
        }), " GitHub repo but Keystatic isn't able to access this repo. This is either because you don't have access to this repo or you haven't added the GitHub app to it."]
      }), /*#__PURE__*/jsx(InstallGitHubApp, {
        config: props.config
      })]
    })
  });
}

const storedStateSchema = z.object({
  state: z.string(),
  from: z.string(),
  code_verifier: z.string()
});
const tokenResponseSchema = z.object({
  access_token: z.string(),
  token_type: z.string(),
  expires_in: z.number()
});
function KeystaticCloudAuthCallback({
  config
}) {
  const router = useRouter();
  const url = new URL(window.location.href);
  const code = url.searchParams.get('code');
  const state = url.searchParams.get('state');
  const storedState = useMemo(() => {
    const _storedState = localStorage.getItem('keystatic-cloud-state');
    const storedState = storedStateSchema.safeParse((() => {
      try {
        return JSON.parse(_storedState || '');
      } catch {
        return null;
      }
    })());
    return storedState;
  }, []);
  const [error, setError] = useState(null);
  useEffect(() => {
    if (code && state && storedState.success && isCloudConfig(config)) {
      (async () => {
        const res = await fetch(`${KEYSTATIC_CLOUD_API_URL}/oauth/token`, {
          method: 'POST',
          body: new URLSearchParams({
            code,
            client_id: config.cloud.project,
            redirect_uri: `${window.location.origin}/keystatic/cloud/oauth/callback`,
            code_verifier: storedState.data.code_verifier,
            grant_type: 'authorization_code'
          }).toString(),
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...KEYSTATIC_CLOUD_HEADERS
          }
        });
        if (!res.ok) {
          throw new Error(`Bad response: ${res.status} ${res.statusText}\n\n${await res.text()}`);
        }
        const data = await res.json();
        const parsed = tokenResponseSchema.parse(data);
        localStorage.setItem('keystatic-cloud-access-token', JSON.stringify({
          token: parsed.access_token,
          validUntil: Date.now() + parsed.expires_in * 1000
        }));
        router.push(`/keystatic/${storedState.data.from}`);
      })().catch(error => {
        setError(error);
      });
    }
  }, [code, state, router, storedState, config]);
  if (config.storage.kind !== 'cloud') {
    return /*#__PURE__*/jsx(Text, {
      children: "Missing Keystatic Cloud config"
    });
  }
  if (!code || !state) {
    return /*#__PURE__*/jsx(Text, {
      children: "Missing code or state"
    });
  }
  if (storedState.success === false || state !== storedState.data.state) {
    return /*#__PURE__*/jsx(Text, {
      children: "Invalid state"
    });
  }
  if (error) {
    return /*#__PURE__*/jsx(Text, {
      children: error.message
    });
  }
  return /*#__PURE__*/jsx("div", {
    children: /*#__PURE__*/jsx(ProgressCircle, {
      isIndeterminate: true,
      "aria-label": "Authenticating"
    })
  });
}

function parseParamsWithoutBranch(params) {
  if (params.length === 0) {
    return {};
  }
  if (params.length === 2 && params[0] === 'singleton') {
    return {
      singleton: params[1]
    };
  }
  if (params.length < 2 || params[0] !== 'collection') return null;
  const collection = params[1];
  if (params.length === 2) {
    return {
      collection
    };
  }
  if (params.length === 3 && params[2] === 'create') {
    return {
      collection,
      kind: 'create'
    };
  }
  if (params.length === 4 && params[2] === 'item') {
    const slug = params[3];
    return {
      collection,
      kind: 'edit',
      slug
    };
  }
  return null;
}
function RedirectToBranch(props) {
  const {
    push
  } = useRouter();
  const {
    data,
    error
  } = useContext(GitHubAppShellDataContext);
  useEffect(() => {
    var _error$response, _data$repository, _data$repository2, _error$graphQLErrors, _error$graphQLErrors2;
    if ((error === null || error === void 0 || (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {
      if (props.config.storage.kind === 'github') {
        window.location.href = '/api/keystatic/github/login';
      } else {
        redirectToCloudAuth('', props.config);
      }
    }
    if (data !== null && data !== void 0 && (_data$repository = data.repository) !== null && _data$repository !== void 0 && _data$repository.defaultBranchRef) {
      push(`/keystatic/branch/${encodeURIComponent(data.repository.defaultBranchRef.name)}`);
    }
    if (props.config.storage.kind === 'github' && !(data !== null && data !== void 0 && (_data$repository2 = data.repository) !== null && _data$repository2 !== void 0 && _data$repository2.id) && (error === null || error === void 0 || (_error$graphQLErrors = error.graphQLErrors) === null || _error$graphQLErrors === void 0 || (_error$graphQLErrors = _error$graphQLErrors[0]) === null || _error$graphQLErrors === void 0 || (_error$graphQLErrors = _error$graphQLErrors.originalError) === null || _error$graphQLErrors === void 0 ? void 0 : _error$graphQLErrors.type) === 'NOT_FOUND' || (error === null || error === void 0 || (_error$graphQLErrors2 = error.graphQLErrors) === null || _error$graphQLErrors2 === void 0 || (_error$graphQLErrors2 = _error$graphQLErrors2[0]) === null || _error$graphQLErrors2 === void 0 || (_error$graphQLErrors2 = _error$graphQLErrors2.originalError) === null || _error$graphQLErrors2 === void 0 ? void 0 : _error$graphQLErrors2.type) === 'FORBIDDEN') {
      window.location.href = '/api/keystatic/github/repo-not-found';
    }
  }, [data, error, push, props.config]);
  return null;
}
function PageInner({
  config
}) {
  const {
    params
  } = useRouter();
  let branch = null,
    parsedParams,
    basePath;
  if (config.storage.kind === 'cloud' && params.join('/') === 'cloud/oauth/callback') {
    return /*#__PURE__*/jsx(KeystaticCloudAuthCallback, {
      config: config
    });
  }
  let wrapper = x => x;
  if (isGitHubConfig(config) || isCloudConfig(config)) {
    wrapper = element => /*#__PURE__*/jsx(AuthWrapper, {
      config: config,
      children: /*#__PURE__*/jsx(GitHubAppShellDataProvider, {
        config: config,
        children: element
      })
    });
    if (params.length === 0) {
      return wrapper( /*#__PURE__*/jsx(RedirectToBranch, {
        config: config
      }));
    }
    if (params.length === 1 && isGitHubConfig(config)) {
      if (params[0] === 'setup') return /*#__PURE__*/jsx(KeystaticSetup, {
        config: config
      });
      if (params[0] === 'repo-not-found') {
        return /*#__PURE__*/jsx(RepoNotFound, {
          config: config
        });
      }
      if (params[0] === 'from-template-deploy') {
        return /*#__PURE__*/jsx(FromTemplateDeploy, {
          config: config
        });
      }
      if (params[0] === 'created-github-app') {
        return /*#__PURE__*/jsx(CreatedGitHubApp, {
          config: config
        });
      }
    }
    if (params[0] !== 'branch' || params.length < 2) {
      return /*#__PURE__*/jsx(Text, {
        children: "Not found"
      });
    }
    branch = params[1];
    basePath = `/keystatic/branch/${encodeURIComponent(branch)}`;
    parsedParams = parseParamsWithoutBranch(params.slice(2));
  } else {
    parsedParams = parseParamsWithoutBranch(params);
    basePath = '/keystatic';
  }
  return wrapper( /*#__PURE__*/jsx(AppShell, {
    config: config,
    currentBranch: branch || '',
    basePath: basePath,
    children: /*#__PURE__*/jsx(NotFoundBoundary, {
      fallback: /*#__PURE__*/jsx(PageRoot, {
        children: /*#__PURE__*/jsx(PageBody, {
          children: /*#__PURE__*/jsx(EmptyState, {
            icon: fileX2Icon,
            title: "Not found",
            message: "This page could not be found."
          })
        })
      }),
      children: parsedParams === null ? /*#__PURE__*/jsx(AlwaysNotFound, {}) : parsedParams.collection ? parsedParams.kind === 'create' ? /*#__PURE__*/jsx(CreateItem, {
        collection: parsedParams.collection,
        config: config,
        basePath: basePath
      }, parsedParams.collection) : parsedParams.kind === 'edit' ? /*#__PURE__*/jsx(ItemPageWrapper, {
        collection: parsedParams.collection,
        basePath: basePath,
        config: config,
        itemSlug: parsedParams.slug
      }, parsedParams.collection) : /*#__PURE__*/jsx(CollectionPage, {
        basePath: basePath,
        collection: parsedParams.collection,
        config: config
      }, parsedParams.collection) : parsedParams.singleton ? /*#__PURE__*/jsx(SingletonPageWrapper, {
        config: config,
        singleton: parsedParams.singleton
      }, parsedParams.singleton) : /*#__PURE__*/jsx(DashboardPage, {
        config: config,
        basePath: basePath
      })
    })
  }));
}
function AlwaysNotFound() {
  notFound();
}
function AuthWrapper(props) {
  const [state, setState] = useState('unknown');
  const router = useRouter();
  useEffect(() => {
    getAuth(props.config).then(auth => {
      if (auth) {
        setState('valid');
        return;
      }
      setState('explicit-auth');
    });
  }, [props.config]);
  if (state === 'valid') {
    return props.children;
  }
  if (state === 'explicit-auth') {
    if (props.config.storage.kind === 'github') {
      return /*#__PURE__*/jsx(Flex, {
        justifyContent: "center",
        alignItems: "center",
        height: "100vh",
        children: /*#__PURE__*/jsx(LinkComponentContext.Provider, {
          value: DefaultLinkComponent,
          children: /*#__PURE__*/jsxs(Button, {
            href: `/api/keystatic/github/login${router.params.length ? `?${new URLSearchParams({
              from: router.params.join('/')
            })}` : ''}`,
            children: [/*#__PURE__*/jsx(Icon, {
              src: githubIcon
            }), /*#__PURE__*/jsx(Text, {
              children: "Log in with GitHub"
            })]
          })
        })
      });
    }
    if (props.config.storage.kind === 'cloud') {
      return /*#__PURE__*/jsx(Flex, {
        justifyContent: "center",
        alignItems: "center",
        height: "100vh",
        children: /*#__PURE__*/jsx(Button, {
          onPress: () => {
            redirectToCloudAuth(router.params.join('/'), props.config);
          },
          children: /*#__PURE__*/jsx(Text, {
            children: "Log in with Keystatic Cloud"
          })
        })
      });
    }
  }
  return null;
}
function Keystatic(props) {
  if (props.config.storage.kind === 'github') {
    assertValidRepoConfig(props.config.storage.repo);
  }
  useEffect(() => {
    if (window.location.hostname === 'localhost') {
      window.location.href = window.location.href.replace('localhost', '127.0.0.1');
    }
  }, []);
  if (window.location.hostname === 'localhost') {
    return null;
  }
  return /*#__PURE__*/jsx(AppSlugProvider, {
    value: props.appSlug,
    children: /*#__PURE__*/jsx(RouterProvider, {
      router: props.router,
      children: /*#__PURE__*/jsx(Provider, {
        config: props.config,
        Link: props.link,
        children: /*#__PURE__*/jsx(PageInner, {
          config: props.config
        })
      })
    })
  });
}

export { Keystatic };
