import React__default, { createContext, useContext, useState, useMemo, useEffect, useCallback, useRef, useId, memo, useReducer } from 'react';
import { ActionButton, Button, ButtonGroup } from '@keystar/ui/button';
import { Icon } from '@keystar/ui/icon';
import { fileX2Icon } from '@keystar/ui/icon/icons/fileX2Icon';
import { githubIcon } from '@keystar/ui/icon/icons/githubIcon';
import { Flex, Box, Grid } from '@keystar/ui/layout';
import { Heading, Text } from '@keystar/ui/typography';
import { useLocalizedStringFormatter, useLocale } from '@react-aria/i18n';
import { alertCircleIcon } from '@keystar/ui/icon/icons/alertCircleIcon';
import { listXIcon } from '@keystar/ui/icon/icons/listXIcon';
import { searchIcon } from '@keystar/ui/icon/icons/searchIcon';
import { searchXIcon } from '@keystar/ui/icon/icons/searchXIcon';
import { TextLink, makeLinkComponent, useLinkComponent, LinkComponentContext, DefaultLinkComponent } from '@keystar/ui/link';
import { ProgressCircle } from '@keystar/ui/progress';
import { SearchField } from '@keystar/ui/search-field';
import { StatusLight } from '@keystar/ui/status-light';
import { css, tokenSchema, breakpointQueries, breakpoints, useBreakpoint, transition, useMediaQuery, injectGlobal, containerQueries, classNames } from '@keystar/ui/style';
import { TableView, TableHeader, Column, TableBody, Row, Cell } from '@keystar/ui/table';
import { assert, isDefined, typedKeys, assertNever } from 'emery';
import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { gql } from '@ts-gql/tag/no-transform';
import { useQuery, useMutation, useClient, Provider as Provider$1, createClient, dedupExchange, fetchExchange } from 'urql';
import { i as isGitHubConfig, r as redirectToCloudAuth, g as getEntriesInCollectionWithTreeKey, a as getSingletonPath, b as getTreeNodeAtPath, t as treeEntriesToTreeNodes, c as treeSha, K as KEYSTATIC_CLOUD_API_URL, d as KEYSTATIC_CLOUD_HEADERS, p as pluralize, e as isCloudConfig, f as getCollectionPath, h as isLocalConfig, u as updateValue, j as getKeysForArrayValue, s as setKeysForArrayValue, k as getSlugFromState, l as getInitialPropsValue, m as getDirectoriesForTreeKey, o as object, n as getTreeKey, q as getEntryDataFilepath, v as blobSha, w as updateTreeWithChanges, x as serializeProps, y as getCollectionFormat, z as getSlugGlobForCollection, A as getCollectionItemPath, B as getDataFileExtension, C as getRepoUrl, D as keyedEntries, E as getSingletonFormat } from '../../dist/index-cd5679e3.node.react-server.esm.js';
import LRU from 'lru-cache';
import cookie, { parse } from 'cookie';
import { z } from 'zod';
import { panelLeftOpenIcon } from '@keystar/ui/icon/icons/panelLeftOpenIcon';
import { panelLeftCloseIcon } from '@keystar/ui/icon/icons/panelLeftCloseIcon';
import { panelRightOpenIcon } from '@keystar/ui/icon/icons/panelRightOpenIcon';
import { panelRightCloseIcon } from '@keystar/ui/icon/icons/panelRightCloseIcon';
import { useModalOverlay, DismissButton } from '@react-aria/overlays';
import { useResizeObserver, useUpdateEffect } from '@react-aria/utils';
import { useOverlayTriggerState } from '@react-stately/overlays';
import { Badge } from '@keystar/ui/badge';
import { Blanket } from '@keystar/ui/overlays';
import { NavList, NavItem, NavGroup } from '@keystar/ui/nav-list';
import { usePrevious } from '@keystar/ui/utils';
import { Breadcrumbs, Item as Item$2 } from '@keystar/ui/breadcrumbs';
import { Dialog, DialogContainer, AlertDialog, DialogTrigger } from '@keystar/ui/dialog';
import { Notice } from '@keystar/ui/notice';
import { Toaster, toastQueue } from '@keystar/ui/toast';
import '@sindresorhus/slugify';
import '@braintree/sanitize-url';
import { t as toFormattedFormDataError, v as validateArrayLength, P as PropValidationError, l as loadDataFile, p as parseProps } from '../../dist/required-files-4d510aad.node.react-server.esm.js';
import 'slate';
import 'slate-react';
import isHotkey from 'is-hotkey';
import { ActionGroup } from '@keystar/ui/action-group';
import { externalLinkIcon } from '@keystar/ui/icon/icons/externalLinkIcon';
import { historyIcon } from '@keystar/ui/icon/icons/historyIcon';
import { trash2Icon } from '@keystar/ui/icon/icons/trash2Icon';
import { Content, Footer } from '@keystar/ui/slots';
import { TextField } from '@keystar/ui/text-field';
import { gitBranchIcon } from '@keystar/ui/icon/icons/gitBranchIcon';
import { Picker, Item } from '@keystar/ui/picker';
import { RadioGroup, Radio } from '@keystar/ui/radio';
import { SplitView, SplitPaneSecondary, SplitPanePrimary } from '@keystar/ui/split-view';
import { useDragAndDrop } from '@keystar/ui/drag-and-drop';
import { FieldLabel, FieldMessage } from '@keystar/ui/field';
import { ListView, Item as Item$1 } from '@keystar/ui/list-view';
import { TooltipTrigger, Tooltip } from '@keystar/ui/tooltip';
import { dump } from 'js-yaml';
import { fromUint8Array } from 'js-base64';
import { VoussoirProvider, ClientSideOnlyDocumentElement } from '@keystar/ui/core';
import { cacheExchange } from '@urql/exchange-graphcache';
import { authExchange } from '@urql/exchange-auth';
import { persistedExchange } from '@urql/exchange-persisted';
import isEqual from 'fast-deep-equal';
import { Avatar } from '@keystar/ui/avatar';
import { gitBranchPlusIcon } from '@keystar/ui/icon/icons/gitBranchPlusIcon';
import { gitPullRequestIcon } from '@keystar/ui/icon/icons/gitPullRequestIcon';
import { plusIcon } from '@keystar/ui/icon/icons/plusIcon';
import { Item as Item$3, Section } from '@react-stately/collections';
import { listTodoIcon } from '@keystar/ui/icon/icons/listTodoIcon';
import { logOutIcon } from '@keystar/ui/icon/icons/logOutIcon';
import { gitForkIcon } from '@keystar/ui/icon/icons/gitForkIcon';
import { monitorIcon } from '@keystar/ui/icon/icons/monitorIcon';
import { moonIcon } from '@keystar/ui/icon/icons/moonIcon';
import { sunIcon } from '@keystar/ui/icon/icons/sunIcon';
import { userIcon } from '@keystar/ui/icon/icons/userIcon';
import { MenuTrigger, Menu, ActionMenu } from '@keystar/ui/menu';
import { refreshCwIcon } from '@keystar/ui/icon/icons/refreshCwIcon';
import '@markdoc/markdoc';
import 'emery/assertions';
import 'crypto';
import '../../dist/empty-field-ui-5b08ee07.node.react-server.esm.js';
import '@emotion/weak-memoize';

// the collator enables language-sensitive string comparison
const collator = new Intl.Collator(undefined, {
  sensitivity: 'base'
});

/**
 * Creates a comparison function that should be provided to the `sort()` method
 * of your data array.
 */
function sortByDescriptor(sortDescriptor) {
  const key = sortDescriptor.column;
  assert(key != null, '`sortDescriptor.column` is required');
  return (a, b) => {
    const valueA = a[key];
    const valueB = b[key];
    const modifier = sortDescriptor.direction === 'ascending' ? 1 : -1;

    // always push `null` and `undefined` to the bottom
    if (valueA == null) return 1;
    if (valueB == null) return -1;

    // the collator is only appropriate for strings, it fails in subtle
    // ways for floats, dates, etc.
    if (typeof valueA === 'string' && typeof valueB === 'string') {
      return collator.compare(valueA, valueB) * modifier;
    }
    return compare(valueA, valueB) * modifier;
  };
}

/** Default comparison for non-string values */
function compare(a, b) {
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
}

var l10nMessages = {
	"bg-BG": {
		add: "Добавете",
		basedOn: "Базиран на",
		branchName: "Име на клон",
		branches: "Клонове",
		cancel: "Отказ",
		clear: "Изчисти",
		collection: "колекция",
		collections: "Колекции",
		create: "Създавайте",
		createPullRequest: "Създайте заявка за изтегляне",
		currentBranch: "Текущ клон",
		dashboard: "Табло",
		defaultBranch: "Клон по подразбиране",
		"delete": "Изтрий",
		deleteBranch: "Изтриване на клон",
		edit: "редактиране",
		loading: "Зареждане",
		newBranch: "Нов клон",
		otherBranches: "Други клонове",
		pullRequests: "Заявки за изтегляне",
		save: "Запазване",
		search: "Търсене",
		singleton: "Сингълтън",
		singletons: "Единични",
		theCurrentlyCheckedOutBranch: "Текущо провереният клон. Изберете това, ако трябва да надграждате върху съществуваща работа от текущия клон.",
		theDefaultBranchInYourRepository: "Клонът по подразбиране във вашето хранилище. Изберете това, за да започнете с нещо ново, което не зависи от текущия ви клон.",
		viewPullRequests: "Преглед на заявките за изтегляне"
	},
	"cs-CZ": {
		add: "Přidat",
		basedOn: "Na základě",
		branchName: "Jméno pobočky",
		branches: "Větve",
		cancel: "zrušení",
		clear: "Vymazat",
		collection: "Sbírka",
		collections: "Sbírky",
		create: "Vytvořit",
		createPullRequest: "Vytvořit požadavek na stažení",
		currentBranch: "Současná pobočka",
		dashboard: "Přístrojová deska",
		defaultBranch: "Výchozí větev",
		"delete": "Vymazat",
		deleteBranch: "Smazat větev",
		edit: "Upravit",
		newBranch: "Nová pobočka",
		loading: "Načítání",
		otherBranches: "Ostatní pobočky",
		pullRequests: "Vytáhněte požadavky",
		save: "Uložit",
		search: "Hledat",
		singleton: "Jedináček",
		singletons: "Singletons",
		theCurrentlyCheckedOutBranch: "Aktuálně odhlášená pobočka. Tuto možnost vyberte, pokud potřebujete navázat na stávající práci z aktuální pobočky.",
		viewPullRequests: "Zobrazit žádosti o stažení",
		theDefaultBranchInYourRepository: "Výchozí větev ve vašem úložišti. Zvolte tuto možnost, chcete-li začít s něčím novým, co není závislé na vaší aktuální větvi."
	},
	"da-DK": {
		add: "Tilføje",
		basedOn: "Baseret på",
		branchName: "Afdelingsnavn",
		branches: "Grene",
		cancel: "Afbestille",
		clear: "Ryd",
		collection: "Kollektion",
		collections: "Samlinger",
		create: "skab",
		createPullRequest: "Opret pull-anmodning",
		currentBranch: "Nuværende filial",
		dashboard: "Dashboard",
		defaultBranch: "Standard gren",
		"delete": "Slet",
		deleteBranch: "Slet filial",
		edit: "Redigere",
		loading: "Indlæser",
		newBranch: "Ny filial",
		otherBranches: "Andre grene",
		pullRequests: "Træk anmodninger",
		save: "Gemme",
		search: "Søg",
		singleton: "Singleton",
		singletons: "Singletoner",
		theCurrentlyCheckedOutBranch: "Den aktuelt tjekkede filial. Vælg dette, hvis du skal bygge videre på eksisterende arbejde fra den nuværende filial.",
		viewPullRequests: "Se pull-anmodninger",
		theDefaultBranchInYourRepository: "Standardgrenen i dit lager. Vælg dette for at starte på noget nyt, der ikke er afhængigt af din nuværende filial."
	},
	"en-US": {
		add: "Add",
		basedOn: "Based on",
		branchName: "Branch name",
		branches: "Branches",
		cancel: "Cancel",
		clear: "Clear",
		collection: "Collection",
		collections: "Collections",
		create: "Create",
		createPullRequest: "Create pull request",
		currentBranch: "Current branch",
		dashboard: "Dashboard",
		defaultBranch: "Default branch",
		"delete": "Delete",
		deleteBranch: "Delete branch",
		edit: "Edit",
		loading: "Loading",
		newBranch: "New branch…",
		otherBranches: "Other branches",
		pullRequests: "Pull requests",
		save: "Save",
		search: "Search",
		singleton: "Singleton",
		singletons: "Singletons",
		theCurrentlyCheckedOutBranch: "The currently checked out branch. Choose this if you need to build on existing work from the current branch.",
		theDefaultBranchInYourRepository: "The default branch in your repository. Choose this to start something new that's not dependent on your current branch.",
		viewPullRequests: "View pull requests"
	},
	"es-ES": {
		add: "Agregar",
		basedOn: "Residencia en",
		branchName: "Nombre de la sucursal",
		branches: "Sucursales",
		cancel: "Cancelar",
		clear: "Borrar",
		collection: "Colección",
		collections: "Colecciones",
		create: "Crear",
		createPullRequest: "Crear solicitud de extracción",
		currentBranch: "Rama actual",
		dashboard: "Panel",
		defaultBranch: "Rama predeterminada",
		"delete": "Borrar",
		deleteBranch: "Eliminar rama",
		edit: "Editar",
		loading: "Cargando",
		newBranch: "Nueva sucursal",
		otherBranches: "Otras sucursales",
		pullRequests: "Solicitudes de extracción",
		save: "Ahorrar",
		search: "Buscar",
		singleton: "Semifallo",
		singletons: "Solteros",
		theCurrentlyCheckedOutBranch: "La sucursal actualmente desprotegida. Elija esto si necesita desarrollar el trabajo existente de la rama actual.",
		theDefaultBranchInYourRepository: "La rama predeterminada en su repositorio. Elija esto para comenzar algo nuevo que no dependa de su sucursal actual.",
		viewPullRequests: "Ver solicitudes de extracción"
	},
	"et-EE": {
		add: "Lisama",
		basedOn: "Põhineb",
		branchName: "Filiaali nimi",
		branches: "Filiaalid",
		cancel: "Tühista",
		clear: "Puhasta",
		collection: "Kollektsioon",
		collections: "Kollektsioonid",
		create: "Loo",
		createPullRequest: "Loo tõmbamistaotlus",
		currentBranch: "Praegune filiaal",
		dashboard: "Armatuurlaud",
		"delete": "Kustuta",
		defaultBranch: "Vaikeharu",
		deleteBranch: "Kustuta haru",
		edit: "Muuda",
		loading: "Laadimine",
		newBranch: "Uus filiaal",
		otherBranches: "Muud oksad",
		pullRequests: "Tõmbetaotlused",
		search: "Otsi",
		save: "Salvesta",
		singleton: "üksikud",
		singletons: "Üksikud",
		theCurrentlyCheckedOutBranch: "Praegu välja registreeritud filiaal. Valige see, kui peate kasutama praeguse haru olemasolevaid töid.",
		theDefaultBranchInYourRepository: "Vaikeharu teie hoidlas. Valige see, et alustada midagi uut, mis ei sõltu teie praegusest harust.",
		viewPullRequests: "Vaadake tõmbamistaotlusi"
	},
	"fi-FI": {
		add: "Lisätä",
		basedOn: "Perustuen",
		branchName: "Sivukonttorin nimi",
		branches: "Oksat",
		cancel: "Tühista",
		clear: "Kirkas",
		collection: "Kokoelma",
		collections: "Kokoelmat",
		create: "Luoda",
		createPullRequest: "Luo vetopyyntö",
		currentBranch: "Nykyinen haara",
		dashboard: "Kojelauta",
		defaultBranch: "Oletushaara",
		"delete": "Poistaa",
		deleteBranch: "Poista haara",
		edit: "Muokata",
		loading: "Ladataan",
		newBranch: "Uusi haara",
		otherBranches: "Muut haarat",
		pullRequests: "Vedä pyyntöjä",
		save: "Tallentaa",
		search: "Hae",
		singleton: "Singleton",
		singletons: "Singletons",
		theCurrentlyCheckedOutBranch: "Tällä hetkellä uloskirjautunut sivuliike. Valitse tämä, jos haluat rakentaa nykyisen haaran olemassa olevaan työhön.",
		theDefaultBranchInYourRepository: "Oletushaara arkistossasi. Valitse tämä aloittaaksesi jotain uutta, joka ei ole riippuvainen nykyisestä haarastasi.",
		viewPullRequests: "Näytä vetopyynnöt"
	},
	"fr-FR": {
		add: "Ajouter",
		branchName: "Nom de la filiale",
		basedOn: "Basé sur",
		branches: "Branches",
		cancel: "Annuler",
		collection: "Collection",
		clear: "Effacer",
		collections: "Collections",
		create: "Créer",
		createPullRequest: "Créer une demande d'extraction",
		currentBranch: "Succursale actuelle",
		dashboard: "Tableau de bord",
		defaultBranch: "Branche par défaut",
		"delete": "Supprimer",
		deleteBranch: "Supprimer la branche",
		edit: "Modifier",
		loading: "Chargement en cours",
		newBranch: "Nouvelle branche",
		otherBranches: "Autres succursales",
		pullRequests: "Demandes d'extraction",
		save: "Sauvegarder",
		search: "Rechercher",
		singleton: "Singleton",
		singletons: "Célibataires",
		theCurrentlyCheckedOutBranch: "La branche actuellement extraite. Choisissez cette option si vous devez vous appuyer sur le travail existant de la branche actuelle.",
		theDefaultBranchInYourRepository: "La branche par défaut de votre référentiel. Choisissez ceci pour commencer quelque chose de nouveau qui ne dépend pas de votre branche actuelle.",
		viewPullRequests: "Afficher les demandes d'extraction"
	},
	"hr-HR": {
		add: "Dodati",
		basedOn: "Na temelju",
		branchName: "Naziv podružnice",
		branches: "Podružnice",
		cancel: "Otkazati",
		clear: "Izbriši",
		collection: "Kolekcija",
		collections: "Zbirke",
		create: "Stvoriti",
		createPullRequest: "Kreirajte zahtjev za povlačenjem",
		currentBranch: "Trenutna grana",
		dashboard: "Nadzorna ploča",
		defaultBranch: "Zadana grana",
		"delete": "Izbrisati",
		deleteBranch: "Izbriši granu",
		edit: "Uredi",
		loading: "Učitavam",
		newBranch: "Nova grana",
		otherBranches: "Ostale grane",
		pullRequests: "Zahtjevi za povlačenjem",
		save: "Uštedjeti",
		search: "Traži",
		singleton: "samac",
		singletons: "Samci",
		theDefaultBranchInYourRepository: "Zadana grana u vašem spremištu. Odaberite ovo da započnete nešto novo što ne ovisi o vašoj trenutnoj grani.",
		theCurrentlyCheckedOutBranch: "Trenutno odjavljena poslovnica. Odaberite ovo ako trebate graditi na postojećem radu iz trenutne grane.",
		viewPullRequests: "Pregledajte zahtjeve za povlačenjem"
	},
	"hu-HU": {
		add: "Hozzáadás",
		basedOn: "Alapján",
		branchName: "Fiók neve",
		branches: "Ágak",
		cancel: "Megszünteti",
		clear: "Törlés",
		collection: "Gyűjtemény",
		collections: "Gyűjtemények",
		create: "Teremt",
		createPullRequest: "Lehívási kérelem létrehozása",
		currentBranch: "Jelenlegi ág",
		dashboard: "Irányítópult",
		"delete": "Töröl",
		defaultBranch: "Alapértelmezett ág",
		deleteBranch: "Elágazás törlése",
		edit: "Szerkesztés",
		loading: "Betöltés folyamatban",
		newBranch: "Új ág",
		otherBranches: "Egyéb ágak",
		pullRequests: "Lehívási kérések",
		save: "Megment",
		search: "Keresés",
		singleton: "szingli",
		singletons: "Singletons",
		theCurrentlyCheckedOutBranch: "A jelenleg kivett fiók. Válassza ezt, ha az aktuális ág meglévő munkájára kell építenie.",
		theDefaultBranchInYourRepository: "Az alapértelmezett ág az adattárban. Válassza ezt, ha valami újat szeretne indítani, amely nem függ az aktuális ágtól.",
		viewPullRequests: "Lehívási kérelmek megtekintése"
	},
	"it-IT": {
		add: "Aggiungere",
		basedOn: "Basato su",
		branchName: "Nome ramo",
		branches: "Rami",
		cancel: "Annulla",
		clear: "Cancella",
		collection: "Collezione",
		collections: "Collezioni",
		create: "Creare",
		createPullRequest: "Crea richiesta pull",
		currentBranch: "Ramo attuale",
		dashboard: "Pannello di controllo",
		defaultBranch: "Ramo predefinito",
		"delete": "Eliminare",
		deleteBranch: "Elimina ramo",
		edit: "Modificare",
		newBranch: "Nuova filiale",
		loading: "Caricamento in corso",
		otherBranches: "Altri rami",
		pullRequests: "Richieste pull",
		save: "Salva",
		search: "Cerca",
		singleton: "Singleton",
		singletons: "Singletons",
		theCurrentlyCheckedOutBranch: "La filiale attualmente verificata. Scegli questa opzione se devi basarti su un lavoro esistente dal ramo corrente.",
		theDefaultBranchInYourRepository: "Il ramo predefinito nel tuo repository. Scegli questa opzione per iniziare qualcosa di nuovo che non dipenda dal tuo ramo attuale.",
		viewPullRequests: "Visualizza le richieste pull"
	},
	"ja-JP": {
		add: "追加",
		branchName: "支店名",
		basedOn: "に基づく",
		cancel: "キャンセル",
		branches: "支店",
		clear: "クリア",
		collection: "コレクション",
		collections: "コレクション",
		create: "作成",
		createPullRequest: "プルリクエストを作成",
		currentBranch: "現在のブランチ",
		dashboard: "ダッシュボード",
		"delete": "消去",
		defaultBranch: "デフォルトのブランチ",
		deleteBranch: "ブランチを削除",
		edit: "編集",
		loading: "読み込み中",
		newBranch: "新しい支店",
		otherBranches: "その他の支店",
		pullRequests: "プルリクエスト",
		save: "保存",
		search: "検索",
		singleton: "シングルトン",
		singletons: "シングルトン",
		theCurrentlyCheckedOutBranch: "現在チェックアウトされているブランチ。 現在のブランチの既存の作業に基づいて構築する必要がある場合は、これを選択してください。",
		theDefaultBranchInYourRepository: "リポジトリのデフォルト ブランチ。 これを選択して、現在のブランチに依存しない新しい何かを開始します。",
		viewPullRequests: "プル リクエストを表示"
	},
	"he-IL": {
		add: "לְהוֹסִיף",
		basedOn: "מבוסס על",
		branchName: "שם הסניף",
		branches: "ענפים",
		cancel: "לְבַטֵל",
		clear: "נקי",
		collection: "אוסף",
		create: "לִיצוֹר",
		collections: "אוספים",
		createPullRequest: "צור בקשת משיכה",
		currentBranch: "סניף נוכחי",
		dashboard: "לוּחַ מַחווָנִים",
		defaultBranch: "סניף ברירת מחדל",
		"delete": "לִמְחוֹק",
		deleteBranch: "מחק סניף",
		edit: "לַעֲרוֹך",
		loading: "טוען",
		newBranch: "סניף חדש",
		otherBranches: "סניפים אחרים",
		pullRequests: "משוך בקשות",
		save: "להציל",
		search: "חפש",
		singleton: "קְלָף בּוֹדֵד",
		singletons: "רווקים",
		theCurrentlyCheckedOutBranch: "הסניף שנקבע כעת. בחר באפשרות זו אם אתה צריך לבנות על עבודה קיימת מהסניף הנוכחי.",
		theDefaultBranchInYourRepository: "סניף ברירת המחדל במאגר שלך. בחר באפשרות זו כדי להתחיל משהו חדש שאינו תלוי בסניף הנוכחי שלך.",
		viewPullRequests: "הצג בקשות משיכה"
	},
	"ko-KR": {
		add: "추가하다",
		basedOn: "기반으로",
		branchName: "지점명",
		branches: "가지",
		clear: "지우기",
		cancel: "취소",
		collection: "수집",
		collections: "컬렉션",
		create: "만들다",
		createPullRequest: "풀 요청 생성",
		currentBranch: "현재 지점",
		dashboard: "계기반",
		defaultBranch: "기본 분기",
		"delete": "삭제",
		deleteBranch: "분기 삭제",
		edit: "편집하다",
		loading: "로드 중",
		newBranch: "새 지점",
		otherBranches: "기타 지점",
		pullRequests: "풀 리퀘스트",
		save: "구하다",
		search: "검색",
		singleton: "하나씩 일어나는 것",
		singletons: "싱글톤",
		theCurrentlyCheckedOutBranch: "현재 체크아웃된 브랜치. 현재 브랜치의 기존 작업을 기반으로 빌드해야 하는 경우 이 옵션을 선택하세요.",
		theDefaultBranchInYourRepository: "리포지토리의 기본 브랜치입니다. 현재 분기에 의존하지 않는 새로운 것을 시작하려면 이것을 선택하십시오.",
		viewPullRequests: "풀 요청 보기"
	},
	"ar-AE": {
		add: "يضيف",
		basedOn: "مرتكز على",
		branchName: "اسم الفرع",
		branches: "الفروع",
		cancel: "يلغي",
		clear: "مسح",
		collection: "مجموعة",
		collections: "المجموعات",
		create: "يخلق",
		createPullRequest: "إنشاء طلب سحب",
		currentBranch: "الفرع الحالي",
		dashboard: "لوحة القيادة",
		defaultBranch: "الفرع الافتراضي",
		"delete": "يمسح",
		deleteBranch: "حذف الفرع",
		edit: "يحرر",
		loading: "جارٍ التحميل",
		newBranch: "فرع جديد",
		pullRequests: "طلبات السحب",
		otherBranches: "الفروع الأخرى",
		save: "يحفظ",
		search: "بحث",
		singleton: "سينجلتون",
		singletons: "الفردي",
		theCurrentlyCheckedOutBranch: "الفرع المعاد حاليا. اختر هذا إذا كنت بحاجة إلى البناء على العمل الحالي من الفرع الحالي.",
		theDefaultBranchInYourRepository: "الفرع الافتراضي في المستودع الخاص بك. اختر هذا لبدء شيء جديد لا يعتمد على فرعك الحالي.",
		viewPullRequests: "عرض طلبات السحب"
	},
	"lt-LT": {
		add: "Papildyti",
		basedOn: "Remiantis",
		branchName: "Filialo pavadinimas",
		branches: "Filialai",
		cancel: "Atšaukti",
		clear: "Skaidrus",
		collection: "Kolekcija",
		collections: "Kolekcijos",
		create: "Sukurti",
		createPullRequest: "Sukurti ištraukimo užklausą",
		currentBranch: "Dabartinis filialas",
		dashboard: "Prietaisų skydelis",
		defaultBranch: "Numatytoji šaka",
		"delete": "Ištrinti",
		deleteBranch: "Ištrinti šaką",
		edit: "Redaguoti",
		loading: "Įkeliama",
		newBranch: "Naujas filialas",
		otherBranches: "Kitos šakos",
		pullRequests: "Ištraukti užklausas",
		save: "Sutaupyti",
		search: "Ieškoti",
		singleton: "vienvietis",
		singletons: "Vienišiai",
		theCurrentlyCheckedOutBranch: "Šiuo metu išregistruotas filialas. Pasirinkite tai, jei reikia remtis esamu darbu iš dabartinės šakos.",
		viewPullRequests: "Peržiūrėkite ištraukimo užklausas",
		theDefaultBranchInYourRepository: "Numatytoji šaka jūsų saugykloje. Pasirinkite tai, kad pradėtumėte ką nors naujo, nepriklausančio nuo dabartinės šakos."
	},
	"el-GR": {
		basedOn: "Βασισμένο στο",
		branchName: "Όνομα υποκαταστήματος",
		branches: "Κλαδια δεντρου",
		cancel: "Ματαίωση",
		clear: "Καθαρισμός",
		collection: "Συλλογή",
		collections: "Συλλογές",
		create: "Δημιουργώ",
		createPullRequest: "Δημιουργία αιτήματος έλξης",
		currentBranch: "Τρέχον υποκατάστημα",
		dashboard: "Ταμπλό",
		defaultBranch: "Προεπιλεγμένος κλάδος",
		"delete": "Διαγράφω",
		deleteBranch: "Διαγραφή υποκαταστήματος",
		edit: "Επεξεργασία",
		loading: "Φόρτωση",
		newBranch: "Νέο υποκατάστημα",
		otherBranches: "Άλλα υποκαταστήματα",
		pullRequests: "Τραβήξτε αιτήματα",
		save: "Αποθηκεύσετε",
		search: "Αναζήτηση",
		singleton: "Μοναδικό χαρτί",
		singletons: "Singletons",
		theCurrentlyCheckedOutBranch: "Το υποκατάστημα που ελέγχεται αυτήν τη στιγμή. Επιλέξτε αυτό εάν χρειάζεται να βασιστείτε σε υπάρχουσες εργασίες από τον τρέχοντα κλάδο.",
		theDefaultBranchInYourRepository: "Ο προεπιλεγμένος κλάδος στο αποθετήριο σας. Επιλέξτε αυτό για να ξεκινήσετε κάτι νέο που δεν εξαρτάται από το τρέχον υποκατάστημά σας.",
		viewPullRequests: "Προβολή αιτημάτων έλξης",
		add: "Προσθήκη"
	},
	"nb-NO": {
		add: "Legg til",
		basedOn: "Basert på",
		branches: "Grener",
		branchName: "Filialnavn",
		cancel: "Avbryt",
		clear: "Tøm",
		collection: "Samling",
		collections: "Samlinger",
		create: "Skape",
		createPullRequest: "Opprett pull-forespørsel",
		currentBranch: "Nåværende gren",
		defaultBranch: "Standard gren",
		dashboard: "Dashbord",
		"delete": "Slett",
		deleteBranch: "Slett filial",
		edit: "Redigere",
		loading: "Laster inn",
		newBranch: "Ny gren",
		otherBranches: "Andre grener",
		pullRequests: "Trekk forespørsler",
		search: "Søk",
		save: "Lagre",
		singleton: "Singleton",
		singletons: "Singletoner",
		theCurrentlyCheckedOutBranch: "Den utsjekkede grenen. Velg dette hvis du skal bygge på eksisterende arbeid fra gjeldende gren.",
		theDefaultBranchInYourRepository: "Standardgrenen i depotet ditt. Velg dette for å starte noe nytt som ikke er avhengig av din nåværende filial.",
		viewPullRequests: "Se pull-forespørsler"
	},
	"nl-NL": {
		add: "Toevoegen",
		basedOn: "Gebaseerd op",
		branchName: "Filiaal naam",
		branches: "Takken",
		clear: "Helder",
		cancel: "Annuleren",
		collection: "Verzameling",
		collections: "Collecties",
		create: "Creëren",
		createPullRequest: "Pull-aanvraag maken",
		currentBranch: "Huidige tak",
		dashboard: "Dashboard",
		defaultBranch: "Standaard filiaal",
		"delete": "Verwijderen",
		deleteBranch: "Filiaal verwijderen",
		edit: "Bewerking",
		loading: "Laden",
		otherBranches: "Andere takken",
		newBranch: "Nieuwe tak",
		pullRequests: "Trek verzoeken",
		save: "Redden",
		search: "Zoeken",
		singleton: "eenling",
		singletons: "Eenlingen",
		theCurrentlyCheckedOutBranch: "Het momenteel uitgecheckte filiaal. Kies dit als u moet voortbouwen op bestaand werk van de huidige branch.",
		theDefaultBranchInYourRepository: "De standaard branch in uw repository. Kies dit om iets nieuws te starten dat niet afhankelijk is van uw huidige branche.",
		viewPullRequests: "Bekijk pull-aanvragen"
	},
	"pl-PL": {
		add: "Dodać",
		basedOn: "Oparte na",
		branchName: "Nazwa filii",
		cancel: "Anulować",
		branches: "Gałęzie",
		clear: "Wyczyść",
		collection: "Kolekcja",
		collections: "Kolekcje",
		create: "Tworzyć",
		createPullRequest: "Utwórz żądanie ściągnięcia",
		currentBranch: "Obecny oddział",
		dashboard: "Panel",
		defaultBranch: "Oddział domyślny",
		"delete": "Usuwać",
		deleteBranch: "Usuń oddział",
		edit: "Edytować",
		newBranch: "Nowa gałąź",
		loading: "Trwa ładowanie",
		otherBranches: "Inne gałęzie",
		pullRequests: "Żądania ściągnięcia",
		save: "Ratować",
		search: "Szukaj",
		singleton: "singel",
		singletons: "Singletony",
		theCurrentlyCheckedOutBranch: "Aktualnie wyewidencjonowana gałąź. Wybierz tę opcję, jeśli chcesz oprzeć się na istniejącej pracy z bieżącej gałęzi.",
		theDefaultBranchInYourRepository: "Domyślna gałąź w twoim repozytorium. Wybierz tę opcję, aby rozpocząć coś nowego, co nie jest zależne od bieżącej gałęzi.",
		viewPullRequests: "Wyświetl żądania ściągnięcia"
	},
	"pt-BR": {
		add: "Adicionar",
		basedOn: "Baseado em",
		branchName: "Nome da filial",
		branches: "Galhos",
		cancel: "Cancelar",
		clear: "Limpar",
		collection: "Coleção",
		collections: "Coleções",
		createPullRequest: "Criar solicitação pull",
		create: "Criar",
		currentBranch: "filial atual",
		dashboard: "Painel",
		defaultBranch: "ramo padrão",
		"delete": "Excluir",
		deleteBranch: "Excluir ramificação",
		edit: "Editar",
		loading: "Carregando",
		newBranch: "Nova filial",
		otherBranches: "Outros ramos",
		pullRequests: "Requisições pull",
		save: "Guardar",
		search: "Pesquisar",
		singleton: "solteiro",
		theCurrentlyCheckedOutBranch: "A ramificação atualmente com check-out. Escolha esta opção se precisar criar um trabalho existente na ramificação atual.",
		singletons: "Solteiros",
		theDefaultBranchInYourRepository: "A ramificação padrão em seu repositório. Escolha isso para iniciar algo novo que não dependa de sua ramificação atual.",
		viewPullRequests: "Ver solicitações pull"
	},
	"pt-PT": {
		add: "Adicionar",
		basedOn: "Baseado em",
		branchName: "Nome da filial",
		branches: "Galhos",
		clear: "Limpar",
		cancel: "Cancelar",
		collection: "Coleção",
		collections: "Coleções",
		createPullRequest: "Criar solicitação pull",
		create: "Criar",
		currentBranch: "filial atual",
		dashboard: "Painel",
		defaultBranch: "ramo padrão",
		"delete": "Excluir",
		deleteBranch: "Excluir ramificação",
		edit: "Editar",
		loading: "A carregar",
		otherBranches: "Outros ramos",
		newBranch: "Nova filial",
		pullRequests: "Requisições pull",
		save: "Guardar",
		search: "Procurar",
		singleton: "solteiro",
		singletons: "Solteiros",
		theCurrentlyCheckedOutBranch: "A ramificação atualmente com check-out. Escolha esta opção se precisar criar um trabalho existente na ramificação atual.",
		theDefaultBranchInYourRepository: "A ramificação padrão em seu repositório. Escolha isso para iniciar algo novo que não dependa de sua ramificação atual.",
		viewPullRequests: "Ver solicitações pull"
	},
	"ro-RO": {
		add: "Adăuga",
		basedOn: "Bazat pe",
		branchName: "Numele sucursalei",
		branches: "Ramuri",
		cancel: "Anulare",
		clear: "Golire",
		collection: "Colectie",
		collections: "Colecții",
		create: "Crea",
		createPullRequest: "Creați cerere de tragere",
		currentBranch: "Filiala actuală",
		dashboard: "Bord",
		defaultBranch: "Ramura implicită",
		"delete": "Șterge",
		deleteBranch: "Ștergeți ramura",
		loading: "Se încarcă",
		edit: "Editați",
		newBranch: "Filiala noua",
		otherBranches: "Alte ramuri",
		pullRequests: "Solicitări de tragere",
		save: "Salvați",
		search: "Căutare",
		singletons: "Singletons",
		singleton: "Singleton",
		theCurrentlyCheckedOutBranch: "Sucursala verificată în prezent. Alegeți acest lucru dacă trebuie să vă bazați pe munca existentă din ramura curentă.",
		theDefaultBranchInYourRepository: "Ramura implicită din depozitul dvs. Alegeți acest lucru pentru a începe ceva nou, care nu depinde de ramura dvs. actuală.",
		viewPullRequests: "Vizualizați solicitările de extragere"
	},
	"ru-RU": {
		add: "Добавлять",
		basedOn: "На основе",
		branchName: "Название филиала",
		branches: "Ветви",
		cancel: "Отмена",
		clear: "Очистить",
		collections: "Коллекции",
		collection: "Коллекция",
		create: "Создавать",
		createPullRequest: "Создать запрос на включение",
		dashboard: "Панель приборов",
		currentBranch: "Текущая ветвь",
		defaultBranch: "Ветка по умолчанию",
		"delete": "Удалить",
		deleteBranch: "Удалить ветку",
		edit: "Редактировать",
		loading: "Загрузка",
		newBranch: "Новая ветка",
		otherBranches: "Другие филиалы",
		pullRequests: "Пулл-реквесты",
		save: "Сохранять",
		search: "Поиск",
		singletons: "Одиночки",
		singleton: "Синглтон",
		theCurrentlyCheckedOutBranch: "Текущая проверенная ветвь. Выберите это, если вам нужно опираться на существующую работу из текущей ветки.",
		theDefaultBranchInYourRepository: "Ветка по умолчанию в вашем репозитории. Выберите это, чтобы начать что-то новое, не зависящее от вашей текущей ветки.",
		viewPullRequests: "Посмотреть пул-реквесты"
	},
	"sk-SK": {
		add: "Pridať",
		basedOn: "Založené na",
		branches: "Pobočky",
		branchName: "Meno pobočky",
		cancel: "Zrušiť",
		clear: "Vymazať",
		collection: "Zbierka",
		create: "Vytvorte",
		collections: "zbierky",
		createPullRequest: "Vytvorte požiadavku na stiahnutie",
		currentBranch: "Aktuálna pobočka",
		dashboard: "Dashboard",
		defaultBranch: "Predvolená vetva",
		"delete": "Odstrániť",
		deleteBranch: "Odstrániť vetvu",
		edit: "Upraviť",
		loading: "Načítava sa",
		newBranch: "Nová pobočka",
		otherBranches: "Ostatné pobočky",
		pullRequests: "Vytiahnite žiadosti",
		save: "Uložiť",
		search: "Vyhľadávať",
		singleton: "Singleton",
		singletons: "Singletons",
		theCurrentlyCheckedOutBranch: "Aktuálne odhlásená pobočka. Túto možnosť vyberte, ak potrebujete stavať na existujúcej práci z aktuálnej pobočky.",
		theDefaultBranchInYourRepository: "Predvolená vetva vo vašom úložisku. Zvoľte túto možnosť, ak chcete začať niečo nové, čo nezávisí od vašej aktuálnej pobočky.",
		viewPullRequests: "Zobraziť požiadavky na stiahnutie"
	},
	"sl-SI": {
		add: "Dodaj",
		basedOn: "Temelji na",
		branchName: "Ime podružnice",
		branches: "Podružnice",
		cancel: "Prekliči",
		collection: "Zbirka",
		clear: "Jasen",
		collections: "Zbirke",
		create: "Ustvari",
		createPullRequest: "Ustvari zahtevo za vleko",
		dashboard: "Nadzorna plošča",
		currentBranch: "Trenutna veja",
		"delete": "Izbriši",
		defaultBranch: "Privzeta veja",
		deleteBranch: "Izbriši vejo",
		edit: "Uredi",
		newBranch: "Nova podružnica",
		loading: "Nalaganje",
		otherBranches: "Druge veje",
		pullRequests: "Zahteve za vlečenje",
		save: "Shrani",
		search: "Iskanje",
		singleton: "Singleton",
		singletons: "Samski",
		theCurrentlyCheckedOutBranch: "Trenutno odjavljena podružnica. To izberite, če morate graditi na obstoječem delu iz trenutne veje.",
		viewPullRequests: "Oglejte si zahteve za vlečenje",
		theDefaultBranchInYourRepository: "Privzeta veja v vašem skladišču. Izberite to, da začnete nekaj novega, kar ni odvisno od vaše trenutne veje."
	},
	"sr-SP": {
		add: "Додати",
		basedOn: "На бази",
		branchName: "Назив огранка",
		branches: "Огранци",
		cancel: "Поништити, отказати",
		clear: "Izbriši",
		collection: "Цоллецтион",
		collections: "Збирке",
		create: "Креирај",
		currentBranch: "Тренутна грана",
		createPullRequest: "Креирајте захтев за повлачење",
		defaultBranch: "Подразумевана грана",
		dashboard: "Командна табла",
		"delete": "Избриши",
		deleteBranch: "Обриши грану",
		loading: "Učitavam",
		edit: "Уредити",
		newBranch: "Нова грана",
		otherBranches: "Остале гране",
		pullRequests: "Захтеви за повлачење",
		save: "сачувати",
		search: "Pretraga",
		singleton: "Синглетон",
		singletons: "Синглетонс",
		theCurrentlyCheckedOutBranch: "Тренутно одјављена филијала. Изаберите ово ако треба да надоградите постојећи рад из тренутне гране.",
		theDefaultBranchInYourRepository: "Подразумевана грана у вашем спремишту. Изаберите ово да започнете нешто ново што не зависи од ваше тренутне гране.",
		viewPullRequests: "Прегледајте захтеве за повлачењем"
	},
	"sv-SE": {
		add: "Lägg till",
		basedOn: "Baserat på",
		branchName: "Filialens namn",
		branches: "Grenar",
		cancel: "Поништити, отказати",
		clear: "Rensa",
		collection: "Samling",
		collections: "Samlingar",
		create: "Skapa",
		createPullRequest: "Skapa pull-förfrågan",
		currentBranch: "Nuvarande gren",
		dashboard: "instrumentbräda",
		defaultBranch: "Standardgren",
		"delete": "Radera",
		deleteBranch: "Ta bort gren",
		edit: "Redigera",
		loading: "Läser in",
		newBranch: "Ny gren",
		otherBranches: "Andra grenar",
		pullRequests: "Dra förfrågningar",
		save: "Spara",
		search: "Sök",
		singleton: "Singleton",
		singletons: "Singlar",
		theCurrentlyCheckedOutBranch: "Den utcheckade filialen. Välj detta om du behöver bygga på befintligt arbete från den aktuella grenen.",
		theDefaultBranchInYourRepository: "Standardgrenen i ditt arkiv. Välj detta för att starta något nytt som inte är beroende av din nuvarande filial.",
		viewPullRequests: "Visa pull-förfrågningar"
	},
	"tr-TR": {
		add: "Avbryt",
		basedOn: "Dayalı",
		branchName: "şube adı",
		branches: "Şubeler",
		cancel: "iptal etmek",
		collection: "Toplamak",
		clear: "Temizle",
		collections: "Koleksiyonlar",
		create: "Yaratmak",
		createPullRequest: "Çekme isteği oluştur",
		currentBranch: "Mevcut şube",
		dashboard: "Gösterge Paneli",
		defaultBranch: "varsayılan dal",
		"delete": "Silmek",
		deleteBranch: "Şubeyi sil",
		edit: "Düzenlemek",
		loading: "Yükleniyor",
		newBranch: "Yeni dal",
		otherBranches: "Diğer şubeler",
		pullRequests: "Çekme istekleri",
		save: "Kaydetmek",
		search: "Ara",
		singleton: "Tekil",
		singletons: "Singleton'lar",
		theCurrentlyCheckedOutBranch: "Şu anda kontrol edilen şube. Geçerli daldaki mevcut işi geliştirmeniz gerekiyorsa bunu seçin.",
		theDefaultBranchInYourRepository: "Deponuzdaki varsayılan şube. Mevcut şubenize bağlı olmayan yeni bir şey başlatmak için bunu seçin.",
		viewPullRequests: "Çekme isteklerini görüntüle"
	},
	"uk-UA": {
		add: "додати",
		basedOn: "На основі",
		branchName: "Назва гілки",
		branches: "Відділення",
		cancel: "скасувати",
		clear: "Очистити",
		collection: "Колекція",
		collections: "Колекції",
		create: "Створити",
		createPullRequest: "Створити запит на отримання",
		currentBranch: "Поточне відділення",
		defaultBranch: "Гілка за замовчуванням",
		dashboard: "Панель приладів",
		"delete": "Видалити",
		deleteBranch: "Видалити гілку",
		edit: "Редагувати",
		loading: "Завантаження",
		newBranch: "Нова гілка",
		otherBranches: "Інші гілки",
		pullRequests: "Запити на витягування",
		save: "зберегти",
		search: "Пошук",
		singleton: "Синглтон",
		singletons: "Одиночки",
		theCurrentlyCheckedOutBranch: "Поточна перевірена гілка. Виберіть це, якщо вам потрібно створити на основі існуючої роботи з поточної гілки.",
		theDefaultBranchInYourRepository: "Стандартна гілка у вашому сховищі. Виберіть це, щоб почати щось нове, що не залежить від вашої поточної гілки.",
		viewPullRequests: "Перегляд запитів на отримання"
	},
	"zh-CN": {
		add: "添加",
		basedOn: "基于",
		branchName: "分店名称",
		branches: "分支机构",
		cancel: "取消",
		clear: "透明",
		collection: "收藏",
		collections: "收藏品",
		create: "创造",
		createPullRequest: "创建拉取请求",
		currentBranch: "当前分支",
		dashboard: "仪表板",
		defaultBranch: "默认分支",
		"delete": "删除",
		deleteBranch: "删除分支",
		edit: "编辑",
		loading: "正在加载",
		otherBranches: "其他分行",
		newBranch: "新分行",
		pullRequests: "拉取请求",
		save: "节省",
		search: "搜索",
		singleton: "单例",
		singletons: "单例",
		theCurrentlyCheckedOutBranch: "当前签出的分支。 如果您需要在当前分支的现有工作的基础上构建，请选择此项。",
		theDefaultBranchInYourRepository: "存储库中的默认分支。 选择此选项可开始一些不依赖于当前分支的新操作。",
		viewPullRequests: "查看拉取请求"
	},
	"zh-TW": {
		add: "添加",
		basedOn: "基於",
		branchName: "分店名稱",
		branches: "分支機構",
		cancel: "取消",
		clear: "清除",
		collection: "收藏",
		collections: "收藏品",
		create: "創造",
		createPullRequest: "創建拉取請求",
		currentBranch: "當前分支",
		dashboard: "儀表板",
		defaultBranch: "默認分支",
		"delete": "刪除",
		deleteBranch: "刪除分支",
		edit: "編輯",
		loading: "正在載入",
		newBranch: "新分行",
		otherBranches: "其他分行",
		pullRequests: "拉取請求",
		save: "節省",
		search: "搜尋",
		singleton: "單例",
		theCurrentlyCheckedOutBranch: "當前簽出的分支。 如果您需要在當前分支的現有工作的基礎上構建，請選擇此項。",
		singletons: "單例",
		theDefaultBranchInYourRepository: "存儲庫中的默認分支。 選擇此選項可開始一些不依賴於當前分支的新操作。",
		viewPullRequests: "查看拉取請求"
	},
	"de-DE": {
		add: "Hinzufügen",
		basedOn: "Bezogen auf",
		branchName: "Zweigname",
		branches: "Geäst",
		cancel: "Stornieren",
		clear: "Löschen",
		collection: "Sammlung",
		collections: "Sammlungen",
		create: "Erstellen",
		createPullRequest: "Pull-Request erstellen",
		currentBranch: "Aktueller Zweig",
		dashboard: "Armaturenbrett",
		defaultBranch: "Standardzweig",
		"delete": "Löschen",
		deleteBranch: "Zweig löschen",
		edit: "Bearbeiten",
		loading: "Wird geladen",
		newBranch: "Neue Zweig",
		otherBranches: "Andere Filialen",
		pullRequests: "Pull-Requests",
		save: "Speichern",
		search: "Suchen",
		singleton: "Einzelling",
		singletons: "Singles",
		theCurrentlyCheckedOutBranch: "Der aktuell ausgecheckte Zweig. Wählen Sie diese Option, wenn Sie auf vorhandener Arbeit aus dem aktuellen Zweig aufbauen müssen.",
		theDefaultBranchInYourRepository: "Der Standard-Branch in Ihrem Repository. Wählen Sie dies, um etwas Neues zu starten, das nicht von Ihrem aktuellen Zweig abhängt.",
		viewPullRequests: "Pull-Requests anzeigen"
	},
	"lv-LV": {
		add: "Pievienot",
		basedOn: "Balstoties uz",
		branchName: "Filiāles nosaukums",
		branches: "Nozares",
		cancel: "Atcelt",
		clear: "Notīrīt",
		collections: "Kolekcijas",
		create: "Izveidot",
		createPullRequest: "Izveidot izvilkšanas pieprasījumu",
		currentBranch: "Pašreizējā filiāle",
		dashboard: "Mērinstrumentu panelis",
		defaultBranch: "Noklusējuma filiāle",
		"delete": "Dzēst",
		deleteBranch: "Dzēst filiāli",
		edit: "Rediģēt",
		loading: "Notiek ielāde",
		newBranch: "Jauna filiāle",
		otherBranches: "Citas filiāles",
		pullRequests: "Izvilkšanas pieprasījumi",
		save: "Saglabāt",
		search: "Meklēt",
		singleton: "Singleton",
		singletons: "Vientuļi",
		theDefaultBranchInYourRepository: "Noklusējuma filiāle jūsu repozitorijā. Izvēlieties šo, lai sāktu kaut ko jaunu, kas nav atkarīgs no jūsu pašreizējās filiāles.",
		theCurrentlyCheckedOutBranch: "Pašlaik izrakstītā filiāle. Izvēlieties šo, ja vēlaties izmantot esošo darbu no pašreizējās filiāles.",
		viewPullRequests: "Skatīt izvilkšanas pieprasījumus",
		collection: "Kolekcija"
	}
};

const RouterContext = /*#__PURE__*/createContext(null);
function RouterProvider(props) {
  return /*#__PURE__*/jsx(RouterContext.Provider, {
    value: props.router,
    children: props.children
  });
}
function useRouter() {
  const router = useContext(RouterContext);
  if (router == null) {
    throw new Error('useRouter must be used within a RouterProvider');
  }
  return router;
}

function EmptyState(props) {
  return /*#__PURE__*/jsx(Flex, {
    alignItems: "center",
    direction: "column",
    gap: "large",
    justifyContent: "center",
    minHeight: "scale.3000",
    paddingX: {
      mobile: 'medium',
      tablet: 'xlarge',
      desktop: 'xxlarge'
    },
    children: 'children' in props ? props.children : /*#__PURE__*/jsxs(Fragment, {
      children: [props.icon && /*#__PURE__*/jsx(Icon, {
        src: props.icon,
        size: "large",
        color: "neutralEmphasis"
      }), props.title && /*#__PURE__*/jsx(Heading, {
        align: "center",
        size: "medium",
        children: props.title
      }), props.message && /*#__PURE__*/jsx(Text, {
        align: "center",
        children: props.message
      }), props.actions]
    })
  });
}

const LOADING = Symbol('loading');
function isThenable(value) {
  return value && typeof value.then === 'function';
}
function useData(func) {
  const [state, setState] = useState({
    kind: 'loading'
  });
  let stateToReturn = state;
  const result = useMemo(() => {
    try {
      const result = func();
      return {
        kind: 'result',
        result
      };
    } catch (error) {
      return {
        kind: 'error',
        error: error
      };
    }
  }, [func]);
  const resultState = useMemo(() => {
    if (result.kind === 'error' && (state.kind !== 'error' || state.error !== result.error)) {
      return {
        kind: 'error',
        error: result.error
      };
    }
    if (result.kind === 'result' && !isThenable(result.result) && result.result !== LOADING && (state.kind !== 'loaded' || state.data !== result.result)) {
      return {
        kind: 'loaded',
        data: result.result
      };
    }
  }, [result, state]);
  if (resultState && resultState !== state) {
    stateToReturn = resultState;
    setState(resultState);
  }
  useEffect(() => {
    if (result.kind === 'result' && isThenable(result.result)) {
      setState({
        kind: 'loading'
      });
      let isActive = true;
      result.result.then(result => {
        if (result === LOADING || !isActive) return;
        setState({
          kind: 'loaded',
          data: result
        });
      }, error => {
        if (!isActive) return;
        setState({
          kind: 'error',
          error
        });
      });
      return () => {
        isActive = false;
      };
    }
  }, [result]);
  return stateToReturn;
}
function mergeDataStates(input) {
  const entries = Object.entries(input);
  for (const [, value] of entries) {
    if (value.kind === 'error') {
      return {
        kind: 'error',
        error: value.error
      };
    }
  }
  for (const [, value] of entries) {
    if (value.kind === 'loading') {
      return {
        kind: 'loading'
      };
    }
  }
  return {
    kind: 'loaded',
    data: Object.fromEntries(entries.map(([key, val]) => {
      return [key, val.data];
    }))
  };
}

const storedTokenSchema = z.object({
  token: z.string(),
  validUntil: z.number().transform(val => new Date(val))
});
function getSyncAuth(config) {
  if (typeof document === 'undefined') {
    return null;
  }
  if (config.storage.kind === 'github') {
    const cookies = parse(document.cookie);
    const accessToken = cookies['keystatic-gh-access-token'];
    if (!accessToken) {
      return null;
    }
    return {
      accessToken
    };
  }
  if (config.storage.kind === 'cloud') {
    const unparsedTokenData = localStorage.getItem('keystatic-cloud-access-token');
    let tokenData;
    try {
      tokenData = storedTokenSchema.parse(JSON.parse(unparsedTokenData));
    } catch (err) {
      return null;
    }
    if (!tokenData || tokenData.validUntil < new Date()) {
      return null;
    }
    return {
      accessToken: tokenData.token
    };
  }
  return null;
}
async function getAuth(config) {
  const token = getSyncAuth(config);
  if (config.storage.kind === 'github' && !token) {
    try {
      const res = await fetch('/api/keystatic/github/refresh-token', {
        method: 'POST'
      });
      if (res.status === 200) {
        const cookies = parse(document.cookie);
        const accessToken = cookies['keystatic-gh-access-token'];
        if (accessToken) {
          return {
            accessToken
          };
        }
      }
    } catch {}
    return null;
  }
  return token;
}

const SidebarFooter_viewer = gql`
  fragment SidebarFooter_viewer on User {
    id
    name
    login
    avatarUrl
    databaseId
  }
`;
const ViewerContext = /*#__PURE__*/createContext(undefined);
function useViewer() {
  return useContext(ViewerContext);
}

function parseRepoConfig(repo) {
  if (typeof repo === 'string') {
    const [owner, name] = repo.split('/');
    return {
      owner,
      name
    };
  }
  return repo;
}
function serializeRepoConfig(repo) {
  if (typeof repo === 'string') {
    return repo;
  }
  return `${repo.owner}/${repo.name}`;
}
function assertValidRepoConfig(repo) {
  if (typeof repo === 'string') {
    if (!repo.includes('/')) {
      throw new Error(`Invalid repo config: ${repo}. It must be in the form owner/name`);
    }
  }
  if (typeof repo === 'object') {
    if (!repo.owner && !repo.name) {
      throw new Error(`Invalid repo config: owner and name are missing`);
    }
    if (!repo.owner) {
      throw new Error(`Invalid repo config: owner is missing`);
    }
    if (!repo.name) {
      throw new Error(`Invalid repo config: name is missing`);
    }
  }
}

function fetchLocalTree(sha) {
  if (treeCache.has(sha)) {
    return treeCache.get(sha);
  }
  const promise = fetch('/api/keystatic/tree', {
    headers: {
      'no-cors': '1'
    }
  }).then(x => x.json()).then(async entries => hydrateTreeCacheWithEntries(entries));
  treeCache.set(sha, promise);
  return promise;
}
function useSetTreeSha() {
  return useContext(SetTreeShaContext);
}
const SetTreeShaContext = /*#__PURE__*/createContext(() => {
  throw new Error('SetTreeShaContext not set');
});
function LocalAppShellProvider(props) {
  const [currentTreeSha, setCurrentTreeSha] = useState('initial');
  const tree = useData(useCallback(() => fetchLocalTree(currentTreeSha), [currentTreeSha]));
  const allTreeData = useMemo(() => ({
    default: tree,
    current: tree,
    merged: mergeDataStates({
      default: tree,
      current: tree
    })
  }), [tree]);
  const changedData = useMemo(() => {
    if (allTreeData.merged.kind !== 'loaded') {
      return {
        collections: new Map(),
        singletons: new Set()
      };
    }
    return getChangedData(props.config, allTreeData.merged.data);
  }, [allTreeData, props.config]);
  return /*#__PURE__*/jsx(SetTreeShaContext.Provider, {
    value: setCurrentTreeSha,
    children: /*#__PURE__*/jsx(ChangedContext.Provider, {
      value: changedData,
      children: /*#__PURE__*/jsx(TreeContext.Provider, {
        value: allTreeData,
        children: props.children
      })
    })
  });
}
const GitHubAppShellDataContext = /*#__PURE__*/createContext(null);
function GitHubAppShellDataProvider(props) {
  const [state] = useQuery({
    query: props.config.storage.kind === 'github' ? GitHubAppShellQuery : CloudAppShellQuery,
    variables: props.config.storage.kind === 'github' ? parseRepoConfig(props.config.storage.repo) : {
      name: 'repo-name',
      owner: 'repo-owner'
    }
  });
  return /*#__PURE__*/jsx(GitHubAppShellDataContext.Provider, {
    value: state,
    children: /*#__PURE__*/jsx(ViewerContext.Provider, {
      value: state.data && 'viewer' in state.data ? state.data.viewer : undefined,
      children: props.children
    })
  });
}
const writePermissions = new Set(['WRITE', 'ADMIN', 'MAINTAIN']);
function GitHubAppShellProvider(props) {
  var _repo, _repo3, _defaultBranchRef$tar, _currentBranchRef$tar, _currentBranchRef$tar2, _currentBranchRef$tar3, _repo5, _repo7, _repo13, _repo14, _repo15, _data$repository3, _data$repository4, _repo16;
  const router = useRouter();
  const {
    data,
    error
  } = useContext(GitHubAppShellDataContext);
  let repo = data === null || data === void 0 ? void 0 : data.repository;
  if (repo && 'viewerPermission' in repo && repo.viewerPermission && !writePermissions.has(repo.viewerPermission) && 'forks' in repo) {
    var _repo$forks$nodes$, _repo$forks;
    repo = (_repo$forks$nodes$ = (_repo$forks = repo.forks) === null || _repo$forks === void 0 || (_repo$forks = _repo$forks.nodes) === null || _repo$forks === void 0 ? void 0 : _repo$forks[0]) !== null && _repo$forks$nodes$ !== void 0 ? _repo$forks$nodes$ : repo;
  }
  const defaultBranchRef = (_repo = repo) === null || _repo === void 0 || (_repo = _repo.refs) === null || _repo === void 0 || (_repo = _repo.nodes) === null || _repo === void 0 ? void 0 : _repo.find(x => {
    var _repo2;
    return (x === null || x === void 0 ? void 0 : x.name) === ((_repo2 = repo) === null || _repo2 === void 0 || (_repo2 = _repo2.defaultBranchRef) === null || _repo2 === void 0 ? void 0 : _repo2.name);
  });
  const currentBranchRef = (_repo3 = repo) === null || _repo3 === void 0 || (_repo3 = _repo3.refs) === null || _repo3 === void 0 || (_repo3 = _repo3.nodes) === null || _repo3 === void 0 ? void 0 : _repo3.find(x => (x === null || x === void 0 ? void 0 : x.name) === props.currentBranch);
  const defaultBranchTreeSha = (_defaultBranchRef$tar = defaultBranchRef === null || defaultBranchRef === void 0 ? void 0 : defaultBranchRef.target.tree.oid) !== null && _defaultBranchRef$tar !== void 0 ? _defaultBranchRef$tar : null;
  const currentBranchTreeSha = (_currentBranchRef$tar = currentBranchRef === null || currentBranchRef === void 0 ? void 0 : currentBranchRef.target.tree.oid) !== null && _currentBranchRef$tar !== void 0 ? _currentBranchRef$tar : null;
  const baseCommit = (_currentBranchRef$tar2 = currentBranchRef === null || currentBranchRef === void 0 || (_currentBranchRef$tar3 = currentBranchRef.target) === null || _currentBranchRef$tar3 === void 0 ? void 0 : _currentBranchRef$tar3.oid) !== null && _currentBranchRef$tar2 !== void 0 ? _currentBranchRef$tar2 : null;
  const defaultBranchTree = useGitHubTreeData(defaultBranchTreeSha, props.config);
  const currentBranchTree = useGitHubTreeData(currentBranchTreeSha, props.config);
  const allTreeData = useMemo(() => ({
    default: defaultBranchTree,
    current: currentBranchTree,
    merged: mergeDataStates({
      default: defaultBranchTree,
      current: currentBranchTree
    })
  }), [currentBranchTree, defaultBranchTree]);
  const changedData = useMemo(() => {
    if (allTreeData.merged.kind !== 'loaded') {
      return {
        collections: new Map(),
        singletons: new Set()
      };
    }
    return getChangedData(props.config, allTreeData.merged.data);
  }, [allTreeData, props.config]);
  useEffect(() => {
    var _error$response, _repo4;
    if ((error === null || error === void 0 || (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {
      if (isGitHubConfig(props.config)) {
        window.location.href = `/api/keystatic/github/login?from=${router.params.join('/')}`;
      } else {
        redirectToCloudAuth(router.params.join('/'), props.config);
      }
    }
    if (!((_repo4 = repo) !== null && _repo4 !== void 0 && _repo4.id) && error !== null && error !== void 0 && error.graphQLErrors.some(err => {
      var _err$originalError, _err$originalError2;
      return (err === null || err === void 0 || (_err$originalError = err.originalError) === null || _err$originalError === void 0 ? void 0 : _err$originalError.type) === 'NOT_FOUND' || (err === null || err === void 0 || (_err$originalError2 = err.originalError) === null || _err$originalError2 === void 0 ? void 0 : _err$originalError2.type) === 'FORBIDDEN';
    })) {
      window.location.href = `/api/keystatic/github/repo-not-found?from=${router.params.join('/')}`;
    }
  }, [error, router, (_repo5 = repo) === null || _repo5 === void 0 ? void 0 : _repo5.id, props.config]);
  const baseInfo = useMemo(() => {
    var _repo$id, _repo6;
    return {
      baseCommit: baseCommit || '',
      repositoryId: (_repo$id = (_repo6 = repo) === null || _repo6 === void 0 ? void 0 : _repo6.id) !== null && _repo$id !== void 0 ? _repo$id : ''
    };
  }, [baseCommit, (_repo7 = repo) === null || _repo7 === void 0 ? void 0 : _repo7.id]);
  const branchInfo = useMemo(() => {
    var _repo$defaultBranchRe, _repo8, _repo$id2, _repo9, _repo$refs$nodes$map$, _repo10, _repo11, _repo12, _data$repository$owne, _data$repository, _data$repository$name, _data$repository2;
    return {
      defaultBranch: (_repo$defaultBranchRe = (_repo8 = repo) === null || _repo8 === void 0 || (_repo8 = _repo8.defaultBranchRef) === null || _repo8 === void 0 ? void 0 : _repo8.name) !== null && _repo$defaultBranchRe !== void 0 ? _repo$defaultBranchRe : '',
      currentBranch: props.currentBranch,
      baseCommit: baseCommit || '',
      repositoryId: (_repo$id2 = (_repo9 = repo) === null || _repo9 === void 0 ? void 0 : _repo9.id) !== null && _repo$id2 !== void 0 ? _repo$id2 : '',
      allBranches: (_repo$refs$nodes$map$ = (_repo10 = repo) === null || _repo10 === void 0 || (_repo10 = _repo10.refs) === null || _repo10 === void 0 || (_repo10 = _repo10.nodes) === null || _repo10 === void 0 ? void 0 : _repo10.map(x => x === null || x === void 0 ? void 0 : x.name).filter(isDefined)) !== null && _repo$refs$nodes$map$ !== void 0 ? _repo$refs$nodes$map$ : [],
      hasPullRequests: !!(currentBranchRef !== null && currentBranchRef !== void 0 && currentBranchRef.associatedPullRequests.totalCount),
      branchNameToId: new Map((_repo11 = repo) === null || _repo11 === void 0 || (_repo11 = _repo11.refs) === null || _repo11 === void 0 || (_repo11 = _repo11.nodes) === null || _repo11 === void 0 ? void 0 : _repo11.filter(isDefined).map(x => [x.name, x.id])),
      branchNameToBaseCommit: new Map((_repo12 = repo) === null || _repo12 === void 0 || (_repo12 = _repo12.refs) === null || _repo12 === void 0 || (_repo12 = _repo12.nodes) === null || _repo12 === void 0 ? void 0 : _repo12.flatMap(x => x !== null && x !== void 0 && x.target ? [[x.name, x.target.oid]] : [])),
      mainOwner: (_data$repository$owne = data === null || data === void 0 || (_data$repository = data.repository) === null || _data$repository === void 0 ? void 0 : _data$repository.owner.login) !== null && _data$repository$owne !== void 0 ? _data$repository$owne : '',
      mainRepo: (_data$repository$name = data === null || data === void 0 || (_data$repository2 = data.repository) === null || _data$repository2 === void 0 ? void 0 : _data$repository2.name) !== null && _data$repository$name !== void 0 ? _data$repository$name : ''
    };
  }, [(_repo13 = repo) === null || _repo13 === void 0 || (_repo13 = _repo13.defaultBranchRef) === null || _repo13 === void 0 ? void 0 : _repo13.name, (_repo14 = repo) === null || _repo14 === void 0 ? void 0 : _repo14.id, (_repo15 = repo) === null || _repo15 === void 0 || (_repo15 = _repo15.refs) === null || _repo15 === void 0 ? void 0 : _repo15.nodes, props.currentBranch, baseCommit, currentBranchRef === null || currentBranchRef === void 0 ? void 0 : currentBranchRef.associatedPullRequests.totalCount, data === null || data === void 0 || (_data$repository3 = data.repository) === null || _data$repository3 === void 0 ? void 0 : _data$repository3.owner.login, data === null || data === void 0 || (_data$repository4 = data.repository) === null || _data$repository4 === void 0 ? void 0 : _data$repository4.name]);
  return /*#__PURE__*/jsx(RepoWithWriteAccessContext.Provider, {
    value: repo && (props.config.storage.kind === 'cloud' || 'viewerPermission' in repo && (_repo16 = repo) !== null && _repo16 !== void 0 && _repo16.viewerPermission && writePermissions.has(repo.viewerPermission)) ? {
      name: repo.name,
      owner: repo.owner.login
    } : null,
    children: /*#__PURE__*/jsx(AppShellErrorContext.Provider, {
      value: error,
      children: /*#__PURE__*/jsx(BranchInfoContext.Provider, {
        value: branchInfo,
        children: /*#__PURE__*/jsx(BaseInfoContext.Provider, {
          value: baseInfo,
          children: /*#__PURE__*/jsx(ChangedContext.Provider, {
            value: changedData,
            children: /*#__PURE__*/jsx(TreeContext.Provider, {
              value: allTreeData,
              children: props.children
            })
          })
        })
      })
    })
  });
}
const AppShellErrorContext = /*#__PURE__*/createContext(undefined);
const BaseInfoContext = /*#__PURE__*/createContext({
  baseCommit: '',
  repositoryId: ''
});
const ChangedContext = /*#__PURE__*/createContext({
  collections: new Map(),
  singletons: new Set()
});
const TreeContext = /*#__PURE__*/createContext({
  current: {
    kind: 'loading'
  },
  default: {
    kind: 'loading'
  },
  merged: {
    kind: 'loading'
  }
});
function useTree() {
  return useContext(TreeContext);
}
function useChanged() {
  return useContext(ChangedContext);
}
function useBaseCommit() {
  return useContext(BaseInfoContext).baseCommit;
}
function useRepositoryId() {
  return useContext(BaseInfoContext).repositoryId;
}
const Ref_base = gql`
  fragment Ref_base on Ref {
    id
    name
    target {
      __typename
      id
      oid
      ... on Commit {
        tree {
          id
          oid
        }
      }
    }
    associatedPullRequests(states: [OPEN]) {
      totalCount
    }
  }
`;
const BaseRepo = gql`
  fragment Repo_base on Repository {
    id
    owner {
      id
      login
    }
    name
    defaultBranchRef {
      id
      name
    }
    refs(refPrefix: "refs/heads/", first: 100) {
      nodes {
        ...Ref_base
      }
    }
  }
  ${Ref_base}
`;
const CloudAppShellQuery = gql`
  query CloudAppShell($name: String!, $owner: String!) {
    repository(owner: $owner, name: $name) {
      id
      ...Repo_base
    }
  }
  ${BaseRepo}
`;
const Repo_ghDirect = gql`
  fragment Repo_ghDirect on Repository {
    id
    ...Repo_base
    viewerPermission
  }
  ${BaseRepo}
`;
const Repo_primary = gql`
  fragment Repo_primary on Repository {
    id
    ...Repo_ghDirect
    forks(affiliations: [OWNER], first: 1) {
      nodes {
        ...Repo_ghDirect
      }
    }
  }
  ${Repo_ghDirect}
`;
const GitHubAppShellQuery = gql`
  query GitHubAppShell($name: String!, $owner: String!) {
    repository(owner: $owner, name: $name) {
      id
      ...Repo_primary
    }
    viewer {
      ...SidebarFooter_viewer
    }
  }
  ${Repo_primary}
  ${SidebarFooter_viewer}
`;
const treeCache = new LRU({
  max: 40
});
async function hydrateTreeCacheWithEntries(entries) {
  const data = {
    entries: new Map(entries.map(entry => [entry.path, entry])),
    tree: treeEntriesToTreeNodes(entries)
  };
  const sha = await treeSha(data.tree);
  treeCache.set(sha, data);
  return data;
}
function fetchGitHubTreeData(sha, config) {
  const cached = treeCache.get(sha);
  if (cached) return cached;
  const promise = getAuth(config).then(auth => {
    if (!auth) throw new Error('Not authorized');
    return fetch(config.storage.kind === 'github' ? `https://api.github.com/repos/${serializeRepoConfig(config.storage.repo)}/git/trees/${sha}?recursive=1` : `${KEYSTATIC_CLOUD_API_URL}/v1/github/trees/${sha}`, {
      headers: {
        Authorization: `Bearer ${auth.accessToken}`,
        ...(config.storage.kind === 'cloud' ? KEYSTATIC_CLOUD_HEADERS : {})
      }
    }).then(x => x.json());
  }).then(res => hydrateTreeCacheWithEntries(res.tree.map(({
    url,
    ...rest
  }) => rest)));
  treeCache.set(sha, promise);
  return promise;
}
function useGitHubTreeData(sha, config) {
  return useData(useCallback(() => sha ? fetchGitHubTreeData(sha, config) : LOADING, [sha, config]));
}
const RepoWithWriteAccessContext = /*#__PURE__*/createContext(null);
const BranchInfoContext = /*#__PURE__*/createContext({
  currentBranch: '',
  allBranches: [],
  defaultBranch: '',
  hasPullRequests: false,
  branchNameToId: new Map(),
  branchNameToBaseCommit: new Map(),
  mainOwner: '',
  mainRepo: ''
});
function useBranchInfo() {
  return useContext(BranchInfoContext);
}
function getChangedData(config, trees) {
  var _config$collections, _config$singletons;
  return {
    collections: new Map(Object.keys((_config$collections = config.collections) !== null && _config$collections !== void 0 ? _config$collections : {}).map(collection => {
      const currentBranch = new Map(getEntriesInCollectionWithTreeKey(config, collection, trees.current.tree).map(x => [x.slug, x.key]));
      const defaultBranch = new Map(getEntriesInCollectionWithTreeKey(config, collection, trees.default.tree).map(x => [x.slug, x.key]));
      const changed = new Set();
      const added = new Set();
      for (const [key, entry] of currentBranch) {
        const defaultBranchEntry = defaultBranch.get(key);
        if (defaultBranchEntry === undefined) {
          added.add(key);
          continue;
        }
        if (entry !== defaultBranchEntry) {
          changed.add(key);
        }
      }
      const removed = new Set([...defaultBranch.keys()].filter(key => !currentBranch.has(key)));
      return [collection, {
        removed,
        added,
        changed,
        totalCount: currentBranch.size
      }];
    })),
    singletons: new Set(Object.keys((_config$singletons = config.singletons) !== null && _config$singletons !== void 0 ? _config$singletons : {}).filter(singleton => {
      var _getTreeNodeAtPath, _getTreeNodeAtPath2;
      const singletonPath = getSingletonPath(config, singleton);
      return ((_getTreeNodeAtPath = getTreeNodeAtPath(trees.current.tree, singletonPath)) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha) !== ((_getTreeNodeAtPath2 = getTreeNodeAtPath(trees.default.tree, singletonPath)) === null || _getTreeNodeAtPath2 === void 0 ? void 0 : _getTreeNodeAtPath2.entry.sha);
    }))
  };
}

const SIDE_PANEL_ID = 'keystatic-side-panel';
const MAIN_PANEL_ID = 'keystatic-main-panel';

const View = props => {
  return /*#__PURE__*/jsx(Box, {
    height: "100%",
    minHeight: 0,
    minWidth: 0,
    ...props
  });
};
const ScrollView = props => {
  let {
    isDisabled,
    ...otherProps
  } = props;
  return /*#__PURE__*/jsx(View, {
    "data-scrollable": isDisabled ? undefined : true,
    UNSAFE_className: css({
      '&[data-scrollable]': {
        overflowY: 'auto',
        WebkitOverflowScrolling: 'touch'
      }
    }),
    ...otherProps
  });
};

function ZapLogo() {
  return /*#__PURE__*/jsx("svg", {
    viewBox: "0 0 24 24",
    fill: tokenSchema.color.foreground.neutral,
    className: css({
      flexShrink: 0,
      height: tokenSchema.size.scale[250],
      width: tokenSchema.size.scale[250],
      [breakpointQueries.below.tablet]: {
        height: tokenSchema.size.icon.regular,
        width: tokenSchema.size.icon.regular
      }
    }),
    children: /*#__PURE__*/jsx("path", {
      d: "M13.3982 1.08274C13.8054 1.25951 14.0473 1.68358 13.9923 2.12407L13.1328 9.00003H21C21.388 9.00003 21.741 9.22449 21.9056 9.57588C22.0702 9.92726 22.0166 10.3421 21.7682 10.6402L11.7682 22.6402C11.484 22.9812 11.009 23.0941 10.6018 22.9173C10.1946 22.7405 9.95267 22.3165 10.0077 21.876L10.8672 15H3.00002C2.612 15 2.25901 14.7756 2.09443 14.4242C1.92985 14.0728 1.9834 13.6579 2.2318 13.3598L12.2318 1.35986C12.516 1.01882 12.991 0.905971 13.3982 1.08274Z"
    })
  });
}

// Config context
// -----------------------------------------------------------------------------
const ConfigContext = /*#__PURE__*/createContext(null);
function useConfig() {
  const config = useContext(ConfigContext);
  if (!config) {
    throw new Error('ConfigContext.Provider not found');
  }
  return config;
}

// Meta context
// -----------------------------------------------------------------------------
const AppStateContext = /*#__PURE__*/createContext({
  basePath: '/keystatic'
});
function useAppState() {
  const appState = useContext(AppStateContext);
  if (!appState) {
    throw new Error('AppStateContext.Provider not found');
  }
  return appState;
}

// Page context
// -----------------------------------------------------------------------------
const ContentPanelContext = /*#__PURE__*/createContext('mobile');
const ContentPanelProvider = ContentPanelContext.Provider;
function useContentPanelSize() {
  return useContext(ContentPanelContext);
}
function useContentPanelQuery(options) {
  const sizes = ['mobile', 'tablet', 'desktop', 'wide'];
  const size = useContentPanelSize();
  const startIndex = 'above' in options ? sizes.indexOf(options.above) + 1 : 0;
  const endIndex = 'below' in options ? sizes.indexOf(options.below) - 1 : sizes.length - 1;
  const range = sizes.slice(startIndex, endIndex + 1);
  return range.includes(size);
}

/** @private only used to initialize context */
function useContentPanelState(ref) {
  let [contentSize, setContentSize] = useState('mobile');
  const onResize = () => {
    setContentSize(size => {
      let contentPane = ref.current;
      if (!contentPane) {
        return size;
      }
      if (contentPane.offsetWidth >= breakpoints.wide) {
        return 'wide';
      }
      if (contentPane.offsetWidth >= breakpoints.desktop) {
        return 'desktop';
      }
      if (contentPane.offsetWidth >= breakpoints.tablet) {
        return 'tablet';
      }
      return 'mobile';
    });
  };
  useResizeObserver({
    ref,
    onResize
  });
  return contentSize;
}

const SidebarContext = /*#__PURE__*/createContext(null);
function useSidebar() {
  let context = useContext(SidebarContext);
  if (!context) {
    throw new Error('useSidebar must be within a SidebarProvider');
  }
  return context;
}
const breakpointNames = typedKeys(breakpoints);
function SidebarProvider(props) {
  const matchedBreakpoints = useBreakpoint();
  const state = useOverlayTriggerState({
    defaultOpen: matchedBreakpoints.includes('desktop')
  });
  let breakpointIndex = breakpointNames.indexOf(matchedBreakpoints[0]);
  let previousIndex = usePrevious(breakpointIndex) || 0;
  useUpdateEffect(() => {
    let larger = previousIndex < breakpointIndex;
    if (larger && breakpointIndex >= 2) {
      state.open();
    } else if (breakpointIndex < 2) {
      state.close();
    }
  }, [matchedBreakpoints]);
  return /*#__PURE__*/jsx(SidebarContext.Provider, {
    value: state,
    children: props.children
  });
}
function SidebarPanel(props) {
  return /*#__PURE__*/jsx(Flex, {
    backgroundColor: "surface",
    direction: "column",
    height: "100%",
    children: /*#__PURE__*/jsx(SidebarNav, {
      ...props
    })
  });
}
function SidebarHeader() {
  let config = useConfig();
  let text = 'Keystatic';
  if (isCloudConfig(config)) {
    text = config.cloud.project;
  }
  if (isGitHubConfig(config)) {
    text = serializeRepoConfig(config.storage.repo);
  }
  return /*#__PURE__*/jsxs(Flex, {
    alignItems: "center",
    borderBottom: "muted",
    gap: "regular",
    height: "element.large",
    paddingX: "xlarge",
    children: [/*#__PURE__*/jsx(ZapLogo, {}), /*#__PURE__*/jsx(Text, {
      color: "neutralEmphasis",
      weight: "semibold",
      children: text
    })]
  });
}
function SidebarDialog(props) {
  const state = useSidebar();
  const router = useRouter();

  // close the sidebar when the route changes
  useUpdateEffect(() => {
    state.close();
  }, [router.href]);
  let dialogRef = useRef(null);
  let {
    modalProps,
    underlayProps
  } = useModalOverlay({
    isDismissable: true
  }, state, dialogRef);
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(Blanket, {
      ...underlayProps,
      isOpen: state.isOpen,
      zIndex: 10
    }), /*#__PURE__*/jsxs("div", {
      "data-visible": state.isOpen,
      id: SIDE_PANEL_ID,
      ref: dialogRef,
      ...modalProps,
      // styles
      className: css({
        backgroundColor: tokenSchema.color.background.surface,
        boxShadow: `${tokenSchema.size.shadow.large} ${tokenSchema.color.shadow.regular}`,
        display: 'flex',
        flexDirection: 'column',
        inset: 0,
        insetInlineEnd: 'auto',
        // ensure that there's always enough of gutter for the user to press
        // and exit the sidebar
        maxWidth: `calc(100% - ${tokenSchema.size.element.medium})`,
        minWidth: tokenSchema.size.scale[3000],
        outline: 0,
        pointerEvents: 'none',
        position: 'fixed',
        transform: 'translateX(-100%)',
        visibility: 'hidden',
        zIndex: 10,
        // exit animation
        transition: [transition('transform', {
          easing: 'easeIn',
          duration: 'short'
          // delay: 'short',
        }), transition('visibility', {
          delay: 'regular',
          duration: 0,
          easing: 'linear'
        })].join(', '),
        '&[data-visible=true]': {
          transform: 'translateX(0)',
          // enter animation
          transition: transition('transform', {
            easing: 'easeOut'
          }),
          pointerEvents: 'auto',
          visibility: 'visible'
        }
      }),
      children: [/*#__PURE__*/jsx(SidebarHeader, {}), /*#__PURE__*/jsx(SidebarNav, {
        ...props
      }), /*#__PURE__*/jsx(DismissButton, {
        onDismiss: state.close
      })]
    })]
  });
}
function SidebarNav(props) {
  let config = useConfig();
  const stringFormatter = useLocalizedStringFormatter(l10nMessages);
  const router = useRouter();
  const isCurrent = (href, {
    exact = false
  } = {}) => {
    if (exact) {
      return href === router.href ? 'page' : undefined;
    }
    return href === router.href || router.href.startsWith(`${href}/`) ? 'page' : undefined;
  };
  const collectionsArray = Object.entries(config.collections || {});
  const singletonsArray = Object.entries(config.singletons || {});
  const changedData = useChanged();
  return /*#__PURE__*/jsx("div", {
    className: css({
      flex: 1,
      overflowY: 'auto',
      paddingBlock: tokenSchema.size.space.large,
      paddingInlineEnd: tokenSchema.size.space.large,
      WebkitOverflowScrolling: 'touch'
    }),
    children: /*#__PURE__*/jsxs(NavList, {
      children: [/*#__PURE__*/jsx(NavItem, {
        href: props.hrefBase,
        "aria-current": isCurrent(props.hrefBase, {
          exact: true
        }),
        children: stringFormatter.format('dashboard')
      }), collectionsArray.length !== 0 && /*#__PURE__*/jsx(NavGroup, {
        title: stringFormatter.format('collections'),
        children: collectionsArray.map(([key, collection]) => {
          const href = `${props.hrefBase}/collection/${encodeURIComponent(key)}`;
          const changes = changedData.collections.get(key);
          const allChangesCount = changes ? changes.changed.size + changes.added.size + changes.removed.size : 0;
          return /*#__PURE__*/jsxs(NavItem, {
            href: href,
            "aria-current": isCurrent(href),
            children: [/*#__PURE__*/jsx(Text, {
              truncate: true,
              title: collection.label,
              children: collection.label
            }), !!allChangesCount && /*#__PURE__*/jsxs(Badge, {
              tone: "accent",
              marginStart: "auto",
              children: [/*#__PURE__*/jsx(Text, {
                children: allChangesCount
              }), /*#__PURE__*/jsx(Text, {
                visuallyHidden: true,
                children: pluralize(allChangesCount, {
                  singular: 'change',
                  plural: 'changes',
                  inclusive: false
                })
              })]
            })]
          }, key);
        })
      }), singletonsArray.length !== 0 && /*#__PURE__*/jsx(NavGroup, {
        title: stringFormatter.format('singletons'),
        children: singletonsArray.map(([key, collection]) => {
          const href = `${props.hrefBase}/singleton/${key}`;
          return /*#__PURE__*/jsxs(NavItem, {
            href: href,
            "aria-current": isCurrent(href),
            children: [/*#__PURE__*/jsx(Text, {
              truncate: true,
              title: collection.label,
              children: collection.label
            }), changedData.singletons.has(key) && /*#__PURE__*/jsx(Box, {
              backgroundColor: "accentEmphasis",
              height: "scale.75",
              width: "scale.75",
              borderRadius: "full",
              marginStart: "auto",
              children: /*#__PURE__*/jsx(Text, {
                visuallyHidden: true,
                children: "Changed"
              })
            })]
          }, key);
        })
      })]
    })
  });
}

const PageContext = /*#__PURE__*/createContext({
  containerWidth: 'medium'
});
const PageRoot = ({
  children,
  containerWidth = 'medium'
}) => {
  return /*#__PURE__*/jsx(PageContext.Provider, {
    value: {
      containerWidth
    },
    children: /*#__PURE__*/jsx(Flex, {
      elementType: "main",
      direction: "column",
      id: MAIN_PANEL_ID,
      flex: true,
      height: "100%"
      // fix flexbox issues
      ,
      minHeight: 0,
      minWidth: 0,
      children: children
    })
  });
};
const PageHeader = ({
  children
}) => {
  const sidebarState = useSidebar();
  const menuButtonRef = useRef(null);
  const {
    direction
  } = useLocale();
  let icon = sidebarState.isOpen ? panelLeftCloseIcon : panelLeftOpenIcon;
  if (direction === 'rtl') {
    icon = sidebarState.isOpen ? panelRightCloseIcon : panelRightOpenIcon;
  }
  return /*#__PURE__*/jsx(Box, {
    borderBottom: "muted",
    elementType: "header",
    height: {
      mobile: 'element.large',
      tablet: 'element.xlarge'
    },
    flexShrink: 0,
    children: /*#__PURE__*/jsx(Box, {
      minHeight: 0,
      minWidth: 0,
      paddingX: {
        mobile: 'medium',
        tablet: 'xlarge',
        desktop: 'xxlarge'
      },
      children: /*#__PURE__*/jsxs(Flex, {
        alignItems: "center",
        gap: {
          mobile: 'small',
          tablet: 'regular'
        },
        height: {
          mobile: 'element.large',
          tablet: 'element.xlarge'
        },
        children: [/*#__PURE__*/jsx(ActionButton, {
          prominence: "low",
          "aria-label": "Open app navigation",
          "aria-pressed": sidebarState.isOpen,
          isHidden: sidebarState.isOpen ? {
            above: 'tablet'
          } : undefined,
          onPress: sidebarState.toggle,
          ref: menuButtonRef,
          UNSAFE_className: css({
            marginInlineStart: `calc(${tokenSchema.size.space.regular} * -1)`
          }),
          children: /*#__PURE__*/jsx(Icon, {
            src: icon
          })
        }), children]
      })
    })
  });
};
const PageBody = ({
  children,
  isScrollable
}) => {
  return /*#__PURE__*/jsx(ScrollView, {
    isDisabled: !isScrollable,
    children: /*#__PURE__*/jsx(PageContainer
    // padding on the container so descendants can use sticky positioning
    // with simple relative offsets
    , {
      paddingY: "xxlarge",
      children: children
    })
  });
};
const PageContainer = props => {
  const {
    containerWidth
  } = useContext(PageContext);
  const maxWidth = containerWidth === 'none' ? undefined : `container.${containerWidth}`;
  return /*#__PURE__*/jsx(Box, {
    minHeight: 0,
    minWidth: 0,
    maxWidth: maxWidth
    // marginX="auto"
    ,
    paddingX: {
      mobile: 'medium',
      tablet: 'xlarge',
      desktop: 'xxlarge'
    },
    ...props
  });
};

class NotFoundError extends Error {
  constructor() {
    super('Not found');
    this.name = 'NotFoundError';
  }
}
function isNotFoundError(err) {
  return typeof err === 'object' && err !== null && err instanceof NotFoundError;
}
function notFound() {
  throw new NotFoundError();
}
class NotFoundErrorBoundaryInner extends React__default.Component {
  constructor(props) {
    super(props);
    this.state = {
      notFound: false,
      lastHref: props.href
    };
  }
  static getDerivedStateFromError(err) {
    if (isNotFoundError(err)) {
      return {
        notFound: true
      };
    }
    throw err;
  }
  static getDerivedStateFromProps(props, state) {
    if (props.href !== state.lastHref && state.notFound) {
      return {
        notFound: false,
        lastHref: props.href
      };
    }
    return {
      notFound: state.notFound,
      lastHref: props.href
    };
  }
  render() {
    if (this.state.notFound) return this.props.fallback;
    return this.props.children;
  }
}
function NotFoundBoundary(props) {
  const router = useRouter();
  return /*#__PURE__*/jsx(NotFoundErrorBoundaryInner, {
    ...props,
    href: router.href
  });
}

function CollectionPage(props) {
  var _config$collections;
  const {
    collection,
    config
  } = props;
  const containerWidth = 'none'; // TODO: use a "large" when we have more columns
  const collectionConfig = (_config$collections = config.collections) === null || _config$collections === void 0 ? void 0 : _config$collections[collection];
  if (!collectionConfig) notFound();
  const [searchTerm, setSearchTerm] = useState('');
  let debouncedSearchTerm = useDebouncedValue(searchTerm, 300);
  return /*#__PURE__*/jsxs(PageRoot, {
    containerWidth: containerWidth,
    children: [/*#__PURE__*/jsx(CollectionPageHeader, {
      collectionLabel: collectionConfig.label,
      createHref: `${props.basePath}/collection/${encodeURIComponent(props.collection)}/create`,
      searchTerm: searchTerm,
      onSearchTermChange: setSearchTerm
    }), /*#__PURE__*/jsx(CollectionPageContent, {
      searchTerm: debouncedSearchTerm,
      ...props
    })]
  });
}
function CollectionPageHeader(props) {
  const {
    collectionLabel,
    createHref
  } = props;
  const stringFormatter = useLocalizedStringFormatter(l10nMessages);
  const isAboveMobile = useMediaQuery(breakpointQueries.above.mobile);
  const [searchVisible, setSearchVisible] = useState(isAboveMobile);
  const searchRef = useRef(null);
  useEffect(() => {
    setSearchVisible(isAboveMobile);
  }, [isAboveMobile]);
  return /*#__PURE__*/jsxs(PageHeader, {
    children: [/*#__PURE__*/jsx(Heading, {
      elementType: "h1",
      id: "page-title",
      size: "small",
      flex: true,
      minWidth: 0,
      children: collectionLabel
    }), /*#__PURE__*/jsx("div", {
      role: "search",
      style: {
        display: searchVisible ? 'block' : 'none'
      },
      children: /*#__PURE__*/jsx(SearchField, {
        ref: searchRef,
        "aria-label": stringFormatter.format('search') // TODO: l10n "Search {collection}"?
        ,
        onChange: props.onSearchTermChange,
        onClear: () => {
          props.onSearchTermChange('');
          if (!isAboveMobile) {
            // the timeout ensures that the "add" button isn't pressed
            setTimeout(() => {
              setSearchVisible(false);
            }, 250);
          }
        },
        onBlur: () => {
          if (!isAboveMobile && props.searchTerm === '') {
            setSearchVisible(false);
          }
        },
        placeholder: stringFormatter.format('search'),
        value: props.searchTerm,
        width: "scale.2400"
      })
    }), /*#__PURE__*/jsx(ActionButton, {
      "aria-label": "show search",
      isHidden: searchVisible || {
        above: 'mobile'
      },
      onPress: () => {
        setSearchVisible(true);
        // NOTE: this hack is to force the search field to focus, and invoke
        // the software keyboard on mobile safari
        let tempInput = document.createElement('input');
        tempInput.style.position = 'absolute';
        tempInput.style.opacity = '0';
        document.body.appendChild(tempInput);
        tempInput.focus();
        setTimeout(() => {
          var _searchRef$current;
          (_searchRef$current = searchRef.current) === null || _searchRef$current === void 0 || _searchRef$current.focus();
          tempInput.remove();
        }, 0);
      },
      children: /*#__PURE__*/jsx(Icon, {
        src: searchIcon
      })
    }), /*#__PURE__*/jsx(Button, {
      marginStart: "auto",
      prominence: "high",
      href: createHref,
      isHidden: searchVisible ? {
        below: 'tablet'
      } : undefined,
      children: stringFormatter.format('add')
    })]
  });
}
function CollectionPageContent(props) {
  const trees = useTree();
  const tree = trees.merged.kind === 'loaded' ? trees.merged.data.current.entries.get(getCollectionPath(props.config, props.collection)) : null;
  if (trees.merged.kind === 'error') {
    return /*#__PURE__*/jsx(EmptyState, {
      icon: alertCircleIcon,
      title: "Unable to load collection",
      message: trees.merged.error.message,
      actions: /*#__PURE__*/jsx(Button, {
        tone: "accent",
        href: props.basePath,
        children: "Dashboard"
      })
    });
  }
  if (trees.merged.kind === 'loading') {
    return /*#__PURE__*/jsx(EmptyState, {
      children: /*#__PURE__*/jsx(ProgressCircle, {
        "aria-label": "Loading Entries",
        isIndeterminate: true,
        size: "large"
      })
    });
  }
  if (!tree) {
    return /*#__PURE__*/jsx(EmptyState, {
      icon: listXIcon,
      title: "Empty collection",
      message: /*#__PURE__*/jsxs(Fragment, {
        children: ["There aren't any entries yet.", ' ', /*#__PURE__*/jsx(TextLink, {
          href: `${props.basePath}/collection/${encodeURIComponent(props.collection)}/create`,
          children: "Create the first entry"
        }), ' ', "to see it here."]
      })
    });
  }
  return /*#__PURE__*/jsx(CollectionTable, {
    ...props,
    trees: trees.merged.data
  });
}
function CollectionTable(props) {
  let {
    searchTerm
  } = props;
  let isLocalMode = isLocalConfig(props.config);
  let router = useRouter();
  let [sortDescriptor, setSortDescriptor] = useState({
    column: 'name',
    direction: 'ascending'
  });
  const entriesWithStatus = useMemo(() => {
    const defaultEntries = new Map(getEntriesInCollectionWithTreeKey(props.config, props.collection, props.trees.default.tree).map(x => [x.slug, x.key]));
    return getEntriesInCollectionWithTreeKey(props.config, props.collection, props.trees.current.tree).map(entry => {
      return {
        name: entry.slug,
        status: defaultEntries.has(entry.slug) ? defaultEntries.get(entry.slug) === entry.key ? 'Unchanged' : 'Changed' : 'Added'
      };
    });
  }, [props.collection, props.config, props.trees]);
  const filteredItems = useMemo(() => {
    return entriesWithStatus.filter(item => item.name.toLowerCase().includes(searchTerm.toLowerCase()));
  }, [entriesWithStatus, searchTerm]);
  const sortedItems = useMemo(() => {
    return [...filteredItems].sort(sortByDescriptor(sortDescriptor));
  }, [filteredItems, sortDescriptor]);
  const columns = useMemo(() => {
    return isLocalMode ? [{
      name: 'Name',
      key: 'name'
    }] : [{
      name: 'Name',
      key: 'name'
    }, {
      name: 'Status',
      key: 'status',
      minWidth: 140,
      width: '20%'
    }];
  }, [isLocalMode]);
  return /*#__PURE__*/jsxs(TableView, {
    "aria-labelledby": "page-title",
    selectionMode: "none",
    onSortChange: setSortDescriptor,
    sortDescriptor: sortDescriptor,
    density: isLocalMode ? 'spacious' : 'regular',
    overflowMode: "truncate",
    prominence: "low",
    onRowAction: key => {
      router.push(getItemPath(props.basePath, props.collection, key));
    },
    renderEmptyState: () => /*#__PURE__*/jsx(EmptyState, {
      icon: searchXIcon,
      title: "No results",
      message: `No items matching "${searchTerm}" were found.`
    }),
    flex: true,
    marginTop: {
      tablet: 'large'
    },
    marginBottom: {
      mobile: 'regular',
      tablet: 'xlarge'
    },
    UNSAFE_className: css({
      marginInline: tokenSchema.size.space.regular,
      [breakpointQueries.above.mobile]: {
        marginInline: `calc(${tokenSchema.size.space.xlarge} - ${tokenSchema.size.space.medium})`
      },
      [breakpointQueries.above.tablet]: {
        marginInline: `calc(${tokenSchema.size.space.xxlarge} - ${tokenSchema.size.space.medium})`
      },
      '[role=rowheader]': {
        cursor: 'pointer'
      }
    }),
    children: [/*#__PURE__*/jsx(TableHeader, {
      columns: columns,
      children: ({
        name,
        key,
        ...options
      }) => /*#__PURE__*/jsx(Column, {
        isRowHeader: true,
        allowsSorting: true,
        ...options,
        children: name
      }, key)
    }), /*#__PURE__*/jsx(TableBody, {
      items: sortedItems,
      children: item => isLocalMode ? /*#__PURE__*/jsx(Row, {
        children: /*#__PURE__*/jsx(Cell, {
          textValue: item.name,
          children: /*#__PURE__*/jsx(Text, {
            weight: "medium",
            children: item.name
          })
        })
      }, item.name) : /*#__PURE__*/jsxs(Row, {
        children: [/*#__PURE__*/jsx(Cell, {
          textValue: item.name,
          children: /*#__PURE__*/jsx(Text, {
            weight: "medium",
            children: item.name
          })
        }), /*#__PURE__*/jsx(Cell, {
          textValue: item.status,
          children: /*#__PURE__*/jsx(StatusLight, {
            tone: statusTones[item.status],
            children: item.status
          })
        })]
      }, item.name)
    })]
  });
}
function getItemPath(basePath, collection, key) {
  return `${basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(key)}`;
}
function useDebouncedValue(value, delay = 300) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay);
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);
  return debouncedValue;
}
const statusTones = {
  Added: 'positive',
  Changed: 'accent',
  Unchanged: 'neutral'
};

function castToMemoizedInfoForSchema(val) {
  return val;
}
function getOrInsert(map, key, val) {
  if (!map.has(key)) {
    map.set(key, val(key));
  }
  return map.get(key);
}
function createGetPreviewProps(rootSchema, rootOnChange, getChildFieldElement) {
  const memoizedInfoForSchema = castToMemoizedInfoForSchema({
    form(schema, onChange) {
      return newVal => onChange(() => newVal);
    },
    array(schema, onChange) {
      return {
        rawOnChange: onChange,
        inner: new Map(),
        onChange(updater) {
          onChange(value => updateValue(schema, value, updater));
        }
      };
    },
    child() {},
    conditional(schema, onChange) {
      return {
        onChange: (discriminant, value) => onChange(val => updateValue(schema, val, {
          discriminant,
          value
        })),
        onChangeForValue: cb => onChange(val => ({
          discriminant: val.discriminant,
          value: cb(val.value)
        }))
      };
    },
    object(schema, onChange) {
      return {
        onChange: updater => {
          onChange(value => updateValue(schema, value, updater));
        },
        innerOnChanges: Object.fromEntries(Object.keys(schema.fields).map(key => {
          return [key, newVal => {
            onChange(val => ({
              ...val,
              [key]: newVal(val[key])
            }));
          }];
        }))
      };
    }
  });
  const previewPropsFactories = {
    form(schema, value, onChange) {
      return {
        value: value,
        onChange,
        schema: schema
      };
    },
    child(schema, value, onChange, path) {
      return {
        element: getChildFieldElement(path),
        schema: schema
      };
    },
    object(schema, value, memoized, path, getInnerProp) {
      const fields = {};
      for (const key of Object.keys(schema.fields)) {
        fields[key] = getInnerProp(schema.fields[key], value[key], memoized.innerOnChanges[key], key);
      }
      const previewProps = {
        fields,
        onChange: memoized.onChange,
        schema: schema
      };
      return previewProps;
    },
    array(schema, value, memoized, path, getInnerProp) {
      const arrayValue = value;
      const keys = getKeysForArrayValue(arrayValue);
      const unusedKeys = new Set(getKeysForArrayValue(value));
      const props = {
        elements: arrayValue.map((val, i) => {
          const key = keys[i];
          unusedKeys.delete(key);
          const element = getOrInsert(memoized.inner, key, () => {
            const onChange = val => {
              memoized.rawOnChange(prev => {
                const keys = getKeysForArrayValue(prev);
                const index = keys.indexOf(key);
                const newValue = [...prev];
                newValue[index] = val(newValue[index]);
                setKeysForArrayValue(newValue, keys);
                return newValue;
              });
            };
            const element = getInnerProp(schema.element, val, onChange, key);
            return {
              element,
              elementWithKey: {
                ...element,
                key
              },
              onChange
            };
          });
          const currentInnerProp = getInnerProp(schema.element, val, element.onChange, key);
          if (element.element !== currentInnerProp) {
            element.element = currentInnerProp;
            element.elementWithKey = {
              ...currentInnerProp,
              key
            };
          }
          return element.elementWithKey;
        }),
        schema: schema,
        onChange: memoized.onChange
      };
      for (const key of unusedKeys) {
        memoized.inner.delete(key);
      }
      return props;
    },
    conditional(schema, value, memoized, path, getInnerProp) {
      const props = {
        discriminant: value.discriminant,
        onChange: memoized.onChange,
        value: getInnerProp(schema.values[value.discriminant.toString()], value.value, memoized.onChangeForValue, 'value'),
        schema: schema
      };
      return props;
    }
  };
  function getPreviewPropsForProp(schema, value, memoedThing, path, getInnerProp) {
    return previewPropsFactories[schema.kind](schema, value, memoedThing, path, getInnerProp);
  }
  function getInitialMemoState(schema, value, onChange, path) {
    const innerState = new Map();
    const memoizedInfo = memoizedInfoForSchema[schema.kind](schema, onChange);
    const state = {
      value,
      inner: innerState,
      props: getPreviewPropsForProp(schema, value, memoizedInfo, path, (schema, value, onChange, key) => {
        const state = getInitialMemoState(schema, value, onChange, path.concat(key));
        innerState.set(key, state);
        return state.props;
      }),
      schema: schema,
      cached: memoizedInfo
    };
    return state;
  }
  function getUpToDateProps(schema, value, onChange, memoState, path) {
    if (memoState.schema !== schema) {
      Object.assign(memoState, getInitialMemoState(schema, value, onChange, path));
      return memoState.props;
    }
    if (memoState.value === value) {
      return memoState.props;
    }
    memoState.value = value;
    const unusedKeys = new Set(memoState.inner.keys());
    memoState.props = getPreviewPropsForProp(schema, value, memoState.cached, path, (schema, value, onChange, innerMemoStateKey) => {
      unusedKeys.delete(innerMemoStateKey);
      if (!memoState.inner.has(innerMemoStateKey)) {
        const innerState = getInitialMemoState(schema, value, onChange, path.concat(innerMemoStateKey));
        memoState.inner.set(innerMemoStateKey, innerState);
        return innerState.props;
      }
      return getUpToDateProps(schema, value, onChange, memoState.inner.get(innerMemoStateKey), path.concat(innerMemoStateKey));
    });
    for (const key of unusedKeys) {
      memoState.inner.delete(key);
    }
    return memoState.props;
  }
  let memoState;
  return value => {
    if (memoState === undefined) {
      memoState = getInitialMemoState(rootSchema, value, rootOnChange, []);
      return memoState.props;
    }
    return getUpToDateProps(rootSchema, value, rootOnChange, memoState, []);
  };
}

function clientSideValidateProp(schema, value, slugField) {
  try {
    validateValueWithSchema(schema, value, slugField);
    return true;
  } catch (error) {
    console.warn(toFormattedFormDataError(error));
    return false;
  }
}
function validateValueWithSchema(schema, value, slugField, path = []) {
  switch (schema.kind) {
    case 'child':
      {
        return;
      }
    case 'form':
      {
        try {
          if (slugField && path[path.length - 1] === (slugField === null || slugField === void 0 ? void 0 : slugField.field)) {
            schema.validate(value, {
              slugField: {
                slugs: slugField.slugs,
                glob: slugField.glob
              }
            });
            return;
          }
          schema.validate(value, undefined);
        } catch (err) {
          throw new PropValidationError(err, path, schema);
        }
        return;
      }
    case 'conditional':
      {
        schema.discriminant.validate(value.discriminant);
        validateValueWithSchema(schema.values[value.discriminant], value.value, undefined, path.concat('value'));
        return;
      }
    case 'object':
      {
        const errors = [];
        for (const [key, childProp] of Object.entries(schema.fields)) {
          try {
            validateValueWithSchema(childProp, value[key], key === (slugField === null || slugField === void 0 ? void 0 : slugField.field) ? slugField : undefined, path.concat(key));
          } catch (err) {
            errors.push(err);
          }
        }
        if (errors.length > 0) {
          throw new AggregateError(errors);
        }
        return;
      }
    case 'array':
      {
        let slugInfo;
        if (schema.slugField !== undefined && schema.element.kind === 'object') {
          const innerSchema = schema.element.fields;
          const {
            slugField
          } = schema;
          slugInfo = {
            slugField,
            slugs: value.map(val => getSlugFromState({
              schema: innerSchema,
              slugField
            }, val))
          };
        }
        const errors = [];
        const val = value;
        const error = validateArrayLength(schema, value, path);
        if (error !== undefined) {
          errors.push(error);
        }
        for (const [idx, innerVal] of val.entries()) {
          try {
            validateValueWithSchema(schema.element, innerVal, slugInfo === undefined ? undefined : {
              field: slugInfo.slugField,
              slugs: new Set(slugInfo.slugs.filter((_, i) => idx !== i)),
              glob: '*'
            }, path.concat(idx));
          } catch (err) {
            errors.push(err);
          }
        }
        if (errors.length > 0) {
          throw new AggregateError(errors);
        }
        return;
      }
  }
}

css({
  marginBlock: '0.75em',
  '&:first-child': {
    marginBlockStart: 0
  },
  '&:last-child': {
    marginBlockEnd: 0
  }
});
const ForceValidationContext = /*#__PURE__*/React__default.createContext(false);
ForceValidationContext.Provider;
function useEventCallback(callback) {
  const callbackRef = useRef(callback);
  const cb = useCallback((...args) => {
    return callbackRef.current(...args);
  }, []);
  useEffect(() => {
    callbackRef.current = callback;
  });
  return cb;
}

function BranchPicker() {
  const {
    allBranches,
    currentBranch,
    defaultBranch
  } = useContext(BranchInfoContext);
  const stringFormatter = useLocalizedStringFormatter(l10nMessages);
  const router = useRouter();
  const items = useMemo(() => {
    let defaultItems = allBranches.map(name => ({
      id: name,
      name
    }));
    if (defaultBranch) {
      return [{
        id: defaultBranch,
        name: defaultBranch,
        description: stringFormatter.format('defaultBranch')
      }, ...defaultItems.filter(i => i.name !== defaultBranch)];
    }
    return defaultItems;
  }, [allBranches, defaultBranch, stringFormatter]);
  return /*#__PURE__*/jsx(Picker, {
    "aria-label": stringFormatter.format('currentBranch'),
    items: items,
    selectedKey: currentBranch,
    onSelectionChange: key => {
      if (typeof key === 'string') {
        router.push(router.href.replace(/\/branch\/[^/]+/, '/branch/' + encodeURIComponent(key)));
      }
    }
    // styles
    ,
    prominence: "low",
    width: "auto",
    menuWidth: 288,
    UNSAFE_className: css({
      button: {
        contain: 'layout'
      }
    }),
    children: item => /*#__PURE__*/jsxs(Item, {
      textValue: item.name,
      children: [/*#__PURE__*/jsx(Icon, {
        src: gitBranchIcon
      }), /*#__PURE__*/jsx(Text, {
        truncate: true,
        children: item.name
      }), 'description' in item && /*#__PURE__*/jsx(Text, {
        slot: "description",
        children: item.description
      })]
    }, item.id)
  });
}
function CreateBranchDialog(props) {
  const branchInfo = useContext(BranchInfoContext);
  const isDefaultBranch = branchInfo.defaultBranch === branchInfo.currentBranch;
  const stringFormatter = useLocalizedStringFormatter(l10nMessages);
  const [{
    error,
    fetching
  }, createBranch] = useCreateBranchMutation();
  const repositoryId = useRepositoryId();
  const createBranchSubmitButtonId = 'create-branch-submit-button';
  const [branchName, setBranchName] = useState('');
  const [baseBranch, setBaseBranch] = useState(branchInfo.defaultBranch);
  return /*#__PURE__*/jsx(Dialog, {
    size: "small",
    children: /*#__PURE__*/jsxs("form", {
      style: {
        display: 'contents'
      },
      onSubmit: async event => {
        var _result$data;
        if (event.target !== event.currentTarget) return;
        event.preventDefault();
        const name = `refs/heads/${branchName}`;
        const result = await createBranch({
          input: {
            name,
            oid: branchInfo.branchNameToBaseCommit.get(baseBranch),
            repositoryId
          }
        });
        if ((_result$data = result.data) !== null && _result$data !== void 0 && (_result$data = _result$data.createRef) !== null && _result$data !== void 0 && _result$data.__typename) {
          props.onCreate(branchName);
        }
      },
      children: [/*#__PURE__*/jsx(Heading, {
        children: stringFormatter.format('newBranch')
      }), /*#__PURE__*/jsx(Content, {
        children: isDefaultBranch ? /*#__PURE__*/jsx(TextField, {
          value: branchName,
          onChange: setBranchName,
          label: stringFormatter.format('branchName')
          // description="Your new branch will be based on the currently checked out branch, which is the default branch for this repository."
          ,
          autoFocus: true,
          errorMessage: error === null || error === void 0 ? void 0 : error.message
        }) : /*#__PURE__*/jsxs(Grid, {
          gap: "xlarge",
          children: [/*#__PURE__*/jsx(TextField, {
            label: stringFormatter.format('branchName'),
            value: branchName,
            onChange: setBranchName,
            autoFocus: true,
            errorMessage: error === null || error === void 0 ? void 0 : error.message
          }), /*#__PURE__*/jsxs(RadioGroup, {
            label: stringFormatter.format('basedOn'),
            value: baseBranch,
            onChange: setBaseBranch,
            children: [/*#__PURE__*/jsxs(Radio, {
              value: branchInfo.defaultBranch,
              children: [/*#__PURE__*/jsxs(Text, {
                children: [branchInfo.defaultBranch, /*#__PURE__*/jsx(Text, {
                  visuallyHidden: true,
                  children: "."
                })]
              }), /*#__PURE__*/jsx(Text, {
                slot: "description",
                children: stringFormatter.format('theDefaultBranchInYourRepository')
              })]
            }), /*#__PURE__*/jsxs(Radio, {
              value: branchInfo.currentBranch,
              children: [/*#__PURE__*/jsxs(Text, {
                children: [branchInfo.currentBranch, /*#__PURE__*/jsx(Text, {
                  visuallyHidden: true,
                  children: "."
                })]
              }), /*#__PURE__*/jsx(Text, {
                slot: "description",
                children: stringFormatter.format('theCurrentlyCheckedOutBranch')
              })]
            })]
          })]
        })
      }), /*#__PURE__*/jsx(Footer, {
        UNSAFE_style: {
          justifyContent: 'flex-end'
        },
        children: fetching && /*#__PURE__*/jsx(ProgressCircle, {
          "aria-labelledby": createBranchSubmitButtonId,
          isIndeterminate: true,
          size: "small"
        })
      }), /*#__PURE__*/jsxs(ButtonGroup, {
        children: [/*#__PURE__*/jsx(Button, {
          onPress: props.onDismiss,
          isDisabled: fetching,
          children: stringFormatter.format('cancel')
        }), /*#__PURE__*/jsx(Button, {
          isDisabled: fetching,
          prominence: "high",
          type: "submit",
          id: createBranchSubmitButtonId,
          children: stringFormatter.format('create')
        })]
      })]
    })
  });
}

// Data
// -----------------------------------------------------------------------------

function useCreateBranchMutation() {
  return useMutation(gql`
      mutation CreateBranch($input: CreateRefInput!) {
        createRef(input: $input) {
          __typename
          ref {
            ...Ref_base
          }
        }
      }
      ${Ref_base}
    `);
}

function AddToPathProvider(props) {
  const path = useContext(PathContext);
  return /*#__PURE__*/jsx(PathContext.Provider, {
    value: useMemo(() => path.concat(props.part), [path, props.part]),
    children: props.children
  });
}
const SlugFieldContext = /*#__PURE__*/createContext(undefined);
const SlugFieldProvider = SlugFieldContext.Provider;
const PathContext = /*#__PURE__*/createContext([]);
const PathContextProvider = PathContext.Provider;

function ObjectFieldInput({
  schema,
  autoFocus,
  fields,
  forceValidation
}) {
  const firstFocusable = autoFocus ? findFocusableObjectFieldKey(schema) : undefined;
  const inner = /*#__PURE__*/jsx(Flex, {
    gap: "xlarge",
    direction: "column",
    children: Object.entries(fields).map(([key, propVal]) => isNonChildFieldPreviewProps(propVal) && /*#__PURE__*/jsx(AddToPathProvider, {
      part: key,
      children: /*#__PURE__*/jsx(InnerFormValueContentFromPreviewProps, {
        forceValidation: forceValidation,
        autoFocus: key === firstFocusable,
        ...propVal
      })
    }, key))
  });
  const id = useId();
  if (!schema.label) {
    return inner;
  }
  const labelId = `${id}-label`;
  const descriptionId = `${id}-description`;
  return /*#__PURE__*/jsxs(Flex, {
    role: "group",
    gap: "medium",
    marginY: "large",
    "aria-labelledby": labelId,
    "aria-describedby": schema.description ? descriptionId : undefined,
    direction: "column",
    children: [/*#__PURE__*/jsx(Text, {
      color: "neutral",
      size: "medium",
      weight: "medium",
      id: labelId,
      children: schema.label
    }), !!schema.description && /*#__PURE__*/jsx(Text, {
      id: descriptionId,
      size: "regular",
      color: "neutralSecondary",
      children: schema.description
    }), inner]
  });
}
function findFocusableObjectFieldKey(schema) {
  for (const [key, innerProp] of Object.entries(schema.fields)) {
    const childFocusable = canFieldBeFocused(innerProp);
    if (childFocusable) {
      return key;
    }
  }
  return undefined;
}
function canFieldBeFocused(schema) {
  if (schema.kind === 'array' || schema.kind === 'conditional' || schema.kind === 'form') {
    return true;
  }
  if (schema.kind === 'child') {
    return false;
  }
  if (schema.kind === 'object') {
    for (const innerProp of Object.values(schema.fields)) {
      if (canFieldBeFocused(innerProp)) {
        return true;
      }
    }
    return false;
  }
  assertNever(schema);
}

function ConditionalFieldInput({
  schema,
  autoFocus,
  discriminant,
  onChange,
  value,
  forceValidation
}) {
  const schemaDiscriminant = schema.discriminant;
  return /*#__PURE__*/jsxs(Flex, {
    gap: "xlarge",
    direction: "column",
    children: [useMemo(() => /*#__PURE__*/jsx(AddToPathProvider, {
      part: "discriminant",
      children: /*#__PURE__*/jsx(schemaDiscriminant.Input, {
        autoFocus: !!autoFocus,
        value: discriminant,
        onChange: onChange,
        forceValidation: forceValidation
      })
    }), [autoFocus, schemaDiscriminant, discriminant, onChange, forceValidation]), isNonChildFieldPreviewProps(value) && /*#__PURE__*/jsx(AddToPathProvider, {
      part: "value",
      children: /*#__PURE__*/jsx(InnerFormValueContentFromPreviewProps, {
        forceValidation: forceValidation,
        ...value
      })
    })]
  });
}

const previewPropsToValueConverter = {
  child() {
    return null;
  },
  form(props) {
    return props.value;
  },
  array(props) {
    const values = props.elements.map(x => previewPropsToValue(x));
    setKeysForArrayValue(values, props.elements.map(x => x.key));
    return values;
  },
  conditional(props) {
    return {
      discriminant: props.discriminant,
      value: previewPropsToValue(props.value)
    };
  },
  object(props) {
    return Object.fromEntries(Object.entries(props.fields).map(([key, val]) => [key, previewPropsToValue(val)]));
  }
};
function previewPropsToValue(props) {
  return previewPropsToValueConverter[props.schema.kind](props);
}
const valueToUpdaters = {
  child() {
    return undefined;
  },
  form(value) {
    return value;
  },
  array(value, schema) {
    const keys = getKeysForArrayValue(value);
    return value.map((x, i) => ({
      key: keys[i],
      value: valueToUpdater(x, schema.element)
    }));
  },
  conditional(value, schema) {
    return {
      discriminant: value.discriminant,
      value: valueToUpdater(value.value, schema.values[value.discriminant.toString()])
    };
  },
  object(value, schema) {
    return Object.fromEntries(Object.entries(schema.fields).map(([key, schema]) => [key, valueToUpdater(value[key], schema)]));
  }
};
function valueToUpdater(value, schema) {
  return valueToUpdaters[schema.kind](value, schema);
}
function setValueToPreviewProps(value, props) {
  if (isKind(props, 'child')) {
    // child fields can't be updated through preview props, so we don't do anything here
    return;
  }
  if (isKind(props, 'form') || isKind(props, 'object') || isKind(props, 'array')) {
    props.onChange(valueToUpdater(value, props.schema));
    return;
  }
  if (isKind(props, 'conditional')) {
    const updater = valueToUpdater(value, props.schema);
    props.onChange(updater.discriminant, updater.value);
    return;
  }
  assertNever(props);
}

// this exists because for props.schema.kind === 'form', ts doesn't narrow props, only props.schema
function isKind(props, kind) {
  return props.schema.kind === kind;
}

function ArrayFieldInput(props) {
  const labelId = useId();
  const descriptionId = useId();
  const stringFormatter = useLocalizedStringFormatter(l10nMessages);
  const [modalState, setModalState] = useState({
    state: 'closed'
  });
  const onModalChange = useCallback(cb => {
    setModalState(state => {
      if (state.state === 'open') {
        return {
          state: 'open',
          forceValidation: state.forceValidation,
          value: cb(state.value),
          index: state.index
        };
      }
      return state;
    });
  }, [setModalState]);
  const formId = useId();
  const modalStateIndex = modalState.state === 'open' ? modalState.index : undefined;
  const slugInfo = useMemo(() => {
    if (props.schema.slugField === undefined || modalState.state !== 'open' || props.schema.element.kind !== 'object') {
      return;
    }
    const val = previewPropsToValue(props);
    const schema = props.schema.element.fields;
    const slugField = props.schema.slugField;
    const slugs = new Set(val.filter((x, i) => i !== modalStateIndex).map(x => getSlugFromState({
      schema,
      slugField
    }, x)));
    return {
      slugs,
      field: slugField,
      glob: '*'
    };
  }, [modalStateIndex, props, modalState.state]);
  return /*#__PURE__*/jsxs(Flex, {
    elementType: "section",
    gap: "medium",
    role: "group",
    "aria-labelledby": labelId,
    "aria-describedby": props.schema.description ? descriptionId : undefined,
    direction: "column",
    children: [/*#__PURE__*/jsx(FieldLabel, {
      elementType: "h3",
      id: labelId,
      children: props.schema.label
    }), props.schema.description && /*#__PURE__*/jsx(Text, {
      id: descriptionId,
      size: "small",
      color: "neutralSecondary",
      children: props.schema.description
    }), /*#__PURE__*/jsx(ActionButton, {
      autoFocus: props.autoFocus,
      onPress: () => {
        setModalState({
          state: 'open',
          value: getInitialPropsValue(props.schema.element),
          forceValidation: false,
          index: undefined
        });
      },
      alignSelf: "start",
      children: stringFormatter.format('add')
    }), /*#__PURE__*/jsx(ArrayFieldListView, {
      ...props,
      labelId: labelId,
      onOpenItem: idx => {
        setModalState({
          state: 'open',
          value: previewPropsToValue(props.elements[idx]),
          forceValidation: false,
          index: idx
        });
      }
    }), /*#__PURE__*/jsx(ArrayFieldValidationMessages, {
      ...props
    }), /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: () => {
        setModalState({
          state: 'closed'
        });
      },
      children: (() => {
        if (modalState.state !== 'open' || props.schema.element.kind === 'child') {
          return;
        }
        return /*#__PURE__*/jsxs(Dialog, {
          children: [/*#__PURE__*/jsx(Heading, {
            children: "Edit item"
          }), /*#__PURE__*/jsx(Content, {
            children: /*#__PURE__*/jsx(Flex, {
              id: formId,
              elementType: "form",
              onSubmit: event => {
                if (event.target !== event.currentTarget) return;
                event.preventDefault();
                if (modalState.state !== 'open') return;
                if (!clientSideValidateProp(props.schema.element, modalState.value, undefined)) {
                  setModalState(state => ({
                    ...state,
                    forceValidation: true
                  }));
                  return;
                }
                if (modalState.index === undefined) {
                  props.onChange([...props.elements.map(x => ({
                    key: x.key
                  })), {
                    key: undefined,
                    value: valueToUpdater(modalState.value, props.schema.element)
                  }]);
                } else {
                  setValueToPreviewProps(modalState.value, props.elements[modalState.index]);
                }
                setModalState({
                  state: 'closed'
                });
              },
              direction: "column",
              gap: "xxlarge",
              children: /*#__PURE__*/jsx(ArrayFieldItemModalContent, {
                onChange: onModalChange,
                schema: props.schema.element,
                value: modalState.value,
                slugField: slugInfo
              })
            })
          }), /*#__PURE__*/jsxs(ButtonGroup, {
            children: [/*#__PURE__*/jsx(Button, {
              onPress: () => {
                setModalState({
                  state: 'closed'
                });
              },
              children: stringFormatter.format('cancel')
            }), /*#__PURE__*/jsx(Button, {
              form: formId,
              prominence: "high",
              type: "submit",
              children: modalState.index === undefined ? stringFormatter.format('add') : 'Done'
            })]
          })]
        });
      })()
    })]
  });
}
function ArrayFieldValidationMessages(props) {
  var _props$schema$validat, _props$schema$validat2;
  return /*#__PURE__*/jsx(Fragment, {
    children: props.forceValidation && (((_props$schema$validat = props.schema.validation) === null || _props$schema$validat === void 0 || (_props$schema$validat = _props$schema$validat.length) === null || _props$schema$validat === void 0 ? void 0 : _props$schema$validat.min) !== undefined && props.elements.length < props.schema.validation.length.min ? /*#__PURE__*/jsxs(FieldMessage, {
      children: ["Must have at least ", props.schema.validation.length.min, " item", props.schema.validation.length.min === 1 ? '' : 's']
    }) : ((_props$schema$validat2 = props.schema.validation) === null || _props$schema$validat2 === void 0 || (_props$schema$validat2 = _props$schema$validat2.length) === null || _props$schema$validat2 === void 0 ? void 0 : _props$schema$validat2.max) !== undefined && props.elements.length > props.schema.validation.length.max ? /*#__PURE__*/jsxs(FieldMessage, {
      children: ["Must have at most ", props.schema.validation.length.max, " item", props.schema.validation.length.max === 1 ? '' : 's']
    }) : undefined)
  });
}
function ArrayFieldListView(props) {
  let onMove = (keys, target) => {
    const targetIndex = props.elements.findIndex(x => x.key === target.key);
    if (targetIndex === -1) return;
    const allKeys = props.elements.map(x => ({
      key: x.key
    }));
    const indexToMoveTo = target.dropPosition === 'before' ? targetIndex : targetIndex + 1;
    const indices = keys.map(key => allKeys.findIndex(x => x.key === key));
    props.onChange(move(allKeys, indices, indexToMoveTo));
  };
  const dragType = useMemo(() => Math.random().toString(36), []);
  let {
    dragAndDropHooks
  } = useDragAndDrop({
    getItems(keys) {
      // Use a drag type so the items can only be reordered within this list
      // and not dragged elsewhere.
      return [...keys].map(key => {
        key = JSON.stringify(key);
        return {
          [dragType]: key,
          'text/plain': key
        };
      });
    },
    getAllowedDropOperations() {
      return ['move', 'cancel'];
    },
    async onDrop(e) {
      if (e.target.type !== 'root' && e.target.dropPosition !== 'on') {
        let keys = [];
        for (let item of e.items) {
          if (item.kind === 'text') {
            let key;
            if (item.types.has(dragType)) {
              key = JSON.parse(await item.getText(dragType));
              keys.push(key);
            } else if (item.types.has('text/plain')) {
              // Fallback for Chrome Android case: https://bugs.chromium.org/p/chromium/issues/detail?id=1293803
              // Multiple drag items are contained in a single string so we need to split them out
              key = await item.getText('text/plain');
              keys = key.split('\n').map(val => val.replaceAll('"', ''));
            }
          }
        }
        onMove(keys, e.target);
      }
    },
    getDropOperation(target) {
      if (target.type === 'root' || target.dropPosition === 'on') {
        return 'cancel';
      }
      return 'move';
    }
  });
  const onRemoveKey = useEventCallback(key => {
    props.onChange(props.elements.map(x => ({
      key: x.key
    })).filter(val => val.key !== key));
  });
  const stringFormatter = useLocalizedStringFormatter(l10nMessages);
  return /*#__PURE__*/jsx(ListView, {
    "aria-labelledby": props.labelId,
    items: props.elements,
    dragAndDropHooks: dragAndDropHooks,
    height: props.elements.length ? undefined : 'scale.2000',
    renderEmptyState: () => /*#__PURE__*/jsxs(Flex, {
      direction: "column",
      gap: "large",
      alignItems: "center",
      justifyContent: "center",
      height: "100%",
      padding: "regular",
      children: [/*#__PURE__*/jsx(Text, {
        elementType: "h3",
        align: "center",
        color: "neutralSecondary",
        size: "large",
        weight: "medium",
        children: "Empty list"
      }), /*#__PURE__*/jsx(Text, {
        align: "center",
        color: "neutralTertiary",
        children: "Add the first item to see it here."
      })]
    }),
    onAction: key => {
      const idx = props.elements.findIndex(x => x.key === key);
      if (idx === -1) return;
      props.onOpenItem(idx);
    },
    children: item => {
      var _props$schema$itemLab, _props$schema;
      const label = ((_props$schema$itemLab = (_props$schema = props.schema).itemLabel) === null || _props$schema$itemLab === void 0 ? void 0 : _props$schema$itemLab.call(_props$schema, item)) || `Item ${props.elements.indexOf(item) + 1}`;
      return /*#__PURE__*/jsxs(Item$1, {
        textValue: label,
        children: [/*#__PURE__*/jsx(Text, {
          children: label
        }), /*#__PURE__*/jsxs(TooltipTrigger, {
          placement: "start",
          children: [/*#__PURE__*/jsx(ActionButton, {
            onPress: () => {
              onRemoveKey(item.key);
            },
            children: /*#__PURE__*/jsx(Icon, {
              src: trash2Icon
            })
          }), /*#__PURE__*/jsx(Tooltip, {
            tone: "critical",
            children: stringFormatter.format('delete')
          })]
        })]
      }, item.key);
    }
  });
}

// https://github.com/adobe/react-spectrum/blob/97ff9f95d91befaf87251e52ea484f81daae8f3a/packages/%40react-stately/data/src/useListData.ts#L263
function move(items, indices, toIndex) {
  // Shift the target down by the number of items being moved from before the target
  toIndex -= indices.filter(index => index < toIndex).length;
  let moves = indices.map(from => ({
    from,
    to: toIndex++
  }));

  // Shift later from indices down if they have a larger index
  for (let i = 0; i < moves.length; i++) {
    let a = moves[i].from;
    for (let j = i; j < moves.length; j++) {
      let b = moves[j].from;
      if (b > a) {
        moves[j].from--;
      }
    }
  }

  // Interleave the moves so they can be applied one by one rather than all at once
  for (let i = 0; i < moves.length; i++) {
    let a = moves[i];
    for (let j = moves.length - 1; j > i; j--) {
      let b = moves[j];
      if (b.from < a.to) {
        a.to++;
      } else {
        b.from++;
      }
    }
  }
  let copy = items.slice();
  for (let move of moves) {
    let [item] = copy.splice(move.from, 1);
    copy.splice(move.to, 0, item);
  }
  return copy;
}
function ArrayFieldItemModalContent(props) {
  const previewProps = useMemo(() => createGetPreviewProps(props.schema, props.onChange, () => undefined), [props.schema, props.onChange])(props.value);
  return /*#__PURE__*/jsx(FormValueContentFromPreviewProps, {
    slugField: props.slugField,
    autoFocus: true,
    ...previewProps
  });
}

function isNonChildFieldPreviewProps(props) {
  return props.schema.kind !== 'child';
}
function getInputComponent(schema) {
  if (schema.kind === 'object') {
    var _schema$Input;
    return (_schema$Input = schema.Input) !== null && _schema$Input !== void 0 ? _schema$Input : ObjectFieldInput;
  }
  if (schema.kind === 'conditional') {
    var _schema$Input2;
    return (_schema$Input2 = schema.Input) !== null && _schema$Input2 !== void 0 ? _schema$Input2 : ConditionalFieldInput;
  }
  if (schema.kind === 'array') {
    var _schema$Input3;
    return (_schema$Input3 = schema.Input) !== null && _schema$Input3 !== void 0 ? _schema$Input3 : ArrayFieldInput;
  }
  return schema.Input;
}
const InnerFormValueContentFromPreviewProps = /*#__PURE__*/memo(function InnerFormValueContentFromPreview(props) {
  let Input = getInputComponent(props.schema);
  return /*#__PURE__*/jsx(Input, {
    ...props,
    autoFocus: !!props.autoFocus,
    forceValidation: !!props.forceValidation
  });
});
const emptyArray$1 = [];
const FormValueContentFromPreviewProps = /*#__PURE__*/memo(function FormValueContentFromPreview({
  slugField,
  ...props
}) {
  let Input = getInputComponent(props.schema);
  return /*#__PURE__*/jsx(PathContextProvider, {
    value: emptyArray$1,
    children: /*#__PURE__*/jsx(SlugFieldProvider, {
      value: slugField,
      children: /*#__PURE__*/jsx(Input, {
        ...props,
        autoFocus: !!props.autoFocus,
        forceValidation: !!props.forceValidation
      })
    })
  });
});

const emptyArray = [];
const RESPONSIVE_PADDING = {
  mobile: 'medium',
  tablet: 'xlarge',
  desktop: 'xxlarge'
};
function containerWidthForEntryLayout(config) {
  return config.entryLayout === 'content' ? 'none' : 'medium';
}
const EntryLayoutSplitPaneContext = /*#__PURE__*/createContext(null);
function FormForEntry({
  formatInfo,
  forceValidation,
  slugField,
  entryLayout,
  previewProps: _previewProps
}) {
  const isAboveMobile = useContentPanelQuery({
    above: 'mobile'
  });
  const props = _previewProps;
  if (entryLayout === 'content' && formatInfo.contentField && isAboveMobile) {
    const {
      contentField
    } = formatInfo;
    return /*#__PURE__*/jsx(PathContextProvider, {
      value: emptyArray,
      children: /*#__PURE__*/jsx(SlugFieldProvider, {
        value: slugField,
        children: /*#__PURE__*/jsxs(SplitView, {
          autoSaveId: "keystatic-content-split-view",
          defaultSize: 320,
          minSize: 240,
          maxSize: 480,
          flex: true,
          children: [/*#__PURE__*/jsx(SplitPaneSecondary, {
            children: /*#__PURE__*/jsx(EntryLayoutSplitPaneContext.Provider, {
              value: "main",
              children: /*#__PURE__*/jsx(ScrollView, {
                children: /*#__PURE__*/jsx(AddToPathProvider, {
                  part: contentField.key,
                  children: /*#__PURE__*/jsx(InnerFormValueContentFromPreviewProps, {
                    forceValidation: forceValidation,
                    ...props.fields[contentField.key]
                  })
                })
              })
            })
          }), /*#__PURE__*/jsx(SplitPanePrimary, {
            children: /*#__PURE__*/jsx(EntryLayoutSplitPaneContext.Provider, {
              value: "side",
              children: /*#__PURE__*/jsx(ScrollView, {
                children: /*#__PURE__*/jsx(Grid, {
                  gap: "xlarge",
                  padding: RESPONSIVE_PADDING,
                  children: Object.entries(props.fields).map(([key, propVal]) => key === contentField.key ? null : /*#__PURE__*/jsx(AddToPathProvider, {
                    part: key,
                    children: /*#__PURE__*/jsx(InnerFormValueContentFromPreviewProps, {
                      forceValidation: forceValidation,
                      ...propVal
                    })
                  }, key))
                })
              })
            })
          })]
        })
      })
    });
  }
  return /*#__PURE__*/jsx(ScrollView, {
    children: /*#__PURE__*/jsx(PageContainer, {
      paddingY: RESPONSIVE_PADDING,
      children: /*#__PURE__*/jsx(FormValueContentFromPreviewProps
      // autoFocus
      , {
        forceValidation: forceValidation,
        slugField: slugField,
        ...props
      })
    })
  });
}

const AppSlugContext = /*#__PURE__*/createContext(undefined);
const AppSlugProvider = AppSlugContext.Provider;
function InstallGitHubApp(props) {
  var _URL$searchParams$get;
  const router = useRouter();
  const appSlugFromContext = useContext(AppSlugContext);
  const appSlug = (_URL$searchParams$get = new URL(router.href, 'https://example.com').searchParams.get('slug')) !== null && _URL$searchParams$get !== void 0 ? _URL$searchParams$get : appSlugFromContext === null || appSlugFromContext === void 0 ? void 0 : appSlugFromContext.value;
  const parsedRepo = parseRepoConfig(props.config.storage.repo);
  return /*#__PURE__*/jsxs(Flex, {
    direction: "column",
    gap: "regular",
    children: [/*#__PURE__*/jsxs(Flex, {
      alignItems: "end",
      gap: "regular",
      children: [/*#__PURE__*/jsx(TextField, {
        label: "Repo Name",
        width: "100%",
        isReadOnly: true,
        value: parsedRepo.name
      }), /*#__PURE__*/jsx(ActionButton, {
        onPress: () => {
          navigator.clipboard.writeText(parsedRepo.name);
        },
        children: "Copy Repo Name"
      })]
    }), appSlug ? /*#__PURE__*/jsx(Button, {
      prominence: "high",
      href: `https://github.com/apps/${appSlug}/installations/new`,
      children: "Install GitHub App"
    }) : /*#__PURE__*/jsx(Notice, {
      tone: "caution",
      children: appSlugFromContext ? /*#__PURE__*/jsxs(Text, {
        children: ["The ", /*#__PURE__*/jsx("code", {
          children: appSlugFromContext.envName
        }), " environment variable wasn't provided so we can't link to the GitHub app installation page. You should find the App on GitHub and add the repo yourself."]
      }) : /*#__PURE__*/jsx(Text, {
        children: "Find the App on GitHub and add the repo."
      })
    })]
  });
}

function ForkRepoDialog(props) {
  const stringFormatter = useLocalizedStringFormatter(l10nMessages);
  const client = useClient();
  const [state, setState] = useState({
    kind: 'idle'
  });
  useEffect(() => {
    const listener = async event => {
      if (event.key === 'ks-refetch-installations' && event.newValue === 'true') {
        localStorage.removeItem('ks-refetch-installations');
        try {
          var _res$data;
          const auth = await getAuth(props.config);
          if (!auth) throw new Error('Unauthorized');
          const res = await client.query(GitHubAppShellQuery, parseRepoConfig(props.config.storage.repo)).toPromise();
          if ((_res$data = res.data) !== null && _res$data !== void 0 && (_res$data = _res$data.repository) !== null && _res$data !== void 0 && (_res$data = _res$data.forks.nodes) !== null && _res$data !== void 0 && _res$data.some(x => (x === null || x === void 0 ? void 0 : x.viewerPermission) === 'ADMIN' || (x === null || x === void 0 ? void 0 : x.viewerPermission) === 'WRITE' || (x === null || x === void 0 ? void 0 : x.viewerPermission) === 'MAINTAIN')) {
            await new Promise(resolve => setTimeout(resolve, 100));
            props.onCreate();
          }
        } catch (err) {
          setState({
            kind: 'error',
            error: err
          });
        }
      }
    };
    addEventListener('storage', listener);
    return () => removeEventListener('storage', listener);
  }, [client, props]);
  const appSlug = useContext(AppSlugContext);
  return /*#__PURE__*/jsxs(Dialog, {
    size: "small",
    isDismissable: true,
    onDismiss: () => {
      props.onDismiss();
    },
    children: [/*#__PURE__*/jsx(Heading, {
      children: "Fork Repo"
    }), state.kind === 'error' ? /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsx(Content, {
        children: /*#__PURE__*/jsx(Notice, {
          tone: "critical",
          children: state.error.message
        })
      }), /*#__PURE__*/jsx(ButtonGroup, {
        children: /*#__PURE__*/jsx(Button, {
          onPress: props.onDismiss,
          children: stringFormatter.format('cancel')
        })
      })]
    }) : /*#__PURE__*/jsx(Fragment, {
      children: /*#__PURE__*/jsx(Content, {
        children: /*#__PURE__*/jsxs(Flex, {
          gap: "large",
          direction: "column",
          marginBottom: "large",
          children: [/*#__PURE__*/jsx(Text, {
            children: "You don't have permission to write to this repo so to save your changes, you need to fork the repo."
          }), /*#__PURE__*/jsxs(Text, {
            children: ["To start,", ' ', /*#__PURE__*/jsx(TextLink, {
              href: `https://github.com/${serializeRepoConfig(props.config.storage.repo)}/fork`,
              target: "_blank",
              rel: "noopener noreferrer",
              children: "fork the repo on GitHub"
            }), ". Then, come back to this page and", ' ', /*#__PURE__*/jsx(TextLink, {
              href: `https://github.com/apps/${appSlug === null || appSlug === void 0 ? void 0 : appSlug.value}/installations/new?state=close`,
              target: "_blank",
              rel: "noopener noreferrer",
              children: "install the Keystatic GitHub App on your fork."
            })]
          })]
        })
      })
    })]
  });
}

function parseEntry(args, files) {
  const dataFilepath = getEntryDataFilepath(args.dirpath, args.format);
  const data = files.get(dataFilepath);
  if (!data) {
    throw new Error(`Could not find data file at ${dataFilepath}`);
  }
  const {
    loaded,
    extraFakeFile
  } = loadDataFile(data, args.format);
  const filesWithFakeFile = new Map(files);
  if (extraFakeFile) {
    filesWithFakeFile.set(`${args.dirpath}/${extraFakeFile.path}`, extraFakeFile.contents);
  }
  const rootSchema = object(args.schema);
  let initialState;
  try {
    initialState = parseProps(rootSchema, loaded, [], [], (schema, value, path, pathWithArrayFieldSlugs) => {
      var _args$slug;
      if (path.length === 1 && path[0] === ((_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.field)) {
        if (schema.formKind !== 'slug') {
          throw new Error(`slugField is not a slug field`);
        }
        return schema.parse(value, {
          slug: args.slug.slug
        });
      }
      if (schema.formKind === 'asset') {
        var _args$slug2, _args$slug3, _args$slug4;
        const suggestedFilenamePrefix = pathWithArrayFieldSlugs.join('/');
        const filepath = schema.filename(value, {
          suggestedFilenamePrefix,
          slug: (_args$slug2 = args.slug) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.slug
        });
        const asset = filepath ? filesWithFakeFile.get(`${schema.directory ? `${schema.directory}${((_args$slug3 = args.slug) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.slug) === undefined ? '' : `/${args.slug.slug}`}` : args.dirpath}/${filepath}`) : undefined;
        return schema.parse(value, {
          asset,
          slug: (_args$slug4 = args.slug) === null || _args$slug4 === void 0 ? void 0 : _args$slug4.slug
        });
      }
      if (schema.formKind === 'content') {
        var _args$slug7;
        const rootPath = `${args.dirpath}/${pathWithArrayFieldSlugs.join('/')}`;
        const mainFilepath = rootPath + schema.contentExtension;
        const mainContents = filesWithFakeFile.get(mainFilepath);
        const otherFiles = new Map();
        const otherDirectories = new Map();
        for (const [filename] of filesWithFakeFile) {
          if (filename.startsWith(rootPath + '/')) {
            const relativePath = filename.slice(rootPath.length + 1);
            otherFiles.set(relativePath, filesWithFakeFile.get(filename));
          }
        }
        for (const dir of (_schema$directories = schema.directories) !== null && _schema$directories !== void 0 ? _schema$directories : []) {
          var _schema$directories, _args$slug5, _args$slug6;
          const dirFiles = new Map();
          const start = `${dir}${((_args$slug5 = args.slug) === null || _args$slug5 === void 0 ? void 0 : _args$slug5.slug) === undefined ? '' : `/${(_args$slug6 = args.slug) === null || _args$slug6 === void 0 ? void 0 : _args$slug6.slug}`}/`;
          for (const [filename, val] of filesWithFakeFile) {
            if (filename.startsWith(start)) {
              const relativePath = filename.slice(start.length);
              dirFiles.set(relativePath, val);
            }
          }
          if (dirFiles.size) {
            otherDirectories.set(dir, dirFiles);
          }
        }
        return schema.parse(value, {
          content: mainContents,
          other: otherFiles,
          external: otherDirectories,
          slug: (_args$slug7 = args.slug) === null || _args$slug7 === void 0 ? void 0 : _args$slug7.slug
        });
      }
      return schema.parse(value, undefined);
    }, false);
  } catch (err) {
    throw toFormattedFormDataError(err);
  }
  const initialFiles = [...files.keys()];
  return {
    initialState,
    initialFiles
  };
}
function getAllFilesInTree(tree) {
  return [...tree.values()].flatMap(val => val.children ? getAllFilesInTree(val.children) : [val.entry]);
}
function useItemData(args) {
  var _args$slug9;
  const {
    current: currentBranch
  } = useTree();
  const rootTree = currentBranch.kind === 'loaded' ? currentBranch.data.tree : undefined;
  const locationsForTreeKey = useMemo(() => {
    var _args$slug8;
    return getDirectoriesForTreeKey(object(args.schema), args.dirpath, (_args$slug8 = args.slug) === null || _args$slug8 === void 0 ? void 0 : _args$slug8.slug, args.format);
  }, [args.dirpath, args.format, args.schema, (_args$slug9 = args.slug) === null || _args$slug9 === void 0 ? void 0 : _args$slug9.slug]);
  const localTreeKey = useMemo(() => getTreeKey(locationsForTreeKey, rootTree !== null && rootTree !== void 0 ? rootTree : new Map()), [locationsForTreeKey, rootTree]);
  const tree = useMemo(() => {
    return rootTree !== null && rootTree !== void 0 ? rootTree : new Map();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [localTreeKey, locationsForTreeKey]);
  const hasLoaded = currentBranch.kind === 'loaded';
  return useData(useCallback(() => {
    var _getTreeNodeAtPath;
    if (!hasLoaded) return LOADING;
    const dataFilepathSha = (_getTreeNodeAtPath = getTreeNodeAtPath(tree, getEntryDataFilepath(args.dirpath, args.format))) === null || _getTreeNodeAtPath === void 0 ? void 0 : _getTreeNodeAtPath.entry.sha;
    if (dataFilepathSha === undefined) {
      return 'not-found';
    }
    const _args = {
      config: args.config,
      dirpath: args.dirpath,
      format: args.format,
      schema: args.schema,
      slug: args.slug
    };
    const allBlobs = locationsForTreeKey.flatMap(dir => {
      const node = getTreeNodeAtPath(tree, dir);
      if (!node) return [];
      return node.children ? getAllFilesInTree(node.children) : [node.entry];
    }).map(entry => {
      const blob = fetchBlob(args.config, entry.sha, entry.path);
      if (blob instanceof Uint8Array) {
        return [entry.path, blob];
      }
      return blob.then(blob => [entry.path, blob]);
    });
    if (allBlobs.every(x => Array.isArray(x))) {
      const {
        initialFiles,
        initialState
      } = parseEntry(_args, new Map(allBlobs));
      return {
        initialState,
        initialFiles,
        localTreeKey
      };
    }
    return Promise.all(allBlobs).then(async data => {
      const {
        initialState,
        initialFiles
      } = parseEntry(_args, new Map(data));
      return {
        initialState,
        initialFiles,
        localTreeKey
      };
    });
  }, [hasLoaded, tree, args.dirpath, args.format, args.config, args.schema, args.slug, locationsForTreeKey, localTreeKey]));
}
const blobCache = new LRU({
  max: 200
});
async function hydrateBlobCache(contents) {
  const sha = await blobSha(contents);
  blobCache.set(sha, contents);
  return sha;
}
async function fetchGitHubBlob(config, oid) {
  const auth = await getAuth(config);
  return fetch(config.storage.kind === 'github' ? `https://api.github.com/repos/${serializeRepoConfig(config.storage.repo)}/git/blobs/${oid}` : `${KEYSTATIC_CLOUD_API_URL}/v1/github/blob/${oid}`, {
    headers: {
      Authorization: `Bearer ${auth.accessToken}`,
      Accept: 'application/vnd.github.raw',
      ...(config.storage.kind === 'cloud' ? KEYSTATIC_CLOUD_HEADERS : {})
    }
  });
}
function fetchBlob(config, oid, filepath) {
  if (blobCache.has(oid)) return blobCache.get(oid);
  const promise = (isGitHubConfig(config) || config.storage.kind === 'cloud' ? fetchGitHubBlob(config, oid) : fetch(`/api/keystatic/blob/${oid}/${filepath}`, {
    headers: {
      'no-cors': '1'
    }
  })).then(x => x.arrayBuffer()).then(x => {
    const array = new Uint8Array(x);
    blobCache.set(oid, array);
    return array;
  }).catch(err => {
    blobCache.delete(oid);
    throw err;
  });
  blobCache.set(oid, promise);
  return promise;
}

const ThemeContext = /*#__PURE__*/createContext({
  theme: 'auto',
  setTheme: () => {
    throw new Error('ThemeContext was not initialized.');
  }
});
const ThemeProvider = ThemeContext.Provider;
const STORAGE_KEY = 'keystatic-color-scheme';

// only for initializing the provider, for consumption use `useThemeContext()`
function useTheme() {
  let [theme, setThemeValue] = useState(() => {
    let storedValue = localStorage.getItem(STORAGE_KEY);
    if (storedValue === 'light' || storedValue === 'dark') {
      return storedValue;
    }
    return 'auto';
  });
  let setTheme = theme => {
    localStorage.setItem(STORAGE_KEY, theme);
    setThemeValue(theme);
  };
  return {
    theme,
    setTheme
  };
}
function useThemeContext() {
  return useContext(ThemeContext);
}

injectGlobal({
  body: {
    overflow: 'hidden'
  }
});
function createUrqlClient(config) {
  const repo = config.storage.kind === 'github' ? parseRepoConfig(config.storage.repo) : {
    owner: 'repo-owner',
    name: 'repo-name'
  };
  return createClient({
    url: config.storage.kind === 'github' ? 'https://api.github.com/graphql' : `${KEYSTATIC_CLOUD_API_URL}/v1/github/graphql`,
    requestPolicy: 'cache-and-network',
    exchanges: [dedupExchange, authExchange(async utils => {
      let authState = await getAuth(config);
      return {
        addAuthToOperation(operation) {
          authState = getSyncAuth(config);
          if (!authState) {
            return operation;
          }
          return utils.appendHeaders(operation, {
            Authorization: `Bearer ${authState.accessToken}`,
            ...(config.storage.kind === 'cloud' ? KEYSTATIC_CLOUD_HEADERS : {})
          });
        },
        didAuthError() {
          return false;
        },
        willAuthError(operation) {
          var _operation$query$defi;
          authState = getSyncAuth(config);
          if (operation.query.definitions[0].kind === 'OperationDefinition' && (_operation$query$defi = operation.query.definitions[0].name) !== null && _operation$query$defi !== void 0 && _operation$query$defi.value.includes('AppShell') && !authState) {
            if (config.storage.kind === 'github') {
              window.location.href = '/api/keystatic/github/login';
            } else {
              redirectToCloudAuth('', config);
            }
            return true;
          }
          if (!authState) {
            return true;
          }
          return false;
        },
        async refreshAuth() {
          authState = await getAuth(config);
        }
      };
    }), cacheExchange({
      updates: {
        Mutation: {
          createRef(result, args, cache, _info) {
            cache.updateQuery({
              query: config.storage.kind === 'github' ? GitHubAppShellQuery : CloudAppShellQuery,
              variables: repo
            }, data => {
              var _data$repository;
              if (data !== null && data !== void 0 && (_data$repository = data.repository) !== null && _data$repository !== void 0 && (_data$repository = _data$repository.refs) !== null && _data$repository !== void 0 && _data$repository.nodes && result.createRef && typeof result.createRef === 'object' && 'ref' in result.createRef) {
                return {
                  ...data,
                  repository: {
                    ...data.repository,
                    refs: {
                      ...data.repository.refs,
                      nodes: [...data.repository.refs.nodes, result.createRef.ref]
                    }
                  }
                };
              }
              return data;
            });
          },
          deleteRef(result, args, cache, _info) {
            cache.updateQuery({
              query: config.storage.kind === 'github' ? GitHubAppShellQuery : CloudAppShellQuery,
              variables: repo
            }, data => {
              var _data$repository2;
              if (data !== null && data !== void 0 && (_data$repository2 = data.repository) !== null && _data$repository2 !== void 0 && (_data$repository2 = _data$repository2.refs) !== null && _data$repository2 !== void 0 && _data$repository2.nodes && result.deleteRef && typeof result.deleteRef === 'object' && '__typename' in result.deleteRef && typeof args.input === 'object' && args.input !== null && 'refId' in args.input && typeof args.input.refId === 'string') {
                const refId = args.input.refId;
                return {
                  ...data,
                  repository: {
                    ...data.repository,
                    refs: {
                      ...data.repository.refs,
                      nodes: data.repository.refs.nodes.filter(x => (x === null || x === void 0 ? void 0 : x.id) !== refId)
                    }
                  }
                };
              }
              return data;
            });
          }
        }
      }
    }), ...(config.storage.kind === 'github' ? [] : [persistedExchange({
      enableForMutation: true,
      enforcePersistedQueries: true
    })]), fetchExchange]
  });
}
function Provider({
  children,
  Link,
  config
}) {
  const themeContext = useTheme();
  const UniversalLink = useMemo(() => makeLinkComponent(({
    href,
    onClick,
    rel,
    ...props
  }, ref) => {
    const shouldUseNext = href[0] === '/';
    return shouldUseNext ? /*#__PURE__*/jsx(Link, {
      href: href,
      ref: ref,
      ...props
    }) : /*#__PURE__*/jsx("a", {
      ref: ref,
      href: href,
      rel: rel || 'noreferrer noopener',
      onClick: event => {
        if (href === '' || href === '#') {
          event.preventDefault();
        }
        if (typeof onClick === 'function') {
          onClick(event);
        }
      },
      ...props
    });
  }), [Link]);
  return /*#__PURE__*/jsx(ThemeProvider, {
    value: themeContext,
    children: /*#__PURE__*/jsxs(VoussoirProvider, {
      linkComponent: UniversalLink,
      locale: config.locale || 'en-US',
      colorScheme: themeContext.theme,
      children: [/*#__PURE__*/jsx(ClientSideOnlyDocumentElement, {}), /*#__PURE__*/jsx("link", {
        href: "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap",
        rel: "stylesheet"
      }), /*#__PURE__*/jsx(Provider$1, {
        value: useMemo(() => createUrqlClient(config), [config]),
        children: children
      }), /*#__PURE__*/jsx(Toaster, {})]
    })
  });
}

const textEncoder = new TextEncoder();
const frontmatterSplit = textEncoder.encode('---\n');
function combineFrontmatterAndContents(frontmatter, contents) {
  const array = new Uint8Array(frontmatter.byteLength + contents.byteLength + frontmatterSplit.byteLength * 2);
  array.set(frontmatterSplit);
  array.set(frontmatter, frontmatterSplit.byteLength);
  array.set(frontmatterSplit, frontmatterSplit.byteLength + frontmatter.byteLength);
  array.set(contents, frontmatterSplit.byteLength * 2 + frontmatter.byteLength);
  return array;
}
function serializeEntryToFiles(args) {
  var _args$slug, _args$slug2;
  let {
    value: stateWithExtraFilesRemoved,
    extraFiles
  } = serializeProps(args.state, object(args.schema), (_args$slug = args.slug) === null || _args$slug === void 0 ? void 0 : _args$slug.field, (_args$slug2 = args.slug) === null || _args$slug2 === void 0 ? void 0 : _args$slug2.value, true);
  const dataFormat = args.format.data;
  let dataContent = textEncoder.encode(dataFormat === 'json' ? JSON.stringify(stateWithExtraFilesRemoved, null, 2) + '\n' : dump(stateWithExtraFilesRemoved));
  if (args.format.contentField) {
    const filename = `${args.format.contentField.key}${args.format.contentField.config.contentExtension}`;
    let contents;
    extraFiles = extraFiles.filter(x => {
      if (x.path !== filename) return true;
      contents = x.contents;
      return false;
    });
    assert(contents !== undefined, 'Expected content field to be present');
    dataContent = combineFrontmatterAndContents(dataContent, contents);
  }
  return [{
    path: getEntryDataFilepath(args.basePath, args.format),
    contents: dataContent
  }, ...extraFiles.map(file => ({
    path: `${file.parent ? args.slug ? `${file.parent}/${args.slug.value}` : file.parent : args.basePath}/${file.path}`,
    contents: file.contents
  }))];
}
function useUpsertItem(args) {
  const [state, setState] = useState({
    kind: 'idle'
  });
  const baseCommit = useBaseCommit();
  const branchInfo = useContext(BranchInfoContext);
  const setTreeSha = useSetTreeSha();
  const [, mutate] = useMutation(createCommitMutation);
  const repoWithWriteAccess = useContext(RepoWithWriteAccessContext);
  const appSlug = useContext(AppSlugContext);
  return [state, async override => {
    try {
      if (repoWithWriteAccess === null && args.config.storage.kind === 'github' && appSlug !== null && appSlug !== void 0 && appSlug.value) {
        setState({
          kind: 'needs-fork'
        });
        return false;
      }
      setState({
        kind: 'loading'
      });
      let additions = serializeEntryToFiles({
        basePath: args.basePath,
        config: args.config,
        schema: args.schema,
        format: args.format,
        state: args.state,
        slug: args.slug
      });
      const additionPathToSha = new Map(await Promise.all(additions.map(async addition => [addition.path, await hydrateBlobCache(addition.contents)])));
      const filesToDelete = new Set(args.initialFiles);
      for (const file of additions) {
        filesToDelete.delete(file.path);
      }
      additions = additions.filter(addition => {
        const sha = additionPathToSha.get(addition.path);
        const existing = getTreeNodeAtPath(args.currentTree, addition.path);
        return (existing === null || existing === void 0 ? void 0 : existing.entry.sha) !== sha;
      });
      const deletions = [...filesToDelete].map(path => ({
        path
      }));
      const updatedTree = await updateTreeWithChanges(args.currentTree, {
        additions,
        deletions: [...filesToDelete]
      });
      await hydrateTreeCacheWithEntries(updatedTree.entries);
      if (args.config.storage.kind === 'github' || args.config.storage.kind === 'cloud') {
        var _override$branch, _override$sha, _result$error, _result$data;
        const branch = {
          branchName: (_override$branch = override === null || override === void 0 ? void 0 : override.branch) !== null && _override$branch !== void 0 ? _override$branch : branchInfo.currentBranch,
          repositoryNameWithOwner: `${repoWithWriteAccess.owner}/${repoWithWriteAccess.name}`
        };
        const runMutation = expectedHeadOid => mutate({
          input: {
            branch,
            expectedHeadOid,
            message: {
              headline: `Update ${args.basePath}`
            },
            fileChanges: {
              additions: additions.map(addition => ({
                ...addition,
                contents: fromUint8Array(addition.contents)
              })),
              deletions
            }
          }
        });
        let result = await runMutation((_override$sha = override === null || override === void 0 ? void 0 : override.sha) !== null && _override$sha !== void 0 ? _override$sha : baseCommit);
        const gqlError = (_result$error = result.error) === null || _result$error === void 0 || (_result$error = _result$error.graphQLErrors[0]) === null || _result$error === void 0 ? void 0 : _result$error.originalError;
        if (gqlError && 'type' in gqlError) {
          if (gqlError.type === 'BRANCH_PROTECTION_RULE_VIOLATION') {
            setState({
              kind: 'needs-new-branch',
              reason: 'Changes must be made via pull request to this branch. Create a new branch to save changes.'
            });
            return false;
          }
          if (gqlError.type === 'STALE_DATA') {
            var _refData$data, _args$slug3;
            // we don't want this to go into the cache yet
            // so we create a new client just for this
            const refData = await createUrqlClient(args.config).query(FetchRef, {
              owner: repoWithWriteAccess.owner,
              name: repoWithWriteAccess.name,
              ref: `refs/heads/${branchInfo.currentBranch}`
            }).toPromise();
            if (!((_refData$data = refData.data) !== null && _refData$data !== void 0 && (_refData$data = _refData$data.repository) !== null && _refData$data !== void 0 && (_refData$data = _refData$data.ref) !== null && _refData$data !== void 0 && _refData$data.target)) {
              throw new Error('Branch not found');
            }
            const tree = await fetchGitHubTreeData(refData.data.repository.ref.target.oid, args.config);
            const treeKey = getTreeKey(getDirectoriesForTreeKey(object(args.schema), args.basePath, (_args$slug3 = args.slug) === null || _args$slug3 === void 0 ? void 0 : _args$slug3.value, args.format), tree.tree);
            if (treeKey === args.currentLocalTreeKey) {
              result = await runMutation(refData.data.repository.ref.target.oid);
            } else {
              setState({
                kind: 'needs-new-branch',
                reason: 'This entry has been updated since it was opened. Create a new branch to save changes.'
              });
              return false;
            }
          }
        }
        if (result.error) {
          throw result.error;
        }
        const target = (_result$data = result.data) === null || _result$data === void 0 || (_result$data = _result$data.createCommitOnBranch) === null || _result$data === void 0 || (_result$data = _result$data.ref) === null || _result$data === void 0 ? void 0 : _result$data.target;
        if (target) {
          setState({
            kind: 'updated'
          });
          return true;
        }
        throw new Error('Failed to update');
      } else {
        const res = await fetch('/api/keystatic/update', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'no-cors': '1'
          },
          body: JSON.stringify({
            additions: additions.map(addition => ({
              ...addition,
              contents: fromUint8Array(addition.contents)
            })),
            deletions
          })
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const newTree = await res.json();
        const {
          tree
        } = await hydrateTreeCacheWithEntries(newTree);
        setTreeSha(await treeSha(tree));
        setState({
          kind: 'updated'
        });
        return true;
      }
    } catch (err) {
      setState({
        kind: 'error',
        error: err
      });
      return false;
    }
  }, () => {
    setState({
      kind: 'idle'
    });
  }];
}
const createCommitMutation = gql`
  mutation CreateCommit($input: CreateCommitOnBranchInput!) {
    createCommitOnBranch(input: $input) {
      ref {
        id
        target {
          id
          oid
          ... on Commit {
            tree {
              id
              oid
            }
          }
        }
      }
    }
  }
`;
function useDeleteItem(args) {
  const [state, setState] = useState({
    kind: 'idle'
  });
  const baseCommit = useBaseCommit();
  const branchInfo = useContext(BranchInfoContext);
  const [, mutate] = useMutation(createCommitMutation);
  const setTreeSha = useSetTreeSha();
  const repoWithWriteAccess = useContext(RepoWithWriteAccessContext);
  const appSlug = useContext(AppSlugContext);
  return [state, async () => {
    try {
      if (repoWithWriteAccess === null && args.storage.kind === 'github' && appSlug !== null && appSlug !== void 0 && appSlug.value) {
        setState({
          kind: 'needs-fork'
        });
        return false;
      }
      setState({
        kind: 'loading'
      });
      const updatedTree = await updateTreeWithChanges(args.currentTree, {
        additions: [],
        deletions: args.initialFiles
      });
      await hydrateTreeCacheWithEntries(updatedTree.entries);
      if (args.storage.kind === 'github' || args.storage.kind === 'cloud') {
        const {
          error
        } = await mutate({
          input: {
            branch: {
              repositoryNameWithOwner: `${repoWithWriteAccess.owner}/${repoWithWriteAccess.name}`,
              branchName: branchInfo.currentBranch
            },
            message: {
              headline: `Delete ${args.basePath}`
            },
            expectedHeadOid: baseCommit,
            fileChanges: {
              deletions: args.initialFiles.map(path => ({
                path
              }))
            }
          }
        });
        if (error) {
          throw error;
        }
        setState({
          kind: 'updated'
        });
        return true;
      } else {
        const res = await fetch('/api/keystatic/update', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'no-cors': '1'
          },
          body: JSON.stringify({
            additions: [],
            deletions: args.initialFiles.map(path => ({
              path
            }))
          })
        });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const newTree = await res.json();
        const {
          tree
        } = await hydrateTreeCacheWithEntries(newTree);
        setTreeSha(await treeSha(tree));
        setState({
          kind: 'updated'
        });
        return true;
      }
    } catch (err) {
      setState({
        kind: 'error',
        error: err
      });
    }
  }, () => {
    setState({
      kind: 'idle'
    });
  }];
}
const FetchRef = gql`
  query FetchRef($owner: String!, $name: String!, $ref: String!) {
    repository(owner: $owner, name: $name) {
      id
      ref(qualifiedName: $ref) {
        id
        target {
          id
          oid
        }
      }
    }
  }
`;

function useHasChanged(args) {
  const initialFilesForUpdate = useMemo(() => args.initialState === null ? null : serializeProps(args.initialState, args.schema, args.slugField, args.slugField ? getSlugFromState({
    schema: args.schema.fields,
    slugField: args.slugField
  }, args.initialState) : undefined, true), [args.initialState, args.schema, args.slugField]);
  const filesForUpdate = useMemo(() => serializeProps(args.state, args.schema, args.slugField, args.slugField ? getSlugFromState({
    schema: args.schema.fields,
    slugField: args.slugField
  }, args.state) : undefined, true), [args.state, args.schema, args.slugField]);
  return useMemo(() => {
    return !isEqual(initialFilesForUpdate, filesForUpdate);
  }, [initialFilesForUpdate, filesForUpdate]);
}

function useSlugsInCollection(collection) {
  const config = useConfig();
  const tree = useTree().current;
  return useMemo(() => {
    const loadedTree = tree.kind === 'loaded' ? tree.data.tree : new Map();
    return getEntriesInCollectionWithTreeKey(config, collection, loadedTree).map(x => x.slug);
  }, [config, tree, collection]);
}

function ItemPage(props) {
  const {
    collection,
    config,
    itemSlug,
    initialFiles,
    initialState,
    localTreeKey,
    currentTree
  } = props;
  const router = useRouter();
  const [forceValidation, setForceValidation] = useState(false);
  const collectionConfig = config.collections[collection];
  const schema = useMemo(() => object(collectionConfig.schema), [collectionConfig.schema]);
  const [{
    state,
    localTreeKey: localTreeKeyInState
  }, setState] = useState({
    state: initialState,
    localTreeKey
  });
  if (localTreeKeyInState !== localTreeKey) {
    setState({
      state: initialState,
      localTreeKey
    });
  }
  const previewProps = useMemo(() => createGetPreviewProps(schema, stateUpdater => {
    setState(state => ({
      localTreeKey: state.localTreeKey,
      state: stateUpdater(state.state)
    }));
  }, () => undefined), [schema])(state);
  const hasChanged = useHasChanged({
    initialState,
    schema,
    state,
    slugField: collectionConfig.slugField
  });
  const baseCommit = useBaseCommit();
  const slug = getSlugFromState(collectionConfig, state);
  const formatInfo = getCollectionFormat(config, collection);
  const currentBasePath = getCollectionItemPath(config, collection, itemSlug);
  const futureBasePath = getCollectionItemPath(config, collection, slug);
  const branchInfo = useBranchInfo();
  const [updateResult, _update, resetUpdateItem] = useUpsertItem({
    state,
    initialFiles,
    config,
    schema: collectionConfig.schema,
    basePath: futureBasePath,
    format: formatInfo,
    currentLocalTreeKey: localTreeKey,
    currentTree,
    slug: {
      field: collectionConfig.slugField,
      value: slug
    }
  });
  const update = useEventCallback(_update);
  const [deleteResult, deleteItem, resetDeleteItem] = useDeleteItem({
    initialFiles,
    storage: config.storage,
    basePath: currentBasePath,
    currentTree
  });
  const onReset = () => {
    setState({
      state: initialState,
      localTreeKey
    });
  };
  const onView = () => {
    assert(isGitHubConfig(config));
    let filePath = formatInfo.dataLocation === 'index' ? `/tree/${branchInfo.currentBranch}/${currentBasePath}` : `/blob/${branchInfo.currentBranch}/${currentBasePath}${getDataFileExtension(formatInfo)}`;
    window.open(`${getRepoUrl(branchInfo)}${filePath}`, '_blank', 'noopener,noreferrer');
  };
  const onDelete = async () => {
    if (await deleteItem()) {
      router.push(`${props.basePath}/collection/${encodeURIComponent(collection)}`);
    }
  };
  const onUpdate = useCallback(async () => {
    if (!clientSideValidateProp(schema, state, props.slugInfo)) {
      setForceValidation(true);
      return;
    }
    const slug = getSlugFromState(collectionConfig, state);
    const hasUpdated = await update();
    if (hasUpdated && slug !== itemSlug) {
      router.replace(`${props.basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(slug)}`);
    }
  }, [collection, collectionConfig, itemSlug, props.basePath, props.slugInfo, router, schema, state, update]);
  const formID = 'item-edit-form';

  // allow shortcuts "cmd+s" and "ctrl+s" to save
  useEffect(() => {
    const listener = event => {
      if (updateResult.kind === 'loading') {
        return;
      }
      if (isHotkey('mod+s', event)) {
        event.preventDefault();
        onUpdate();
      }
    };
    document.addEventListener('keydown', listener);
    return () => document.removeEventListener('keydown', listener);
  }, [updateResult.kind, onUpdate]);
  return /*#__PURE__*/jsx(Fragment, {
    children: /*#__PURE__*/jsxs(ItemPageShell, {
      headerActions: /*#__PURE__*/jsx(HeaderActions, {
        config: config,
        formID: formID,
        isLoading: updateResult.kind === 'loading',
        hasChanged: hasChanged,
        onDelete: onDelete,
        onReset: onReset,
        onView: onView
      }),
      ...props,
      children: [updateResult.kind === 'error' && /*#__PURE__*/jsx(Notice, {
        tone: "critical",
        children: updateResult.error.message
      }), deleteResult.kind === 'error' && /*#__PURE__*/jsx(Notice, {
        tone: "critical",
        children: deleteResult.error.message
      }), /*#__PURE__*/jsx(Box, {
        id: formID,
        height: "100%",
        minHeight: 0,
        minWidth: 0,
        elementType: "form",
        onSubmit: event => {
          if (event.target !== event.currentTarget) return;
          event.preventDefault();
          onUpdate();
        },
        children: /*#__PURE__*/jsx(FormForEntry, {
          previewProps: previewProps,
          forceValidation: forceValidation,
          entryLayout: collectionConfig.entryLayout,
          formatInfo: formatInfo,
          slugField: props.slugInfo
        })
      }), /*#__PURE__*/jsx(DialogContainer
      // ideally this would be a popover on desktop but using a DialogTrigger wouldn't work since
      // this doesn't open on click but after doing a network request and it failing and manually wiring about a popover and modal would be a pain
      , {
        onDismiss: resetUpdateItem,
        children: updateResult.kind === 'needs-new-branch' && /*#__PURE__*/jsx(CreateBranchDuringUpdateDialog, {
          branchOid: baseCommit,
          onCreate: async newBranch => {
            const itemBasePath = `/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(collection)}/item/`;
            router.push(itemBasePath + encodeURIComponent(itemSlug));
            const slug = getSlugFromState(collectionConfig, state);
            const hasUpdated = await update({
              branch: newBranch,
              sha: baseCommit
            });
            if (hasUpdated && slug !== itemSlug) {
              router.replace(itemBasePath + encodeURIComponent(slug));
            }
          },
          reason: updateResult.reason,
          onDismiss: resetUpdateItem
        })
      }), /*#__PURE__*/jsx(DialogContainer
      // ideally this would be a popover on desktop but using a DialogTrigger
      // wouldn't work since this doesn't open on click but after doing a
      // network request and it failing and manually wiring about a popover
      // and modal would be a pain
      , {
        onDismiss: resetUpdateItem,
        children: updateResult.kind === 'needs-fork' && isGitHubConfig(props.config) && /*#__PURE__*/jsx(ForkRepoDialog, {
          onCreate: async () => {
            const slug = getSlugFromState(collectionConfig, state);
            const hasUpdated = await update();
            if (hasUpdated && slug !== itemSlug) {
              router.replace(`${props.basePath}/collection/${encodeURIComponent(collection)}/item/${encodeURIComponent(slug)}`);
            }
          },
          onDismiss: resetUpdateItem,
          config: props.config
        })
      }), /*#__PURE__*/jsx(DialogContainer
      // ideally this would be a popover on desktop but using a DialogTrigger
      // wouldn't work since this doesn't open on click but after doing a
      // network request and it failing and manually wiring about a popover
      // and modal would be a pain
      , {
        onDismiss: resetDeleteItem,
        children: deleteResult.kind === 'needs-fork' && isGitHubConfig(props.config) && /*#__PURE__*/jsx(ForkRepoDialog, {
          onCreate: async () => {
            await deleteItem();
            router.push(`${props.basePath}/collection/${encodeURIComponent(collection)}`);
          },
          onDismiss: resetDeleteItem,
          config: props.config
        })
      })]
    })
  });
}
function HeaderActions(props) {
  let {
    config,
    formID,
    hasChanged,
    isLoading,
    onDelete,
    onReset,
    onView
  } = props;
  const isBelowTablet = useMediaQuery(breakpointQueries.below.tablet);
  const isGithub = isGitHubConfig(config);
  const stringFormatter = useLocalizedStringFormatter(l10nMessages);
  const [deleteAlertIsOpen, setDeleteAlertOpen] = useState(false);
  const menuActions = useMemo(() => {
    let items = [{
      key: 'reset',
      label: 'Reset changes',
      // TODO: l10n
      icon: historyIcon
    }, {
      key: 'delete',
      label: 'Delete entry…',
      // TODO: l10n
      icon: trash2Icon
    }];
    if (isGithub) {
      items.push({
        key: 'view',
        label: 'View on GitHub',
        icon: externalLinkIcon
      });
    }
    return items;
  }, [isGithub]);
  const indicatorElement = (() => {
    if (isLoading) {
      return /*#__PURE__*/jsx(ProgressCircle, {
        "aria-label": "Saving changes",
        isIndeterminate: true,
        size: "small",
        alignSelf: "center"
      });
    }
    if (hasChanged) {
      return isBelowTablet ? /*#__PURE__*/jsx(Box, {
        backgroundColor: "pendingEmphasis",
        height: "scale.75",
        width: "scale.75",
        borderRadius: "full",
        children: /*#__PURE__*/jsx(Text, {
          visuallyHidden: true,
          children: "Unsaved"
        })
      }) : /*#__PURE__*/jsx(Badge, {
        tone: "pending",
        children: "Unsaved"
      });
    }
    return null;
  })();
  return /*#__PURE__*/jsxs(Fragment, {
    children: [indicatorElement, /*#__PURE__*/jsx(ActionGroup, {
      buttonLabelBehavior: "hide",
      overflowMode: "collapse",
      prominence: "low",
      density: "compact",
      maxWidth: isBelowTablet ? 'element.regular' : undefined // force switch to action menu on small devices
      ,
      items: menuActions,
      disabledKeys: hasChanged ? [] : ['reset'],
      onAction: key => {
        switch (key) {
          case 'reset':
            onReset();
            break;
          case 'delete':
            setDeleteAlertOpen(true);
            break;
          case 'view':
            onView();
            break;
        }
      },
      children: item => /*#__PURE__*/jsxs(Item$2, {
        textValue: item.label,
        children: [/*#__PURE__*/jsx(Icon, {
          src: item.icon
        }), /*#__PURE__*/jsx(Text, {
          children: item.label
        })]
      }, item.key)
    }), /*#__PURE__*/jsx(Button, {
      form: formID,
      isDisabled: isLoading,
      prominence: "high",
      type: "submit",
      children: stringFormatter.format('save')
    }), /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: () => setDeleteAlertOpen(false),
      children: deleteAlertIsOpen && /*#__PURE__*/jsx(AlertDialog, {
        title: "Delete entry",
        tone: "critical",
        cancelLabel: "Cancel",
        primaryActionLabel: "Yes, delete",
        autoFocusButton: "cancel",
        onPrimaryAction: onDelete,
        children: "Are you sure? This action cannot be undone."
      })
    })]
  });
}
function CreateBranchDuringUpdateDialog(props) {
  var _data$createRef;
  const stringFormatter = useLocalizedStringFormatter(l10nMessages);
  const repositoryId = useRepositoryId();
  const [branchName, setBranchName] = useState('');
  const [{
    error,
    fetching,
    data
  }, createBranch] = useCreateBranchMutation();
  const isLoading = fetching || !!(data !== null && data !== void 0 && (_data$createRef = data.createRef) !== null && _data$createRef !== void 0 && _data$createRef.__typename);
  return /*#__PURE__*/jsx(Dialog, {
    children: /*#__PURE__*/jsxs("form", {
      style: {
        display: 'contents'
      },
      onSubmit: async event => {
        var _result$data;
        if (event.target !== event.currentTarget) return;
        event.preventDefault();
        const name = `refs/heads/${branchName}`;
        const result = await createBranch({
          input: {
            name,
            oid: props.branchOid,
            repositoryId
          }
        });
        if ((_result$data = result.data) !== null && _result$data !== void 0 && (_result$data = _result$data.createRef) !== null && _result$data !== void 0 && _result$data.__typename) {
          props.onCreate(branchName);
        }
      },
      children: [/*#__PURE__*/jsx(Heading, {
        children: stringFormatter.format('newBranch')
      }), /*#__PURE__*/jsx(Content, {
        children: /*#__PURE__*/jsx(Flex, {
          gap: "large",
          direction: "column",
          children: /*#__PURE__*/jsx(TextField, {
            value: branchName,
            onChange: setBranchName,
            label: "Branch name",
            description: props.reason,
            autoFocus: true,
            errorMessage: error === null || error === void 0 ? void 0 : error.message
          })
        })
      }), /*#__PURE__*/jsxs(ButtonGroup, {
        children: [isLoading && /*#__PURE__*/jsx(ProgressCircle, {
          isIndeterminate: true,
          size: "small",
          "aria-label": "Creating Branch"
        }), /*#__PURE__*/jsx(Button, {
          isDisabled: isLoading,
          onPress: props.onDismiss,
          children: stringFormatter.format('cancel')
        }), /*#__PURE__*/jsx(Button, {
          isDisabled: isLoading,
          prominence: "high",
          type: "submit",
          children: "Create branch and save"
        })]
      })]
    })
  });
}
function ItemPageWrapper(props) {
  var _props$config$collect;
  const collectionConfig = (_props$config$collect = props.config.collections) === null || _props$config$collect === void 0 ? void 0 : _props$config$collect[props.collection];
  if (!collectionConfig) notFound();
  const format = useMemo(() => getCollectionFormat(props.config, props.collection), [props.config, props.collection]);
  const allSlugs = useSlugsInCollection(props.collection);
  const slugInfo = useMemo(() => {
    const slugs = new Set(allSlugs);
    slugs.delete(props.itemSlug);
    return {
      slug: props.itemSlug,
      field: collectionConfig.slugField,
      slugs,
      glob: getSlugGlobForCollection(props.config, props.collection)
    };
  }, [allSlugs, collectionConfig.slugField, props.collection, props.config, props.itemSlug]);
  const itemData = useItemData({
    config: props.config,
    dirpath: getCollectionItemPath(props.config, props.collection, props.itemSlug),
    schema: collectionConfig.schema,
    format,
    slug: slugInfo
  });
  const {
    current: tree
  } = useTree();
  const combined = useMemo(() => mergeDataStates({
    item: itemData,
    tree
  }), [itemData, tree]);
  if (combined.kind === 'error') {
    return /*#__PURE__*/jsx(ItemPageShell, {
      ...props,
      children: /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Notice, {
          tone: "critical",
          children: combined.error.message
        })
      })
    });
  }
  if (combined.kind === 'loading') {
    return /*#__PURE__*/jsx(ItemPageShell, {
      ...props,
      children: /*#__PURE__*/jsx(Flex, {
        alignItems: "center",
        justifyContent: "center",
        minHeight: "scale.3000",
        children: /*#__PURE__*/jsx(ProgressCircle, {
          "aria-label": "Loading Item",
          isIndeterminate: true,
          size: "large"
        })
      })
    });
  }
  if (combined.data.item === 'not-found') {
    return /*#__PURE__*/jsx(ItemPageShell, {
      ...props,
      children: /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Notice, {
          tone: "caution",
          children: "Entry not found."
        })
      })
    });
  }
  return /*#__PURE__*/jsx(ItemPage, {
    collection: props.collection,
    basePath: props.basePath,
    config: props.config,
    itemSlug: props.itemSlug,
    initialState: combined.data.item.initialState,
    initialFiles: combined.data.item.initialFiles,
    localTreeKey: combined.data.item.localTreeKey,
    currentTree: combined.data.tree.tree,
    slugInfo: slugInfo
  });
}
const ItemPageShell = props => {
  const router = useRouter();
  const collectionConfig = props.config.collections[props.collection];
  return /*#__PURE__*/jsxs(PageRoot, {
    containerWidth: containerWidthForEntryLayout(collectionConfig),
    children: [/*#__PURE__*/jsxs(PageHeader, {
      children: [/*#__PURE__*/jsxs(Breadcrumbs, {
        flex: true,
        size: "medium",
        minWidth: 0,
        onAction: key => {
          if (key === 'collection') {
            router.push(`${props.basePath}/collection/${encodeURIComponent(props.collection)}`);
          }
        },
        children: [/*#__PURE__*/jsx(Item$2, {
          children: collectionConfig.label
        }, "collection"), /*#__PURE__*/jsx(Item$2, {
          children: props.itemSlug
        }, "item")]
      }), props.headerActions]
    }), props.children]
  });
};

const emptyMap = new Map();
function CreateItem(props) {
  var _props$config$collect;
  const stringFormatter = useLocalizedStringFormatter(l10nMessages);
  const router = useRouter();
  const collectionConfig = (_props$config$collect = props.config.collections) === null || _props$config$collect === void 0 ? void 0 : _props$config$collect[props.collection];
  if (!collectionConfig) notFound();
  const [forceValidation, setForceValidation] = useState(false);
  const schema = useMemo(() => object(collectionConfig.schema), [collectionConfig.schema]);
  const [state, setState] = useState(() => getInitialPropsValue(schema));
  const previewProps = useMemo(() => createGetPreviewProps(schema, setState, () => undefined), [schema])(state);
  const baseCommit = useBaseCommit();
  const tree = useTree();
  const slug = getSlugFromState(collectionConfig, state);
  const formatInfo = getCollectionFormat(props.config, props.collection);
  const [createResult, _createItem, resetCreateItemState] = useUpsertItem({
    state,
    basePath: getCollectionItemPath(props.config, props.collection, slug),
    initialFiles: undefined,
    config: props.config,
    schema: collectionConfig.schema,
    format: formatInfo,
    currentLocalTreeKey: undefined,
    currentTree: tree.current.kind === 'loaded' ? tree.current.data.tree : emptyMap,
    slug: {
      field: collectionConfig.slugField,
      value: slug
    }
  });
  const createItem = useEventCallback(_createItem);
  let collectionPath = `${props.basePath}/collection/${encodeURIComponent(props.collection)}`;
  const slugsArr = useSlugsInCollection(props.collection);
  const currentSlug = createResult.kind === 'updated' || createResult.kind === 'loading' ? slug : undefined;
  const slugInfo = useMemo(() => {
    const slugs = new Set(slugsArr);
    if (currentSlug) {
      slugs.delete(currentSlug);
    }
    return {
      field: collectionConfig.slugField,
      slugs,
      glob: getSlugGlobForCollection(props.config, props.collection)
    };
  }, [slugsArr, currentSlug, collectionConfig.slugField, props.config, props.collection]);
  const onCreate = async () => {
    if (!clientSideValidateProp(schema, state, slugInfo)) {
      setForceValidation(true);
      return;
    }
    if (await createItem()) {
      const slug = getSlugFromState(collectionConfig, state);
      router.push(`${collectionPath}/item/${encodeURIComponent(slug)}`);
      toastQueue.positive('Entry created', {
        timeout: 5000
      }); // TODO: l10n
    }
  };

  // note we're still "loading" when it's already been created
  // since we're waiting to go to the item page
  const isLoading = createResult.kind === 'loading' || createResult.kind === 'updated';
  const formID = 'item-create-form';
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsxs(PageRoot, {
      containerWidth: containerWidthForEntryLayout(collectionConfig),
      children: [/*#__PURE__*/jsxs(PageHeader, {
        children: [/*#__PURE__*/jsxs(Breadcrumbs, {
          size: "medium",
          flex: true,
          minWidth: 0,
          onAction: key => {
            if (key === 'collection') {
              router.push(collectionPath);
            }
          },
          children: [/*#__PURE__*/jsx(Item$2, {
            children: collectionConfig.label
          }, "collection"), /*#__PURE__*/jsx(Item$2, {
            children: stringFormatter.format('add')
          }, "current")]
        }), isLoading && /*#__PURE__*/jsx(ProgressCircle, {
          "aria-label": "Creating entry",
          isIndeterminate: true,
          size: "small"
        }), /*#__PURE__*/jsx(Button, {
          isDisabled: isLoading,
          prominence: "high",
          type: "submit",
          form: formID,
          marginStart: "auto",
          children: stringFormatter.format('create')
        })]
      }), /*#__PURE__*/jsxs(Flex, {
        id: formID,
        elementType: "form",
        onSubmit: event => {
          if (event.target !== event.currentTarget) return;
          event.preventDefault();
          onCreate();
        },
        direction: "column",
        gap: "xxlarge",
        height: "100%",
        minHeight: 0,
        minWidth: 0,
        children: [createResult.kind === 'error' && /*#__PURE__*/jsx(Notice, {
          tone: "critical",
          children: createResult.error.message
        }), /*#__PURE__*/jsx(FormForEntry, {
          previewProps: previewProps,
          forceValidation: forceValidation,
          entryLayout: collectionConfig.entryLayout,
          formatInfo: formatInfo,
          slugField: slugInfo
        })]
      })]
    }), /*#__PURE__*/jsx(DialogContainer
    // ideally this would be a popover on desktop but using a DialogTrigger
    // wouldn't work since this doesn't open on click but after doing a
    // network request and it failing and manually wiring about a popover
    // and modal would be a pain
    , {
      onDismiss: resetCreateItemState,
      children: createResult.kind === 'needs-new-branch' && /*#__PURE__*/jsx(CreateBranchDuringUpdateDialog, {
        branchOid: baseCommit,
        onCreate: async newBranch => {
          router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(props.collection)}/create`);
          if (await createItem({
            branch: newBranch,
            sha: baseCommit
          })) {
            const slug = getSlugFromState(collectionConfig, state);
            router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/collection/${encodeURIComponent(props.collection)}/item/${encodeURIComponent(slug)}`);
          }
        },
        reason: createResult.reason,
        onDismiss: resetCreateItemState
      })
    }), /*#__PURE__*/jsx(DialogContainer
    // ideally this would be a popover on desktop but using a DialogTrigger
    // wouldn't work since this doesn't open on click but after doing a
    // network request and it failing and manually wiring about a popover
    // and modal would be a pain
    , {
      onDismiss: resetCreateItemState,
      children: createResult.kind === 'needs-fork' && isGitHubConfig(props.config) && /*#__PURE__*/jsx(ForkRepoDialog, {
        onCreate: async () => {
          if (await createItem()) {
            const slug = getSlugFromState(collectionConfig, state);
            router.push(`${collectionPath}/item/${encodeURIComponent(slug)}`);
          }
        },
        onDismiss: resetCreateItemState,
        config: props.config
      })
    })]
  });
}

const DashboardSection = ({
  children,
  title
}) => {
  return /*#__PURE__*/jsxs(Flex, {
    elementType: "section",
    direction: "column",
    gap: "medium",
    children: [/*#__PURE__*/jsx(Text, {
      casing: "uppercase",
      color: "neutralTertiary",
      size: "small",
      weight: "bold",
      elementType: "h2",
      children: title
    }), children]
  });
};
const DashboardGrid = props => {
  return /*#__PURE__*/jsx("div", {
    className: css({
      display: 'grid',
      gap: tokenSchema.size.space.large,
      gridAutoRows: tokenSchema.size.element.xlarge,
      [containerQueries.above.mobile]: {
        gridTemplateColumns: '1fr 1fr'
      },
      [containerQueries.above.tablet]: {
        gridTemplateColumns: '1fr 1fr 1fr'
      }
    }),
    ...props
  });
};
const DashboardCard = props => {
  let Link = useLinkComponent(null);
  return /*#__PURE__*/jsxs(Flex, {
    alignItems: "center",
    backgroundColor: "canvas",
    padding: "large",
    position: "relative",
    children: [/*#__PURE__*/jsxs(Flex, {
      direction: "column",
      gap: "medium",
      flex: true,
      children: [/*#__PURE__*/jsx(Heading, {
        elementType: "h3",
        size: "small",
        truncate: true,
        children: /*#__PURE__*/jsx(Link, {
          href: props.href,
          className: classNames(css({
            color: tokenSchema.color.foreground.neutral,
            outline: 'none',
            '&:hover': {
              color: tokenSchema.color.foreground.neutralEmphasis,
              '::before': {
                backgroundColor: tokenSchema.color.alias.backgroundIdle,
                borderColor: tokenSchema.color.border.neutral
              }
            },
            '&:active': {
              '::before': {
                backgroundColor: tokenSchema.color.alias.backgroundHovered,
                borderColor: tokenSchema.color.alias.borderHovered
              }
            },
            '&:focus-visible::before': {
              outline: `${tokenSchema.size.alias.focusRing} solid ${tokenSchema.color.alias.focusRing}`,
              outlineOffset: tokenSchema.size.alias.focusRingGap
            },
            // fill the available space so that the card is clickable
            '::before': {
              border: `${tokenSchema.size.border.regular} solid ${tokenSchema.color.border.muted}`,
              borderRadius: tokenSchema.size.radius.medium,
              content: '""',
              position: 'absolute',
              inset: 0,
              transition: transition(['background-color', 'border-color'])
            }
          })),
          children: props.label
        })
      }), props.children]
    }), props.endElement]
  });
};

function useLocalizedString() {
  let stringFormatter = useLocalizedStringFormatter(l10nMessages);
  return stringFormatter;
}

function BranchSection(props) {
  let branchInfo = useBranchInfo();
  let router = useRouter();
  let localizedString = useLocalizedString();
  if (isLocalConfig(props.config)) {
    return null;
  }
  let repoURL = getRepoUrl(branchInfo);
  let isDefaultBranch = branchInfo.currentBranch === branchInfo.defaultBranch;
  return /*#__PURE__*/jsxs(DashboardSection, {
    title: localizedString.format('currentBranch'),
    children: [/*#__PURE__*/jsxs(Flex, {
      alignItems: "center",
      gap: "regular",
      border: "muted",
      borderRadius: "medium",
      backgroundColor: "canvas",
      padding: "large",
      children: [/*#__PURE__*/jsx(Icon, {
        src: gitBranchIcon,
        color: "neutralTertiary"
      }), /*#__PURE__*/jsx(Text, {
        size: "medium",
        weight: "semibold",
        children: branchInfo.currentBranch
      })]
    }), /*#__PURE__*/jsxs(Flex, {
      gap: "regular",
      wrap: true,
      children: [/*#__PURE__*/jsxs(DialogTrigger, {
        children: [/*#__PURE__*/jsxs(ActionButton, {
          children: [/*#__PURE__*/jsx(Icon, {
            src: gitBranchPlusIcon
          }), /*#__PURE__*/jsx(Text, {
            children: localizedString.format('newBranch')
          })]
        }), close => /*#__PURE__*/jsx(CreateBranchDialog, {
          onDismiss: close,
          onCreate: branchName => {
            close();
            router.push(router.href.replace(/\/branch\/[^/]+/, '/branch/' + encodeURIComponent(branchName)));
          }
        })]
      }), !isDefaultBranch && /*#__PURE__*/jsxs(ActionButton, {
        href: `${repoURL}/pull/new/${branchInfo.currentBranch}`,
        target: "_blank",
        children: [/*#__PURE__*/jsx(Icon, {
          src: gitPullRequestIcon
        }), /*#__PURE__*/jsx(Text, {
          children: localizedString.format('createPullRequest')
        })]
      })]
    })]
  });
}

function CollectionSection(props) {
  var _props$config$collect;
  let localizedString = useLocalizedString();
  let changed = useChanged();
  let collections = keyedEntries((_props$config$collect = props.config.collections) !== null && _props$config$collect !== void 0 ? _props$config$collect : {});
  return /*#__PURE__*/jsx(DashboardSection, {
    title: "Collections",
    children: /*#__PURE__*/jsx(DashboardGrid, {
      children: collections.map(collection => {
        var _counts$totalCount;
        let counts = changed.collections.get(collection.key);
        let totalCount = (_counts$totalCount = counts === null || counts === void 0 ? void 0 : counts.totalCount) !== null && _counts$totalCount !== void 0 ? _counts$totalCount : 0;
        let changes = counts ? counts.added.size + counts.changed.size + counts.removed.size : 0;
        return /*#__PURE__*/jsx(DashboardCard, {
          label: collection.label,
          href: `${props.basePath}/collection/${encodeURIComponent(collection.key)}`,
          endElement: /*#__PURE__*/jsxs(Flex, {
            gap: "medium",
            alignItems: "center",
            children: [changes > 0 && /*#__PURE__*/jsx(Badge, {
              tone: "accent",
              children: pluralize(changes, {
                singular: 'change',
                plural: 'changes'
              })
            }), /*#__PURE__*/jsx(ActionButton, {
              "aria-label": localizedString.format('add'),
              href: `${props.basePath}/collection/${encodeURIComponent(collection.key)}/create`,
              children: /*#__PURE__*/jsx(Icon, {
                src: plusIcon
              })
            })]
          }),
          children: /*#__PURE__*/jsx(Text, {
            color: "neutralSecondary",
            children: pluralize(totalCount, {
              singular: 'entry',
              plural: 'entries'
            })
          })
        }, collection.key);
      })
    })
  });
}

function SingletonSection(props) {
  var _props$config$singlet;
  let changed = useChanged();
  let singletons = keyedEntries((_props$config$singlet = props.config.singletons) !== null && _props$config$singlet !== void 0 ? _props$config$singlet : {});
  if (singletons.length === 0) {
    return null;
  }
  return /*#__PURE__*/jsx(DashboardSection, {
    title: "Singletons",
    children: /*#__PURE__*/jsx(DashboardGrid, {
      children: singletons.map(singleton => {
        let changes = changed.singletons.has(singleton.key);
        return /*#__PURE__*/jsx(DashboardCard, {
          label: singleton.label,
          href: `${props.basePath}/singleton/${encodeURIComponent(singleton.key)}`,
          endElement: changes ? /*#__PURE__*/jsx(Badge, {
            tone: "accent",
            children: "Changed"
          }) : /*#__PURE__*/jsx(Badge, {
            children: "Unchanged"
          })
        }, singleton.key);
      })
    })
  });
}

function DashboardPage(props) {
  var _user$name, _user$name2;
  const stringFormatter = useLocalizedStringFormatter(l10nMessages);
  const user = useViewer();
  return /*#__PURE__*/jsxs(PageRoot, {
    containerWidth: "large",
    children: [/*#__PURE__*/jsx(PageHeader, {
      children: /*#__PURE__*/jsx(Heading, {
        elementType: "h1",
        id: "page-title",
        size: "small",
        children: stringFormatter.format('dashboard')
      })
    }), /*#__PURE__*/jsx(PageBody, {
      isScrollable: true,
      children: /*#__PURE__*/jsxs(Flex, {
        direction: "column",
        gap: "xxlarge",
        children: [user && /*#__PURE__*/jsxs(Flex, {
          alignItems: "center",
          gap: "medium",
          isHidden: {
            below: 'tablet'
          },
          children: [/*#__PURE__*/jsx(Avatar, {
            src: user.avatarUrl,
            name: (_user$name = user.name) !== null && _user$name !== void 0 ? _user$name : undefined,
            size: "large"
          }), /*#__PURE__*/jsxs(Heading, {
            size: "medium",
            elementType: "p",
            UNSAFE_style: {
              fontWeight: tokenSchema.typography.fontWeight.bold
            },
            children: ["Hello, ", (_user$name2 = user.name) !== null && _user$name2 !== void 0 ? _user$name2 : user.login, "!"]
          })]
        }), /*#__PURE__*/jsx(BranchSection, {
          config: props.config
        }), /*#__PURE__*/jsx(CollectionSection, {
          basePath: props.basePath,
          config: props.config
        }), /*#__PURE__*/jsx(SingletonSection, {
          basePath: props.basePath,
          config: props.config
        })]
      })
    })]
  });
}

const TopBar = () => {
  let config = useConfig();
  if (isCloudConfig(config)) {
    return /*#__PURE__*/jsx(CloudHeader, {
      config: config
    });
  }
  if (isGitHubConfig(config)) {
    return /*#__PURE__*/jsx(GithubHeader, {
      config: config
    });
  }
  if (isLocalConfig(config)) {
    return /*#__PURE__*/jsx(LocalHeader, {});
  }
  throw new Error('Unknown config type.');
};

// Cloud
// -----------------------------------------------------------------------------

function CloudHeader({
  config
}) {
  return /*#__PURE__*/jsxs(HeaderOuter, {
    children: [/*#__PURE__*/jsx(BrandButton, {}), /*#__PURE__*/jsx(Text, {
      color: "neutralEmphasis",
      weight: "semibold",
      marginX: "regular",
      truncate: true,
      isHidden: {
        below: 'tablet'
      },
      children: config.cloud.project
    }), /*#__PURE__*/jsx(Slash, {}), /*#__PURE__*/jsx(BranchPicker, {}), /*#__PURE__*/jsx(GitMenu, {}), /*#__PURE__*/jsx(Box, {
      flex: "1"
    }), /*#__PURE__*/jsx(ThemeMenu, {})]
  });
}

// Github
// -----------------------------------------------------------------------------

function GithubHeader({
  config
}) {
  return /*#__PURE__*/jsxs(HeaderOuter, {
    children: [/*#__PURE__*/jsx(BrandButton, {}), /*#__PURE__*/jsx(Button, {
      href: `https://github.com/${serializeRepoConfig(config.storage.repo)}`,
      target: "_blank",
      rel: "noopener noreferrer",
      prominence: "low",
      isHidden: {
        below: 'tablet'
      },
      UNSAFE_className: css({
        paddingInline: tokenSchema.size.space.regular
      }),
      children: serializeRepoConfig(config.storage.repo)
    }), /*#__PURE__*/jsx(Slash, {}), /*#__PURE__*/jsx(BranchPicker, {}), /*#__PURE__*/jsx(GitMenu, {}), /*#__PURE__*/jsx(Box, {
      flex: "1"
    }), /*#__PURE__*/jsx(ThemeMenu, {}), /*#__PURE__*/jsx(UserMenu, {})]
  });
}

// Local
// -----------------------------------------------------------------------------

function LocalHeader() {
  return /*#__PURE__*/jsxs(HeaderOuter, {
    children: [/*#__PURE__*/jsx(BrandButton, {}), /*#__PURE__*/jsx(Text, {
      color: "neutralEmphasis",
      weight: "semibold",
      children: "Keystatic"
    }), /*#__PURE__*/jsx(Box, {
      flex: "1"
    }), /*#__PURE__*/jsx(ThemeMenu, {})]
  });
}

// =============================================================================
// Misc.
// =============================================================================

function BrandButton() {
  let {
    basePath
  } = useAppState();
  return /*#__PURE__*/jsx(Button, {
    "aria-label": "dashboard",
    prominence: "low",
    href: basePath,
    UNSAFE_style: {
      marginInlineStart: `calc(${tokenSchema.size.space.regular} * -1)`,
      padding: 0
    },
    children: /*#__PURE__*/jsx(ZapLogo, {})
  });
}
function Slash() {
  return /*#__PURE__*/jsx(Text, {
    "aria-hidden": true,
    color: "neutralTertiary",
    role: "presentation",
    isHidden: {
      below: 'tablet'
    },
    UNSAFE_className: css({
      userSelect: 'none'
    }),
    children: "/"
  });
}
function HeaderOuter({
  children
}) {
  return /*#__PURE__*/jsx(Flex, {
    elementType: "header"
    // styles
    ,
    alignItems: "center",
    borderBottom: "muted",
    flexShrink: 0,
    gap: "small",
    height: {
      mobile: 'element.large',
      tablet: 'scale.700'
    },
    paddingX: {
      mobile: 'medium',
      tablet: 'xlarge'
    },
    paddingEnd: {
      desktop: 'xxlarge'
    },
    children: children
  });
}

// Theme controls
// -----------------------------------------------------------------------------

const THEME_MODE = {
  light: {
    icon: sunIcon,
    label: 'Light'
  },
  dark: {
    icon: moonIcon,
    label: 'Dark'
  },
  auto: {
    icon: monitorIcon,
    label: 'System'
  }
};
const themeItems = Object.entries(THEME_MODE).map(([id, {
  icon,
  label
}]) => ({
  id,
  icon,
  label
}));
function ThemeMenu() {
  let {
    theme,
    setTheme
  } = useThemeContext();
  let matchesDark = useMediaQuery('(prefers-color-scheme: dark)');
  let icon = THEME_MODE[theme].icon;
  if (theme === 'auto') {
    icon = matchesDark ? moonIcon : sunIcon;
  }
  return /*#__PURE__*/jsxs(MenuTrigger, {
    children: [/*#__PURE__*/jsx(ActionButton, {
      "aria-label": "Theme",
      prominence: "low",
      UNSAFE_className: css({
        borderRadius: '50%',
        padding: 0
      }),
      children: /*#__PURE__*/jsx(Icon, {
        src: icon
      })
    }), /*#__PURE__*/jsx(Menu, {
      items: themeItems,
      onSelectionChange: ([key]) => setTheme(key),
      disallowEmptySelection: true,
      selectedKeys: [theme],
      selectionMode: "single",
      children: item => /*#__PURE__*/jsxs(Item$3, {
        textValue: item.label,
        children: [/*#__PURE__*/jsx(Icon, {
          src: item.icon
        }), /*#__PURE__*/jsx(Text, {
          children: item.label
        })]
      })
    })]
  });
}

// User controls
// -----------------------------------------------------------------------------

function UserMenu() {
  var _user$name, _user$name2, _user$name3;
  let user = useViewer();
  let config = useConfig();
  const menuItems = useMemo(() => {
    let items = [{
      id: 'logout',
      label: 'Log out',
      icon: logOutIcon
    }];
    if (isCloudConfig(config)) {
      items.unshift({
        id: 'manage',
        label: 'Manage account',
        icon: userIcon
      });
    }
    return items;
  }, [config]);
  if (!user) {
    return null;
  }
  return /*#__PURE__*/jsxs(MenuTrigger, {
    children: [/*#__PURE__*/jsx(ActionButton, {
      "aria-label": "User menu",
      prominence: "low",
      UNSAFE_className: css({
        borderRadius: '50%',
        padding: 0
      }),
      children: /*#__PURE__*/jsx(Avatar, {
        src: user.avatarUrl,
        name: (_user$name = user.name) !== null && _user$name !== void 0 ? _user$name : undefined,
        size: "small"
      })
    }), /*#__PURE__*/jsxs(Fragment, {
      children: [/*#__PURE__*/jsxs(Flex, {
        borderBottom: "muted",
        gap: "regular",
        marginX: "regular",
        paddingY: "regular",
        paddingEnd: "xxlarge",
        alignItems: "center",
        UNSAFE_className: css({
          userSelect: 'none'
        }),
        "aria-hidden": true,
        children: [/*#__PURE__*/jsx(Avatar, {
          src: user.avatarUrl,
          name: (_user$name2 = user.name) !== null && _user$name2 !== void 0 ? _user$name2 : undefined,
          size: "small"
        }), /*#__PURE__*/jsxs(Flex, {
          direction: "column",
          gap: "small",
          children: [/*#__PURE__*/jsx(Text, {
            size: "small",
            weight: "semibold",
            color: "neutralEmphasis",
            children: (_user$name3 = user.name) !== null && _user$name3 !== void 0 ? _user$name3 : user.login
          }), /*#__PURE__*/jsx(Text, {
            size: "small",
            color: "neutralTertiary",
            children: user.login
          })]
        })]
      }), /*#__PURE__*/jsx(Menu, {
        items: menuItems,
        minWidth: "scale.2400",
        onAction: key => {
          switch (key) {
            case 'manage':
              openBlankTargetSafely('https://keystatic.cloud/account');
              break;
            case 'logout':
              switch (config.storage.kind) {
                case 'github':
                  window.location.href = '/api/keystatic/github/logout';
                  break;
                case 'cloud':
                  localStorage.removeItem('keystatic-cloud-access-token');
                  window.location.reload();
                  break;
              }
          }
        },
        children: item => /*#__PURE__*/jsxs(Item$3, {
          textValue: item.label,
          children: [/*#__PURE__*/jsx(Icon, {
            src: item.icon
          }), /*#__PURE__*/jsx(Text, {
            children: item.label
          })]
        })
      })]
    })]
  });
}

// Git controls
// -----------------------------------------------------------------------------

function GitMenu() {
  var _appShellData$data, _appShellData$data$re;
  const stringFormatter = useLocalizedStringFormatter(l10nMessages);
  const data = useContext(BranchInfoContext);
  const [newBranchDialogVisible, toggleNewBranchDialog] = useReducer(v => !v, false);
  const [deleteBranchDialogVisible, toggleDeleteBranchDialog] = useReducer(v => !v, false);
  const [, deleteBranch] = useMutation(gql`
      mutation DeleteBranch($refId: ID!) {
        deleteRef(input: { refId: $refId }) {
          __typename
        }
      }
    `);
  const appShellData = useContext(GitHubAppShellDataContext);
  const fork = (appShellData === null || appShellData === void 0 || (_appShellData$data = appShellData.data) === null || _appShellData$data === void 0 ? void 0 : _appShellData$data.repository) && 'forks' in appShellData.data.repository && ((_appShellData$data$re = appShellData.data.repository.forks.nodes) === null || _appShellData$data$re === void 0 ? void 0 : _appShellData$data$re[0]);
  const gitMenuItems = useMemo(() => {
    let isDefaultBranch = data.currentBranch === data.defaultBranch;
    let items = [];
    let branchSection = [{
      key: 'new-branch',
      icon: gitBranchPlusIcon,
      label: stringFormatter.format('newBranch')
    }];
    let prSection = [];
    let repoSection = [{
      key: 'repo',
      icon: githubIcon,
      label: 'Github repo' // TODO: l10n
    }];

    if (!isDefaultBranch) {
      prSection.push({
        key: 'create-pull-request',
        icon: gitPullRequestIcon,
        label: stringFormatter.format('createPullRequest')
      });
      if (!data.hasPullRequests) {
        branchSection.push({
          key: 'delete-branch',
          icon: trash2Icon,
          label: stringFormatter.format('deleteBranch')
        });
      }
    }
    if (data.hasPullRequests) {
      prSection.push({
        key: 'related-pull-requests',
        icon: listTodoIcon,
        label: stringFormatter.format('viewPullRequests')
      });
    }
    if (fork) {
      repoSection.push({
        key: 'fork',
        icon: gitForkIcon,
        label: 'View fork' // TODO: l10n
      });
    }

    if (branchSection.length) {
      items.push({
        key: 'branch-section',
        label: stringFormatter.format('branches'),
        children: branchSection
      });
    }
    if (prSection.length) {
      items.push({
        key: 'pr-section',
        label: stringFormatter.format('pullRequests'),
        children: prSection
      });
    }
    if (repoSection.length) {
      items.push({
        key: 'repo-section',
        label: 'Repository',
        // TODO: l10n
        children: repoSection
      });
    }
    return items;
  }, [fork, data.currentBranch, data.defaultBranch, data.hasPullRequests, stringFormatter]);
  const router = useRouter();
  return /*#__PURE__*/jsxs(Fragment, {
    children: [/*#__PURE__*/jsx(ActionMenu, {
      "aria-label": "git actions",
      prominence: "low",
      items: gitMenuItems,
      onAction: key => {
        let repoURL = getRepoUrl(data);
        switch (key) {
          case 'new-branch':
            toggleNewBranchDialog();
            break;
          case 'delete-branch':
            {
              toggleDeleteBranchDialog();
              break;
            }
          case 'related-pull-requests':
            let query = [['is', 'pr'], ['is', 'open'], ['head', data.currentBranch]].map(([key, value]) => encodeURIComponent(`${key}:${value}`)).join('+');
            openBlankTargetSafely(`${repoURL}/pulls?q=${query}`);
            break;
          case 'create-pull-request':
            openBlankTargetSafely(`${repoURL}/pull/new/${data.currentBranch}`);
            break;
          case 'repo':
            openBlankTargetSafely(repoURL);
            break;
          case 'fork':
            assert(!!fork);
            openBlankTargetSafely(`https://github.com/${fork.owner.login}/${fork.name}`);
        }
      },
      children: item => /*#__PURE__*/jsx(Section, {
        items: item.children,
        "aria-label": item.label,
        children: item => /*#__PURE__*/jsxs(Item$3, {
          textValue: item.label,
          children: [/*#__PURE__*/jsx(Icon, {
            src: item.icon
          }), /*#__PURE__*/jsx(Text, {
            children: item.label
          })]
        }, item.key)
      }, item.key)
    }), /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: toggleNewBranchDialog,
      children: newBranchDialogVisible && /*#__PURE__*/jsx(CreateBranchDialog, {
        onDismiss: toggleNewBranchDialog,
        onCreate: branchName => {
          toggleNewBranchDialog();
          router.push(router.href.replace(/\/branch\/[^/]+/, '/branch/' + encodeURIComponent(branchName)));
        }
      })
    }), /*#__PURE__*/jsx(DialogContainer, {
      onDismiss: toggleDeleteBranchDialog,
      children: deleteBranchDialogVisible && /*#__PURE__*/jsxs(AlertDialog, {
        title: "Delete branch",
        tone: "critical",
        cancelLabel: "Cancel",
        primaryActionLabel: "Yes, delete",
        autoFocusButton: "cancel",
        onPrimaryAction: async () => {
          await deleteBranch({
            refId: data.branchNameToId.get(data.currentBranch)
          });
          router.push(router.href.replace(/\/branch\/[^/]+/, '/branch/' + encodeURIComponent(data.defaultBranch)));
        },
        children: ["Are you sure you want to delete the \"", data.currentBranch, "\" branch? This cannot be undone."]
      })
    })]
  });
}

// ============================================================================
// Utils
// ============================================================================

function openBlankTargetSafely(url) {
  window.open(url, '_blank', 'noopener,noreferrer');
}

const MainPanelLayout = props => {
  let {
    basePath,
    children,
    config
  } = props;
  let isBelowDesktop = useMediaQuery(breakpointQueries.below.desktop);
  let sidebarState = useSidebar();
  let ref = useRef(null);
  let context = useContentPanelState(ref);
  return /*#__PURE__*/jsx(ContentPanelProvider, {
    value: context,
    children: /*#__PURE__*/jsxs(SplitView, {
      autoSaveId: "keystatic-app-split-view",
      isCollapsed: isBelowDesktop || !sidebarState.isOpen,
      onCollapseChange: sidebarState.toggle,
      defaultSize: 260,
      minSize: 180,
      maxSize: 400,
      flex: true,
      children: [isBelowDesktop ? /*#__PURE__*/jsx(SidebarDialog, {
        hrefBase: basePath,
        config: config
      }) : /*#__PURE__*/jsx(SplitPanePrimary, {
        children: /*#__PURE__*/jsx(SidebarPanel, {
          hrefBase: basePath,
          config: config
        })
      }), /*#__PURE__*/jsx(SplitPaneSecondary, {
        ref: ref,
        children: children
      })]
    })
  });
};

const AppShell = props => {
  const content = /*#__PURE__*/jsx(AppShellErrorContext.Consumer, {
    children: error => error && !(error !== null && error !== void 0 && error.graphQLErrors.some(err => {
      var _err$originalError;
      return (err === null || err === void 0 || (_err$originalError = err.originalError) === null || _err$originalError === void 0 ? void 0 : _err$originalError.type) === 'NOT_FOUND';
    })) ? /*#__PURE__*/jsx(EmptyState, {
      icon: alertCircleIcon,
      title: "Failed to load shell",
      message: error.message
    }) : props.children
  });
  const inner = /*#__PURE__*/jsx(ConfigContext.Provider, {
    value: props.config,
    children: /*#__PURE__*/jsx(AppStateContext.Provider, {
      value: {
        basePath: props.basePath
      },
      children: /*#__PURE__*/jsx(SidebarProvider, {
        children: /*#__PURE__*/jsxs(Flex, {
          direction: "column",
          height: "100vh",
          children: [/*#__PURE__*/jsx(TopBar, {}), /*#__PURE__*/jsx(MainPanelLayout, {
            basePath: props.basePath,
            config: props.config,
            children: content
          })]
        })
      })
    })
  });
  if (isGitHubConfig(props.config) || props.config.storage.kind === 'cloud') {
    return /*#__PURE__*/jsx(GitHubAppShellProvider, {
      currentBranch: props.currentBranch,
      config: props.config,
      children: inner
    });
  }
  if (isLocalConfig(props.config)) {
    return /*#__PURE__*/jsx(LocalAppShellProvider, {
      config: props.config,
      children: inner
    });
  }
  return null;
};

function SingletonPage({
  singleton,
  initialFiles,
  initialState,
  localTreeKey,
  config,
  currentTree
}) {
  const [forceValidation, setForceValidation] = useState(false);
  const singletonConfig = config.singletons[singleton];
  const schema = useMemo(() => object(singletonConfig.schema), [singletonConfig.schema]);
  const singletonPath = getSingletonPath(config, singleton);
  const router = useRouter();
  const [{
    state,
    localTreeKey: localTreeKeyInState
  }, setState] = useState(() => ({
    localTreeKey: localTreeKey,
    state: initialState === null ? getInitialPropsValue(schema) : initialState
  }));
  if (localTreeKeyInState !== localTreeKey) {
    setState({
      localTreeKey: localTreeKey,
      state: initialState === null ? getInitialPropsValue(schema) : initialState
    });
  }
  const isCreating = initialState === null;
  const hasChanged = useHasChanged({
    initialState,
    state,
    schema,
    slugField: undefined
  }) || isCreating;
  const previewProps = useMemo(() => createGetPreviewProps(schema, stateUpdater => {
    setState(state => ({
      localTreeKey: state.localTreeKey,
      state: stateUpdater(state.state)
    }));
  }, () => undefined), [schema])(state);
  const baseCommit = useBaseCommit();
  const formatInfo = getSingletonFormat(config, singleton);
  const [updateResult, _update, resetUpdateItem] = useUpsertItem({
    state,
    initialFiles,
    config,
    schema: singletonConfig.schema,
    basePath: singletonPath,
    format: formatInfo,
    currentLocalTreeKey: localTreeKey,
    currentTree,
    slug: undefined
  });
  const update = useEventCallback(_update);
  const onCreate = async () => {
    if (!clientSideValidateProp(schema, state, undefined)) {
      setForceValidation(true);
      return;
    }
    await update();
  };
  const formID = 'singleton-form';
  return /*#__PURE__*/jsxs(PageRoot, {
    containerWidth: containerWidthForEntryLayout(singletonConfig),
    children: [/*#__PURE__*/jsxs(PageHeader, {
      children: [/*#__PURE__*/jsxs(Flex, {
        alignItems: "center",
        gap: "regular",
        children: [/*#__PURE__*/jsx(Heading, {
          elementType: "h1",
          id: "page-title",
          size: "small",
          children: singletonConfig.label
        }), updateResult.kind === 'loading' ? /*#__PURE__*/jsx(ProgressCircle, {
          "aria-label": `Updating ${singletonConfig.label}`,
          isIndeterminate: true,
          size: "small",
          alignSelf: "center"
        }) : hasChanged && /*#__PURE__*/jsx(Badge, {
          tone: "pending",
          children: "Unsaved"
        })]
      }), /*#__PURE__*/jsxs(ButtonGroup, {
        marginStart: "auto",
        children: [/*#__PURE__*/jsxs(Button, {
          "aria-label": "Reset"
          // prominence="low"
          ,
          isDisabled: updateResult.kind === 'loading' || !hasChanged,
          onPress: () => {
            setState({
              localTreeKey: localTreeKey,
              state: initialState === null ? getInitialPropsValue(schema) : initialState
            });
          },
          children: [/*#__PURE__*/jsx(Icon, {
            isHidden: {
              above: 'mobile'
            },
            src: refreshCwIcon
          }), /*#__PURE__*/jsx(Text, {
            isHidden: {
              below: 'tablet'
            },
            children: "Reset"
          })]
        }), /*#__PURE__*/jsx(Button, {
          form: formID,
          isDisabled: updateResult.kind === 'loading',
          prominence: "high",
          type: "submit",
          children: isCreating ? 'Create' : 'Save'
        })]
      })]
    }), /*#__PURE__*/jsxs(Flex, {
      elementType: "form",
      id: formID,
      onSubmit: event => {
        if (event.target !== event.currentTarget) return;
        event.preventDefault();
        onCreate();
      },
      direction: "column",
      gap: "xxlarge",
      height: "100%",
      minHeight: 0,
      minWidth: 0,
      children: [updateResult.kind === 'error' && /*#__PURE__*/jsx(Notice, {
        tone: "critical",
        children: updateResult.error.message
      }), /*#__PURE__*/jsx(FormForEntry, {
        previewProps: previewProps,
        forceValidation: forceValidation,
        entryLayout: singletonConfig.entryLayout,
        formatInfo: formatInfo,
        slugField: undefined
      }), /*#__PURE__*/jsx(DialogContainer
      // ideally this would be a popover on desktop but using a DialogTrigger wouldn't work since
      // this doesn't open on click but after doing a network request and it failing and manually wiring about a popover and modal would be a pain
      , {
        onDismiss: resetUpdateItem,
        children: updateResult.kind === 'needs-new-branch' && /*#__PURE__*/jsx(CreateBranchDuringUpdateDialog, {
          branchOid: baseCommit,
          onCreate: async newBranch => {
            router.push(`/keystatic/branch/${encodeURIComponent(newBranch)}/singleton/${encodeURIComponent(singleton)}`);
            update({
              branch: newBranch,
              sha: baseCommit
            });
          },
          reason: updateResult.reason,
          onDismiss: resetUpdateItem
        })
      }), /*#__PURE__*/jsx(DialogContainer
      // ideally this would be a popover on desktop but using a DialogTrigger
      // wouldn't work since this doesn't open on click but after doing a
      // network request and it failing and manually wiring about a popover
      // and modal would be a pain
      , {
        onDismiss: resetUpdateItem,
        children: updateResult.kind === 'needs-fork' && isGitHubConfig(config) && /*#__PURE__*/jsx(ForkRepoDialog, {
          onCreate: async () => {
            update();
          },
          onDismiss: resetUpdateItem,
          config: config
        })
      })]
    })]
  });
}
function SingletonPageWrapper(props) {
  var _props$config$singlet;
  const singletonConfig = (_props$config$singlet = props.config.singletons) === null || _props$config$singlet === void 0 ? void 0 : _props$config$singlet[props.singleton];
  if (!singletonConfig) notFound();
  const header = /*#__PURE__*/jsx(PageHeader, {
    children: /*#__PURE__*/jsx(Heading, {
      elementType: "h1",
      id: "page-title",
      size: "small",
      children: singletonConfig.label
    })
  });
  const format = useMemo(() => getSingletonFormat(props.config, props.singleton), [props.config, props.singleton]);
  const itemData = useItemData({
    config: props.config,
    dirpath: getSingletonPath(props.config, props.singleton),
    schema: props.config.singletons[props.singleton].schema,
    format,
    slug: undefined
  });
  const {
    current: tree
  } = useTree();
  const combined = useMemo(() => mergeDataStates({
    tree,
    item: itemData
  }), [itemData, tree]);
  if (combined.kind === 'error') {
    return /*#__PURE__*/jsxs(PageRoot, {
      children: [header, /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Notice, {
          margin: "xxlarge",
          tone: "critical",
          children: combined.error.message
        })
      })]
    });
  }
  if (combined.kind === 'loading') {
    return /*#__PURE__*/jsxs(PageRoot, {
      children: [header, /*#__PURE__*/jsx(PageBody, {
        children: /*#__PURE__*/jsx(Flex, {
          alignItems: "center",
          justifyContent: "center",
          minHeight: "scale.3000",
          children: /*#__PURE__*/jsx(ProgressCircle, {
            "aria-label": `Loading ${singletonConfig.label}`,
            isIndeterminate: true,
            size: "large"
          })
        })
      })]
    });
  }
  return /*#__PURE__*/jsx(SingletonPage, {
    singleton: props.singleton,
    config: props.config,
    initialState: combined.data.item === 'not-found' ? null : combined.data.item.initialState,
    initialFiles: combined.data.item === 'not-found' ? [] : combined.data.item.initialFiles,
    localTreeKey: combined.data.item === 'not-found' ? undefined : combined.data.item.localTreeKey,
    currentTree: combined.data.tree.tree
  });
}

function FromTemplateDeploy(props) {
  useEffect(() => {
    const parsedCookies = cookie.parse(document.cookie);
    const repo = serializeRepoConfig(props.config.storage.repo);
    const cookieName = 'ks-template';
    if (parsedCookies[cookieName] !== repo) {
      document.cookie = cookie.serialize(cookieName, repo, {
        path: '/',
        maxAge: 60 * 60 * 24 * 30,
        expires: new Date(Date.now() + 60 * 60 * 24 * 30 * 1000),
        secure: true,
        sameSite: 'lax'
      });
    }
  }, [props.config.storage.repo]);
  return /*#__PURE__*/jsx(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: /*#__PURE__*/jsxs(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      children: [/*#__PURE__*/jsx(Heading, {
        children: "You've deployed Keystatic! \uD83C\uDF89"
      }), /*#__PURE__*/jsx(Text, {
        children: "To start using Keystatic, you need to install the GitHub app you've created."
      }), /*#__PURE__*/jsxs(Text, {
        children: ["Make sure to add the App to the", ' ', /*#__PURE__*/jsx("code", {
          children: serializeRepoConfig(props.config.storage.repo)
        }), ' ', "repository."]
      }), /*#__PURE__*/jsx(InstallGitHubApp, {
        config: props.config
      })]
    })
  });
}

function CreatedGitHubApp(props) {
  return /*#__PURE__*/jsx(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: /*#__PURE__*/jsxs(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      children: [/*#__PURE__*/jsx(Heading, {
        children: "You've installed Keystatic! \uD83C\uDF89"
      }), /*#__PURE__*/jsx(Text, {
        children: "To start using Keystatic, you need to install the GitHub app you've created."
      }), /*#__PURE__*/jsxs(Text, {
        children: ["Make sure to add the App to the", ' ', /*#__PURE__*/jsx("code", {
          children: serializeRepoConfig(props.config.storage.repo)
        }), ' ', "repository."]
      }), /*#__PURE__*/jsx(InstallGitHubApp, {
        config: props.config
      })]
    })
  });
}

function KeystaticSetup(props) {
  const [deployedURL, setDeployedURL] = useState('');
  const [organization, setOrganization] = useState('');
  return /*#__PURE__*/jsx(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: /*#__PURE__*/jsxs(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      elementType: "form",
      action: `https://github.com${organization ? `/organizations/${organization}` : ''}/settings/apps/new`,
      method: "post",
      children: [/*#__PURE__*/jsx(Flex, {
        justifyContent: "center",
        children: /*#__PURE__*/jsx(Heading, {
          children: "Keystatic Setup"
        })
      }), /*#__PURE__*/jsx(Text, {
        children: "Keystatic doesn't have the required config."
      }), /*#__PURE__*/jsx(Text, {
        children: "If you've already created your GitHub app, make sure to add the following environment variables:"
      }), /*#__PURE__*/jsxs(Box, {
        elementType: "ul",
        children: [/*#__PURE__*/jsx("li", {
          children: /*#__PURE__*/jsx("code", {
            children: "KEYSTATIC_GITHUB_CLIENT_ID"
          })
        }), /*#__PURE__*/jsx("li", {
          children: /*#__PURE__*/jsx("code", {
            children: "KEYSTATIC_GITHUB_CLIENT_SECRET"
          })
        }), /*#__PURE__*/jsx("li", {
          children: /*#__PURE__*/jsx("code", {
            children: "KEYSTATIC_SECRET"
          })
        })]
      }), /*#__PURE__*/jsx(Text, {
        children: "If you haven't created your GitHub app for Keystatic, you can create one below."
      }), /*#__PURE__*/jsx(TextField, {
        label: "Deployed App URL",
        description: "This should the root of your domain. If you're not sure where Keystatic will be deployed, leave this blank and you can update the GitHub app later.",
        value: deployedURL,
        onChange: setDeployedURL
      }), /*#__PURE__*/jsx(TextField, {
        label: "GitHub organization (if any)",
        description: "You must be an owner or GitHub App manager in the organization to create the GitHub App. Leave this blank to create the app in your personal account.",
        value: organization,
        onChange: setOrganization
      }), /*#__PURE__*/jsxs(Text, {
        children: ["After visiting GitHub to create the GitHub app, you'll be redirected back here and secrets generated from GitHub will be written to your", ' ', /*#__PURE__*/jsx("code", {
          children: ".env"
        }), " file."]
      }), /*#__PURE__*/jsx("input", {
        type: "text",
        name: "manifest",
        className: css({
          display: 'none'
        }),
        value: JSON.stringify({
          name: `${parseRepoConfig(props.config.storage.repo).owner} Keystatic`,
          url: deployedURL ? `${deployedURL}/keystatic` : `${window.location.origin}/keystatic`,
          public: true,
          redirect_url: `${window.location.origin}/api/keystatic/github/created-app`,
          callback_urls: [`${window.location.origin}/api/keystatic/github/oauth/callback`, `http://127.0.0.1/api/keystatic/github/oauth/callback`, ...(deployedURL ? [`${deployedURL}/api/keystatic/github/oauth/callback`] : [])],
          request_oauth_on_install: true,
          default_permissions: {
            contents: 'write',
            metadata: 'read',
            pull_requests: 'read'
          }
        })
      }), /*#__PURE__*/jsx(Button, {
        prominence: "high",
        type: "submit",
        children: "Create GitHub App"
      })]
    })
  });
}

function RepoNotFound(props) {
  const repo = serializeRepoConfig(props.config.storage.repo);
  return /*#__PURE__*/jsx(Flex, {
    alignItems: "center",
    justifyContent: "center",
    margin: "xxlarge",
    children: /*#__PURE__*/jsxs(Flex, {
      backgroundColor: "surface",
      padding: "large",
      border: "color.alias.borderIdle",
      borderRadius: "medium",
      direction: "column",
      justifyContent: "center",
      gap: "xlarge",
      maxWidth: "scale.4600",
      children: [/*#__PURE__*/jsx(Flex, {
        justifyContent: "center",
        children: /*#__PURE__*/jsx(Heading, {
          children: "Repo not found"
        })
      }), /*#__PURE__*/jsxs(Text, {
        children: ["Keystatic is configured for the", ' ', /*#__PURE__*/jsx("a", {
          href: `https://github.com/${repo}`,
          children: repo
        }), " GitHub repo but Keystatic isn't able to access this repo. This is either because you don't have access to this repo or you haven't added the GitHub app to it."]
      }), /*#__PURE__*/jsx(InstallGitHubApp, {
        config: props.config
      })]
    })
  });
}

const storedStateSchema = z.object({
  state: z.string(),
  from: z.string(),
  code_verifier: z.string()
});
const tokenResponseSchema = z.object({
  access_token: z.string(),
  token_type: z.string(),
  expires_in: z.number()
});
function KeystaticCloudAuthCallback({
  config
}) {
  const router = useRouter();
  const url = new URL(window.location.href);
  const code = url.searchParams.get('code');
  const state = url.searchParams.get('state');
  const storedState = useMemo(() => {
    const _storedState = localStorage.getItem('keystatic-cloud-state');
    const storedState = storedStateSchema.safeParse((() => {
      try {
        return JSON.parse(_storedState || '');
      } catch {
        return null;
      }
    })());
    return storedState;
  }, []);
  const [error, setError] = useState(null);
  useEffect(() => {
    if (code && state && storedState.success && isCloudConfig(config)) {
      (async () => {
        const res = await fetch(`${KEYSTATIC_CLOUD_API_URL}/oauth/token`, {
          method: 'POST',
          body: new URLSearchParams({
            code,
            client_id: config.cloud.project,
            redirect_uri: `${window.location.origin}/keystatic/cloud/oauth/callback`,
            code_verifier: storedState.data.code_verifier,
            grant_type: 'authorization_code'
          }).toString(),
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
            ...KEYSTATIC_CLOUD_HEADERS
          }
        });
        if (!res.ok) {
          throw new Error(`Bad response: ${res.status} ${res.statusText}\n\n${await res.text()}`);
        }
        const data = await res.json();
        const parsed = tokenResponseSchema.parse(data);
        localStorage.setItem('keystatic-cloud-access-token', JSON.stringify({
          token: parsed.access_token,
          validUntil: Date.now() + parsed.expires_in * 1000
        }));
        router.push(`/keystatic/${storedState.data.from}`);
      })().catch(error => {
        setError(error);
      });
    }
  }, [code, state, router, storedState, config]);
  if (config.storage.kind !== 'cloud') {
    return /*#__PURE__*/jsx(Text, {
      children: "Missing Keystatic Cloud config"
    });
  }
  if (!code || !state) {
    return /*#__PURE__*/jsx(Text, {
      children: "Missing code or state"
    });
  }
  if (storedState.success === false || state !== storedState.data.state) {
    return /*#__PURE__*/jsx(Text, {
      children: "Invalid state"
    });
  }
  if (error) {
    return /*#__PURE__*/jsx(Text, {
      children: error.message
    });
  }
  return /*#__PURE__*/jsx("div", {
    children: /*#__PURE__*/jsx(ProgressCircle, {
      isIndeterminate: true,
      "aria-label": "Authenticating"
    })
  });
}

function parseParamsWithoutBranch(params) {
  if (params.length === 0) {
    return {};
  }
  if (params.length === 2 && params[0] === 'singleton') {
    return {
      singleton: params[1]
    };
  }
  if (params.length < 2 || params[0] !== 'collection') return null;
  const collection = params[1];
  if (params.length === 2) {
    return {
      collection
    };
  }
  if (params.length === 3 && params[2] === 'create') {
    return {
      collection,
      kind: 'create'
    };
  }
  if (params.length === 4 && params[2] === 'item') {
    const slug = params[3];
    return {
      collection,
      kind: 'edit',
      slug
    };
  }
  return null;
}
function RedirectToBranch(props) {
  const {
    push
  } = useRouter();
  const {
    data,
    error
  } = useContext(GitHubAppShellDataContext);
  useEffect(() => {
    var _error$response, _data$repository, _data$repository2, _error$graphQLErrors, _error$graphQLErrors2;
    if ((error === null || error === void 0 || (_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401) {
      if (props.config.storage.kind === 'github') {
        window.location.href = '/api/keystatic/github/login';
      } else {
        redirectToCloudAuth('', props.config);
      }
    }
    if (data !== null && data !== void 0 && (_data$repository = data.repository) !== null && _data$repository !== void 0 && _data$repository.defaultBranchRef) {
      push(`/keystatic/branch/${encodeURIComponent(data.repository.defaultBranchRef.name)}`);
    }
    if (props.config.storage.kind === 'github' && !(data !== null && data !== void 0 && (_data$repository2 = data.repository) !== null && _data$repository2 !== void 0 && _data$repository2.id) && (error === null || error === void 0 || (_error$graphQLErrors = error.graphQLErrors) === null || _error$graphQLErrors === void 0 || (_error$graphQLErrors = _error$graphQLErrors[0]) === null || _error$graphQLErrors === void 0 || (_error$graphQLErrors = _error$graphQLErrors.originalError) === null || _error$graphQLErrors === void 0 ? void 0 : _error$graphQLErrors.type) === 'NOT_FOUND' || (error === null || error === void 0 || (_error$graphQLErrors2 = error.graphQLErrors) === null || _error$graphQLErrors2 === void 0 || (_error$graphQLErrors2 = _error$graphQLErrors2[0]) === null || _error$graphQLErrors2 === void 0 || (_error$graphQLErrors2 = _error$graphQLErrors2.originalError) === null || _error$graphQLErrors2 === void 0 ? void 0 : _error$graphQLErrors2.type) === 'FORBIDDEN') {
      window.location.href = '/api/keystatic/github/repo-not-found';
    }
  }, [data, error, push, props.config]);
  return null;
}
function PageInner({
  config
}) {
  const {
    params
  } = useRouter();
  let branch = null,
    parsedParams,
    basePath;
  if (config.storage.kind === 'cloud' && params.join('/') === 'cloud/oauth/callback') {
    return /*#__PURE__*/jsx(KeystaticCloudAuthCallback, {
      config: config
    });
  }
  let wrapper = x => x;
  if (isGitHubConfig(config) || isCloudConfig(config)) {
    wrapper = element => /*#__PURE__*/jsx(AuthWrapper, {
      config: config,
      children: /*#__PURE__*/jsx(GitHubAppShellDataProvider, {
        config: config,
        children: element
      })
    });
    if (params.length === 0) {
      return wrapper( /*#__PURE__*/jsx(RedirectToBranch, {
        config: config
      }));
    }
    if (params.length === 1 && isGitHubConfig(config)) {
      if (params[0] === 'setup') return /*#__PURE__*/jsx(KeystaticSetup, {
        config: config
      });
      if (params[0] === 'repo-not-found') {
        return /*#__PURE__*/jsx(RepoNotFound, {
          config: config
        });
      }
      if (params[0] === 'from-template-deploy') {
        return /*#__PURE__*/jsx(FromTemplateDeploy, {
          config: config
        });
      }
      if (params[0] === 'created-github-app') {
        return /*#__PURE__*/jsx(CreatedGitHubApp, {
          config: config
        });
      }
    }
    if (params[0] !== 'branch' || params.length < 2) {
      return /*#__PURE__*/jsx(Text, {
        children: "Not found"
      });
    }
    branch = params[1];
    basePath = `/keystatic/branch/${encodeURIComponent(branch)}`;
    parsedParams = parseParamsWithoutBranch(params.slice(2));
  } else {
    parsedParams = parseParamsWithoutBranch(params);
    basePath = '/keystatic';
  }
  return wrapper( /*#__PURE__*/jsx(AppShell, {
    config: config,
    currentBranch: branch || '',
    basePath: basePath,
    children: /*#__PURE__*/jsx(NotFoundBoundary, {
      fallback: /*#__PURE__*/jsx(PageRoot, {
        children: /*#__PURE__*/jsx(PageBody, {
          children: /*#__PURE__*/jsx(EmptyState, {
            icon: fileX2Icon,
            title: "Not found",
            message: "This page could not be found."
          })
        })
      }),
      children: parsedParams === null ? /*#__PURE__*/jsx(AlwaysNotFound, {}) : parsedParams.collection ? parsedParams.kind === 'create' ? /*#__PURE__*/jsx(CreateItem, {
        collection: parsedParams.collection,
        config: config,
        basePath: basePath
      }, parsedParams.collection) : parsedParams.kind === 'edit' ? /*#__PURE__*/jsx(ItemPageWrapper, {
        collection: parsedParams.collection,
        basePath: basePath,
        config: config,
        itemSlug: parsedParams.slug
      }, parsedParams.collection) : /*#__PURE__*/jsx(CollectionPage, {
        basePath: basePath,
        collection: parsedParams.collection,
        config: config
      }, parsedParams.collection) : parsedParams.singleton ? /*#__PURE__*/jsx(SingletonPageWrapper, {
        config: config,
        singleton: parsedParams.singleton
      }, parsedParams.singleton) : /*#__PURE__*/jsx(DashboardPage, {
        config: config,
        basePath: basePath
      })
    })
  }));
}
function AlwaysNotFound() {
  notFound();
}
function AuthWrapper(props) {
  const [state, setState] = useState('unknown');
  const router = useRouter();
  useEffect(() => {
    getAuth(props.config).then(auth => {
      if (auth) {
        setState('valid');
        return;
      }
      setState('explicit-auth');
    });
  }, [props.config]);
  if (state === 'valid') {
    return props.children;
  }
  if (state === 'explicit-auth') {
    if (props.config.storage.kind === 'github') {
      return /*#__PURE__*/jsx(Flex, {
        justifyContent: "center",
        alignItems: "center",
        height: "100vh",
        children: /*#__PURE__*/jsx(LinkComponentContext.Provider, {
          value: DefaultLinkComponent,
          children: /*#__PURE__*/jsxs(Button, {
            href: `/api/keystatic/github/login${router.params.length ? `?${new URLSearchParams({
              from: router.params.join('/')
            })}` : ''}`,
            children: [/*#__PURE__*/jsx(Icon, {
              src: githubIcon
            }), /*#__PURE__*/jsx(Text, {
              children: "Log in with GitHub"
            })]
          })
        })
      });
    }
    if (props.config.storage.kind === 'cloud') {
      return /*#__PURE__*/jsx(Flex, {
        justifyContent: "center",
        alignItems: "center",
        height: "100vh",
        children: /*#__PURE__*/jsx(Button, {
          onPress: () => {
            redirectToCloudAuth(router.params.join('/'), props.config);
          },
          children: /*#__PURE__*/jsx(Text, {
            children: "Log in with Keystatic Cloud"
          })
        })
      });
    }
  }
  return null;
}
function Keystatic(props) {
  if (props.config.storage.kind === 'github') {
    assertValidRepoConfig(props.config.storage.repo);
  }
  useEffect(() => {
    if (window.location.hostname === 'localhost') {
      window.location.href = window.location.href.replace('localhost', '127.0.0.1');
    }
  }, []);
  if (window.location.hostname === 'localhost') {
    return null;
  }
  return /*#__PURE__*/jsx(AppSlugProvider, {
    value: props.appSlug,
    children: /*#__PURE__*/jsx(RouterProvider, {
      router: props.router,
      children: /*#__PURE__*/jsx(Provider, {
        config: props.config,
        Link: props.link,
        children: /*#__PURE__*/jsx(PageInner, {
          config: props.config
        })
      })
    })
  });
}

export { Keystatic };
