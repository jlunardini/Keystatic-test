'use strict';

var index = require('./index-8044c959.node.cjs.js');
var numberField = require('@keystar/ui/number-field');
var React = require('react');
var jsxRuntime = require('react/jsx-runtime');
var slateReact = require('slate-react');
var overlays = require('@react-stately/overlays');
var button = require('@keystar/ui/button');
var dialog = require('@keystar/ui/dialog');
var icon = require('@keystar/ui/icon');
var imageIcon = require('@keystar/ui/icon/icons/imageIcon');
var link2Icon = require('@keystar/ui/icon/icons/link2Icon');
var link2OffIcon = require('@keystar/ui/icon/icons/link2OffIcon');
var pencilIcon = require('@keystar/ui/icon/icons/pencilIcon');
var trash2Icon = require('@keystar/ui/icon/icons/trash2Icon');
var undo2Icon = require('@keystar/ui/icon/icons/undo2Icon');
var layout = require('@keystar/ui/layout');
var link = require('@keystar/ui/link');
var progress = require('@keystar/ui/progress');
var slots = require('@keystar/ui/slots');
var textField = require('@keystar/ui/text-field');
var tooltip = require('@keystar/ui/tooltip');
var typography = require('@keystar/ui/typography');
var utils = require('@keystar/ui/utils');
require('@keystar/ui/checkbox');
require('emery');
require('@keystar/ui/field');
require('@keystar/ui/style');
require('@keystar/ui/combobox');
require('minimatch');
require('@react-stately/collections');
require('@keystar/ui/picker');
require('@sindresorhus/slugify');
require('@braintree/sanitize-url');
require('@react-aria/i18n');
require('@keystar/ui/drag-and-drop');
require('@keystar/ui/list-view');
require('@keystar/ui/menu');

function validateInteger(validation, value, label) {
  if (value !== null && (typeof value !== 'number' || !Number.isFinite(value))) {
    return `${label} is not a valid whole number`;
  }
  if (validation !== null && validation !== void 0 && validation.isRequired && value === null) {
    return `${label} is required`;
  }
  if (value !== null) {
    if ((validation === null || validation === void 0 ? void 0 : validation.min) !== undefined && value < validation.min) {
      return `${label} must be at least ${validation.min}`;
    }
    if ((validation === null || validation === void 0 ? void 0 : validation.max) !== undefined && value > validation.max) {
      return `${label} must be at most ${validation.max}`;
    }
  }
}

function IntegerFieldInput(props) {
  const [blurred, onBlur] = React.useReducer(() => true, false);
  return /*#__PURE__*/jsxRuntime.jsx(numberField.NumberField, {
    label: props.label,
    description: props.description,
    errorMessage: props.forceValidation || blurred ? validateInteger(props.validation, props.value, props.label) : undefined,
    onBlur: onBlur,
    autoFocus: props.autoFocus,
    value: props.value === null ? undefined : props.value,
    onChange: val => {
      props.onChange(val === undefined ? null : val);
    }
  });
}

function integer({
  label,
  defaultValue,
  validation,
  description
}) {
  return index.basicFormFieldWithSimpleReaderParse({
    Input(props) {
      return /*#__PURE__*/jsxRuntime.jsx(IntegerFieldInput, {
        label: label,
        description: description,
        validation: validation,
        ...props
      });
    },
    defaultValue() {
      return defaultValue !== null && defaultValue !== void 0 ? defaultValue : null;
    },
    parse(value) {
      if (value === undefined) {
        return null;
      }
      if (typeof value === 'number') {
        return value;
      }
      throw new index.FieldDataError('Must be a number');
    },
    validate(value) {
      const message = validateInteger(validation, value, label);
      if (message !== undefined) {
        throw new index.FieldDataError(message);
      }
      index.assertRequired(value, validation, label);
      return value;
    },
    serialize(value) {
      return {
        value: value === null ? undefined : value
      };
    }
  });
}

function parseImageData(data) {
  try {
    const parsed = JSON.parse(data);
    if (typeof parsed === 'object' && parsed !== null && 'src' in parsed && typeof parsed.src === 'string') {
      return {
        src: parsed.src,
        alt: 'alt' in parsed && typeof parsed.alt === 'string' ? parsed.alt : '',
        height: 'height' in parsed && typeof parsed.height === 'number' && Number.isInteger(parsed.height) ? parsed.height : undefined,
        width: 'width' in parsed && typeof parsed.width === 'number' && Number.isInteger(parsed.width) ? parsed.width : undefined
      };
    }
  } catch (err) {}
  const pattern = /^\s*!\[(.*)\]\(([a-z0-9_\-/:.]+)\)\s*$/;
  const match = data.match(pattern);
  if (match) {
    return {
      src: match[2],
      alt: match[1]
    };
  }
  return {
    src: data,
    alt: ''
  };
}
const emptyImageData = {
  src: '',
  alt: ''
};
function ImageDialog(props) {
  const {
    image,
    onCancel,
    onChange,
    onClose
  } = props;
  const [state, setState] = React.useState(image !== null && image !== void 0 ? image : emptyImageData);
  const [status, setStatus] = React.useState(image ? 'good' : '');
  const [constrainProportions, setConstrainProportions] = React.useState(true);
  const [dimensions, setDimensions] = React.useState(emptyImageData);
  const formId = utils.useId();
  const imageLibraryURL = useImageLibraryURL();
  const revertLabel = `Revert to original (${dimensions.width} Ã— ${dimensions.height})`;
  const dimensionsMatchOriginal = dimensions.width === state.width && dimensions.height === state.height;
  const onPaste = event => {
    event.preventDefault();
    const text = event.clipboardData.getData('text/plain');
    setState(parseImageData(text));
  };
  React.useEffect(() => {
    if (!state.src) {
      setStatus('');
      return;
    }
    if (!isValidURL(state.src)) {
      return;
    }
    setStatus('loading');
    const img = new Image();
    img.onload = () => {
      const dimensions = {
        width: img.width,
        height: img.height
      };
      setState(state => ({
        ...state,
        ...dimensions
      }));
      setDimensions(dimensions);
      setStatus('good');
    };
    img.onerror = () => {
      setStatus('error');
    };
    img.src = state.src;
    return () => {
      img.onload = null;
    };
  }, [state.src]);
  return /*#__PURE__*/jsxRuntime.jsxs(dialog.Dialog, {
    children: [/*#__PURE__*/jsxRuntime.jsx(typography.Heading, {
      children: "Cloud image"
    }), /*#__PURE__*/jsxRuntime.jsx(slots.Content, {
      children: /*#__PURE__*/jsxRuntime.jsxs(layout.VStack, {
        elementType: "form",
        id: formId,
        gap: "xlarge",
        onSubmit: e => {
          e.preventDefault();
          if (status !== 'good') return;
          onChange(state);
          onClose();
        },
        children: [/*#__PURE__*/jsxRuntime.jsx(textField.TextField, {
          label: "Image URL",
          autoFocus: true,
          onPaste: onPaste,
          onKeyDown: e => {
            if (e.code === 'Backspace' || e.code === 'Delete') {
              setState(emptyImageData);
            } else {
              e.continuePropagation();
            }
          },
          value: state.src,
          description: /*#__PURE__*/jsxRuntime.jsxs(typography.Text, {
            children: ["Copy an image URL from the", ' ', /*#__PURE__*/jsxRuntime.jsx(link.TextLink, {
              prominence: "high",
              href: imageLibraryURL,
              target: "_blank",
              rel: "noreferrer",
              children: "Image Library"
            }), ' ', "and paste it into this field."]
          }),
          endElement: status === 'loading' ? /*#__PURE__*/jsxRuntime.jsx(layout.Flex, {
            height: "element.regular",
            width: "element.regular",
            alignItems: "center",
            justifyContent: "center",
            children: /*#__PURE__*/jsxRuntime.jsx(progress.ProgressCircle, {
              size: "small",
              "aria-label": "Checking\u2026",
              isIndeterminate: true
            })
          }) : state.src ? /*#__PURE__*/jsxRuntime.jsx(button.ClearButton, {
            onPress: () => setState(emptyImageData),
            preventFocus: true
          }) : null
        }), status === 'good' ? /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [/*#__PURE__*/jsxRuntime.jsx(textField.TextArea, {
            label: "Alt text",
            value: state.alt,
            onChange: alt => setState(state => ({
              ...state,
              alt
            }))
          }), /*#__PURE__*/jsxRuntime.jsxs(layout.HStack, {
            gap: "regular",
            alignItems: "end",
            children: [/*#__PURE__*/jsxRuntime.jsx(numberField.NumberField, {
              label: "Width",
              width: "scale.1600",
              formatOptions: {
                maximumFractionDigits: 0
              },
              value: state.width,
              onChange: width => {
                if (constrainProportions) {
                  setState(state => ({
                    ...state,
                    width,
                    height: Math.round(width / getAspectRatio(state))
                  }));
                } else {
                  setState(state => ({
                    ...state,
                    width
                  }));
                }
              }
            }), /*#__PURE__*/jsxRuntime.jsxs(tooltip.TooltipTrigger, {
              children: [/*#__PURE__*/jsxRuntime.jsx(button.ToggleButton, {
                isSelected: constrainProportions,
                "aria-label": "Constrain proportions",
                prominence: "low",
                onPress: () => {
                  setConstrainProportions(state => !state);
                },
                children: /*#__PURE__*/jsxRuntime.jsx(icon.Icon, {
                  src: constrainProportions ? link2Icon.link2Icon : link2OffIcon.link2OffIcon
                })
              }), /*#__PURE__*/jsxRuntime.jsx(tooltip.Tooltip, {
                children: "Constrain proportions"
              })]
            }), /*#__PURE__*/jsxRuntime.jsx(numberField.NumberField, {
              label: "Height",
              width: "scale.1600",
              formatOptions: {
                maximumFractionDigits: 0
              },
              value: state.height,
              onChange: height => {
                if (constrainProportions) {
                  setState(state => ({
                    ...state,
                    height,
                    width: Math.round(height * getAspectRatio(state))
                  }));
                } else {
                  setState(state => ({
                    ...state,
                    height
                  }));
                }
              }
            }), /*#__PURE__*/jsxRuntime.jsxs(tooltip.TooltipTrigger, {
              children: [/*#__PURE__*/jsxRuntime.jsx(button.ActionButton, {
                "aria-label": revertLabel,
                isDisabled: dimensionsMatchOriginal,
                onPress: () => {
                  setState(state => ({
                    ...state,
                    height: dimensions.height,
                    width: dimensions.width
                  }));
                },
                children: /*#__PURE__*/jsxRuntime.jsx(icon.Icon, {
                  src: undo2Icon.undo2Icon
                })
              }), /*#__PURE__*/jsxRuntime.jsx(tooltip.Tooltip, {
                maxWidth: "100%",
                children: revertLabel
              })]
            })]
          })]
        }) : null]
      })
    }), /*#__PURE__*/jsxRuntime.jsxs(button.ButtonGroup, {
      children: [/*#__PURE__*/jsxRuntime.jsx(button.Button, {
        onPress: onCancel,
        children: "Cancel"
      }), /*#__PURE__*/jsxRuntime.jsx(button.Button, {
        prominence: "high",
        type: "submit",
        form: formId,
        isDisabled: status !== 'good',
        children: image ? 'Done' : 'Insert'
      })]
    })]
  });
}
function Placeholder(props) {
  const editor = slateReact.useSlateStatic();
  const selected = slateReact.useSelected();
  const state = overlays.useOverlayTriggerState({
    defaultOpen: false
  });
  React.useEffect(() => {
    if (selected) {
      state.open();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selected]);
  const closeAndCleanup = () => {
    state.close();
    index.focusWithPreviousSelection(editor);
    props.onRemove();
  };
  return /*#__PURE__*/jsxRuntime.jsxs(index.NotEditable, {
    children: [/*#__PURE__*/jsxRuntime.jsxs(layout.Flex, {
      alignItems: "center",
      backgroundColor: "surface",
      borderRadius: "regular",
      gap: "regular",
      height: "element.large",
      paddingX: "large",
      onClick: () => state.open(),
      children: [/*#__PURE__*/jsxRuntime.jsx(icon.Icon, {
        src: imageIcon.imageIcon
      }), /*#__PURE__*/jsxRuntime.jsxs(typography.Text, {
        children: ["Cloud image", state.isOpen ? '' : '(click to configure)']
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(dialog.DialogContainer, {
      onDismiss: closeAndCleanup,
      children: state.isOpen && /*#__PURE__*/jsxRuntime.jsx(ImageDialog, {
        onChange: props.onChange,
        onCancel: closeAndCleanup,
        onClose: state.close
      })
    })]
  });
}
function ImagePreview({
  image,
  onChange,
  onRemove
}) {
  const selected = slateReact.useSelected();
  const maxHeight = 368; // size.scale.4600 â€” TODO: it'd be nice to get this from some token artefact
  const maxWidth = 734; // roughly the max width that an editor container will allow

  return /*#__PURE__*/jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: /*#__PURE__*/jsxRuntime.jsx(index.NotEditable, {
      children: /*#__PURE__*/jsxRuntime.jsxs(layout.VStack, {
        backgroundColor: selected ? 'accent' : 'surface',
        borderRadius: "medium",
        border: selected ? 'color.alias.borderFocused' : 'neutral',
        overflow: "hidden",
        children: [/*#__PURE__*/jsxRuntime.jsx(layout.Flex, {
          backgroundColor: "canvas",
          justifyContent: "center",
          UNSAFE_style: {
            maxHeight
          },
          children: /*#__PURE__*/jsxRuntime.jsx("img", {
            alt: image.alt,
            src: imageWithTransforms({
              source: image.src,
              // 2x for retina etc.
              height: maxHeight * 2,
              width: maxWidth * 2
            }),
            style: {
              objectFit: 'contain'
            }
          })
        }), /*#__PURE__*/jsxRuntime.jsxs(layout.HStack, {
          padding: "large",
          gap: "xlarge",
          borderTop: selected ? 'color.alias.borderFocused' : 'neutral',
          children: [/*#__PURE__*/jsxRuntime.jsxs(layout.VStack, {
            flex: "1",
            gap: "medium",
            justifyContent: "center",
            children: [image.alt ? /*#__PURE__*/jsxRuntime.jsx(typography.Text, {
              truncate: 2,
              children: image.alt
            }) : null, /*#__PURE__*/jsxRuntime.jsxs(typography.Text, {
              color: "neutralTertiary",
              size: "small",
              children: [image.width, " \xD7 ", image.height]
            })]
          }), /*#__PURE__*/jsxRuntime.jsxs(layout.HStack, {
            gap: "regular",
            children: [/*#__PURE__*/jsxRuntime.jsxs(dialog.DialogTrigger, {
              children: [/*#__PURE__*/jsxRuntime.jsxs(tooltip.TooltipTrigger, {
                children: [/*#__PURE__*/jsxRuntime.jsx(button.ActionButton, {
                  children: /*#__PURE__*/jsxRuntime.jsx(icon.Icon, {
                    src: pencilIcon.pencilIcon
                  })
                }), /*#__PURE__*/jsxRuntime.jsx(tooltip.Tooltip, {
                  children: "Edit Image Options"
                })]
              }), onClose => /*#__PURE__*/jsxRuntime.jsx(ImageDialog, {
                image: image,
                onChange: onChange,
                onCancel: onClose,
                onClose: onClose
              })]
            }), /*#__PURE__*/jsxRuntime.jsxs(tooltip.TooltipTrigger, {
              children: [/*#__PURE__*/jsxRuntime.jsx(button.ActionButton, {
                onPress: onRemove,
                children: /*#__PURE__*/jsxRuntime.jsx(icon.Icon, {
                  src: trash2Icon.trash2Icon
                })
              }), /*#__PURE__*/jsxRuntime.jsx(tooltip.Tooltip, {
                children: "Remove Image"
              })]
            })]
          })]
        })]
      })
    })
  });
}
function CloudImagePreview(props) {
  var _props$fields$width$v, _props$fields$height$;
  if (!props.fields.src.value) {
    return /*#__PURE__*/jsxRuntime.jsx(Placeholder, {
      onChange: props.onChange,
      onRemove: props.onRemove
    });
  }
  return /*#__PURE__*/jsxRuntime.jsx(ImagePreview, {
    image: {
      src: props.fields.src.value,
      alt: props.fields.alt.value,
      width: (_props$fields$width$v = props.fields.width.value) !== null && _props$fields$width$v !== void 0 ? _props$fields$width$v : undefined,
      height: (_props$fields$height$ = props.fields.height.value) !== null && _props$fields$height$ !== void 0 ? _props$fields$height$ : undefined
    },
    onChange: props.onChange,
    onRemove: props.onRemove
  });
}

// Utils
// -----------------------------------------------------------------------------
function imageWithTransforms(options) {
  let {
    fit = 'scale-down',
    source,
    height,
    width
  } = options;
  if (!/^https?:\/\/[^\.]+\.keystatic\.net/.test(source)) {
    return source;
  }
  return `${source}?` + new URLSearchParams({
    fit,
    height: height.toString(),
    width: width.toString()
  }).toString();
}
function isValidURL(str) {
  try {
    new URL(str);
    return true;
  } catch {
    return false;
  }
}
function useImageLibraryURL() {
  const config = index.useConfig();
  if (!index.isCloudConfig(config)) return 'https://keystatic.cloud/';
  const {
    project,
    team
  } = index.getSplitCloudProject(config);
  return `https://keystatic.cloud/teams/${team}/project/${project}/images`;
}
function getAspectRatio(state) {
  if (!state.width || !state.height) return 1;
  return state.width / state.height;
}

// this is written like this rather than ArrayField<ComponentSchema> to avoid TypeScript erroring about circularity
function component(options) {
  return options;
}

exports.CloudImagePreview = CloudImagePreview;
exports.component = component;
exports.emptyImageData = emptyImageData;
exports.integer = integer;
exports.parseImageData = parseImageData;
exports.useImageLibraryURL = useImageLibraryURL;
