'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('@keystar/ui/checkbox');
require('@keystar/ui/typography');
require('react/jsx-runtime');
require('@keystar/ui/text-field');
require('react');
var index = require('../../dist/index-8044c959.node.cjs.js');
require('@keystar/ui/button');
require('@keystar/ui/field');
require('@keystar/ui/layout');
require('@keystar/ui/style');
require('@keystar/ui/number-field');
require('@keystar/ui/combobox');
require('minimatch');
require('@react-stately/collections');
require('@keystar/ui/picker');
require('@sindresorhus/slugify');
require('@braintree/sanitize-url');
require('@react-aria/i18n');
require('@keystar/ui/dialog');
require('@keystar/ui/slots');
require('emery');
require('@keystar/ui/drag-and-drop');
require('@keystar/ui/icon');
require('@keystar/ui/icon/icons/trash2Icon');
require('@keystar/ui/list-view');
require('@keystar/ui/tooltip');
require('@keystar/ui/menu');
require('@keystar/ui/icon/icons/link2Icon');
require('@keystar/ui/icon/icons/link2OffIcon');
require('@keystar/ui/icon/icons/undo2Icon');
require('@keystar/ui/link');
require('@keystar/ui/progress');
require('slate-react');
require('@react-stately/overlays');
require('@keystar/ui/icon/icons/imageIcon');
require('@keystar/ui/icon/icons/pencilIcon');
require('@keystar/ui/utils');
var fs = require('fs/promises');
var path = require('path');
var requiredFiles = require('../../dist/required-files-714b48bf.node.cjs.js');
require('@markdoc/markdoc');
require('slate');
require('emery/assertions');
require('js-base64');
require('crypto');
require('@keystar/ui/split-view');
require('../../dist/languages-e9a3f1a7.node.cjs.js');
require('@keystar/ui/icon/icons/panelLeftOpenIcon');
require('@keystar/ui/icon/icons/panelLeftCloseIcon');
require('@keystar/ui/icon/icons/panelRightOpenIcon');
require('@keystar/ui/icon/icons/panelRightCloseIcon');
require('@react-aria/overlays');
require('@react-aria/utils');
require('@keystar/ui/badge');
require('@keystar/ui/overlays');
require('@keystar/ui/nav-list');
require('@ts-gql/tag/no-transform');
require('urql');
require('lru-cache');
require('cookie');
require('zod');
require('is-hotkey');
require('@keystar/ui/icon/icons/editIcon');
require('@keystar/ui/icon/icons/externalLinkIcon');
require('@keystar/ui/icon/icons/linkIcon');
require('@keystar/ui/icon/icons/unlinkIcon');
require('@keystar/ui/action-group');
require('@keystar/ui/icon/icons/boldIcon');
require('@keystar/ui/icon/icons/chevronDownIcon');
require('@keystar/ui/icon/icons/codeIcon');
require('@keystar/ui/icon/icons/italicIcon');
require('@keystar/ui/icon/icons/maximizeIcon');
require('@keystar/ui/icon/icons/minimizeIcon');
require('@keystar/ui/icon/icons/plusIcon');
require('@keystar/ui/icon/icons/removeFormattingIcon');
require('@keystar/ui/icon/icons/strikethroughIcon');
require('@keystar/ui/icon/icons/subscriptIcon');
require('@keystar/ui/icon/icons/superscriptIcon');
require('@keystar/ui/icon/icons/typeIcon');
require('@keystar/ui/icon/icons/underlineIcon');
require('@keystar/ui/icon/icons/alignLeftIcon');
require('@keystar/ui/icon/icons/alignRightIcon');
require('@keystar/ui/icon/icons/alignCenterIcon');
require('@keystar/ui/icon/icons/quoteIcon');
require('match-sorter');
require('@keystar/ui/icon/icons/trashIcon');
require('@emotion/weak-memoize');
require('@keystar/ui/icon/icons/minusIcon');
require('@keystar/ui/icon/icons/columnsIcon');
require('@keystar/ui/icon/icons/listIcon');
require('@keystar/ui/icon/icons/listOrderedIcon');
require('@keystar/ui/icon/icons/fileUpIcon');
require('@keystar/ui/icon/icons/sheetIcon');
require('@keystar/ui/icon/icons/tableIcon');
require('scroll-into-view-if-needed');
require('@react-stately/list');
require('@keystar/ui/listbox');
require('slate-history');
require('mdast-util-from-markdown');
require('mdast-util-gfm-autolink-literal/from-markdown');
require('micromark-extension-gfm-autolink-literal');
require('mdast-util-gfm-strikethrough/from-markdown');
require('micromark-extension-gfm-strikethrough');
require('js-yaml');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefault(fs);
var path__default = /*#__PURE__*/_interopDefault(path);

function cache(func) {
  return func;
}

async function getAllEntries(root, prefix) {
  return (await Promise.all((await fs__default["default"].readdir(path__default["default"].join(root, prefix), {
    withFileTypes: true
  }).catch(err => {
    if (err.code === 'ENOENT') {
      return [];
    }
    throw err;
  })).map(async dirent => {
    const name = `${prefix}${dirent.name}`;
    const entry = {
      entry: dirent,
      name
    };
    if (dirent.isDirectory()) {
      return [entry, ...(await getAllEntries(root, `${name}/`))];
    }
    if (dirent.isFile()) {
      return entry;
    }
    return [];
  }))).flat();
}
const listCollection = cache(async function listCollection(repoPath, collectionPath, glob, formatInfo, extension) {
  const entries = glob === '*' ? (await fs__default["default"].readdir(path__default["default"].join(repoPath, collectionPath), {
    withFileTypes: true
  }).catch(err => {
    if (err.code === 'ENOENT') {
      return [];
    }
    throw err;
  })).map(x => ({
    entry: x,
    name: x.name
  })) : await getAllEntries(path__default["default"].join(repoPath, collectionPath), '');
  return (await Promise.all(entries.map(async x => {
    if (formatInfo.dataLocation === 'index') {
      if (!x.entry.isDirectory()) return [];
      try {
        await fs__default["default"].stat(path__default["default"].join(repoPath, index.getEntryDataFilepath(`${collectionPath}/${x.name}`, formatInfo)));
        return [x.name];
      } catch (err) {
        if (err.code === 'ENOENT') {
          return [];
        }
        throw err;
      }
    } else {
      if (!x.entry.isFile() || !x.name.endsWith(extension)) return [];
      return [x.name.slice(0, -extension.length)];
    }
  }))).flat();
});
function collectionReader(repoPath, collection, config) {
  const formatInfo = index.getCollectionFormat(config, collection);
  const collectionPath = index.getCollectionPath(config, collection);
  const collectionConfig = config.collections[collection];
  const schema = index.object(collectionConfig.schema);
  const glob = index.getSlugGlobForCollection(config, collection);
  const extension = index.getDataFileExtension(formatInfo);
  const read = (slug, ...args) => {
    var _args$;
    return readItem(schema, formatInfo, index.getCollectionItemPath(config, collection, slug), repoPath, (_args$ = args[0]) === null || _args$ === void 0 ? void 0 : _args$.resolveLinkedFiles, `"${slug}" in collection "${collection}"`, slug, collectionConfig.slugField, glob);
  };
  const list = () => listCollection(repoPath, collectionPath, glob, formatInfo, extension);
  return {
    read,
    readOrThrow: async (...args) => {
      const entry = await read(...args);
      if (entry === null) {
        throw new Error(`Entry "${args[0]}" not found in collection "${collection}"`);
      }
      return entry;
    },
    // TODO: this could drop the fs.stat call that list does for each item
    // since we just immediately read it
    all: async (...args) => {
      const slugs = await list();
      return (await Promise.all(slugs.map(async slug => {
        const entry = await read(slug, args[0]);
        if (entry === null) return [];
        return [{
          slug,
          entry
        }];
      }))).flat();
    },
    list
  };
}
const readItem = cache(async function readItem(rootSchema, formatInfo, itemDir, repoPath, resolveLinkedFiles, debugReference, ...slugInfo) {
  let dataFile;
  try {
    dataFile = await fs__default["default"].readFile(path__default["default"].resolve(repoPath, index.getEntryDataFilepath(itemDir, formatInfo)));
  } catch (err) {
    if (err.code === 'ENOENT') {
      return null;
    }
    throw err;
  }
  const {
    loaded,
    extraFakeFile
  } = requiredFiles.loadDataFile(dataFile, formatInfo);
  const contentFieldPathsToEagerlyResolve = resolveLinkedFiles ? [] : undefined;
  let validated;
  try {
    validated = index.parseProps(rootSchema, loaded, [], [], (schema, value, path, pathWithArrayFieldSlugs) => {
      if (schema.formKind === 'asset') {
        return schema.reader.parse(value);
      }
      if (schema.formKind === 'content') {
        contentFieldPathsToEagerlyResolve === null || contentFieldPathsToEagerlyResolve === void 0 || contentFieldPathsToEagerlyResolve.push(path);
        return async () => {
          let content;
          const filename = pathWithArrayFieldSlugs.join('/') + schema.contentExtension;
          if (filename === (extraFakeFile === null || extraFakeFile === void 0 ? void 0 : extraFakeFile.path)) {
            content = extraFakeFile.contents;
          } else {
            content = await fs__default["default"].readFile(path__default["default"].resolve(repoPath, `${itemDir}/${filename}`)).catch(x => {
              if (x.code === 'ENOENT') return undefined;
              throw x;
            });
          }
          return schema.reader.parse(value, {
            content
          });
        };
      }
      if (path.length === 1 && slugInfo[0] !== undefined) {
        const [slug, slugField, glob] = slugInfo;
        if (path[0] === slugField) {
          if (schema.formKind !== 'slug') {
            throw new Error(`Slug field ${slugInfo[1]} is not a slug field`);
          }
          return schema.reader.parseWithSlug(value, {
            slug,
            glob
          });
        }
      }
      return schema.reader.parse(value);
    }, true);
    if (contentFieldPathsToEagerlyResolve !== null && contentFieldPathsToEagerlyResolve !== void 0 && contentFieldPathsToEagerlyResolve.length) {
      await Promise.all(contentFieldPathsToEagerlyResolve.map(async path => {
        const parentValue = index.getValueAtPropPath(validated, path.slice(0, -1));
        const keyOnParent = path[path.length - 1];
        const originalValue = parentValue[keyOnParent];
        parentValue[keyOnParent] = await originalValue();
      }));
    }
  } catch (err) {
    const formatted = index.formatFormDataError(err);
    throw new Error(`Invalid data for ${debugReference}:\n${formatted}`);
  }
  return validated;
});
function singletonReader(repoPath, singleton, config) {
  const formatInfo = index.getSingletonFormat(config, singleton);
  const singletonPath = index.getSingletonPath(config, singleton);
  const schema = index.object(config.singletons[singleton].schema);
  const read = (...args) => {
    var _args$2;
    return readItem(schema, formatInfo, singletonPath, repoPath, (_args$2 = args[0]) === null || _args$2 === void 0 ? void 0 : _args$2.resolveLinkedFiles, `singleton "${singleton}"`, undefined);
  };
  return {
    read,
    readOrThrow: async (...opts) => {
      const entry = await read(...opts);
      if (entry === null) {
        throw new Error(`Singleton "${singleton}" not found`);
      }
      return entry;
    }
  };
}
function createReader(repoPath, config) {
  return {
    collections: Object.fromEntries(Object.keys(config.collections || {}).map(key => [key, collectionReader(repoPath, key, config)])),
    singletons: Object.fromEntries(Object.keys(config.singletons || {}).map(key => [key, singletonReader(repoPath, key, config)])),
    repoPath,
    config
  };
}

exports.createReader = createReader;
