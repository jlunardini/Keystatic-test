import { makeSubject as e, filter as r, mergeMap as t, fromPromise as n, map as s, merge as i } from "wonka";

import { makeOperation as o, stringifyDocument as a } from "@urql/core";

var u = "undefined" != typeof window ? window.crypto : "undefined" != typeof self ? self.crypto : null;

var p;

var hash = async e => {
  if (u && u.subtle) {
    var r = await u.subtle.digest({
      name: "SHA-256"
    }, (new TextEncoder).encode(e));
    return new Uint8Array(r).reduce(((e, r) => e + r.toString(16).padStart(2, "0")), "");
  } else if (await (async () => {
    if (!p) {
      try {
        p = new Function("require", 'return require("crypto")')(require);
      } catch (e) {
        try {
          p = new Function('return import("crypto")')();
        } catch (e) {}
      }
    }
    return p;
  })()) {
    return (await p).createHash("sha256").update(e).digest("hex");
  }
  if ("production" !== process.env.NODE_ENV) {
    console.warn("[@urql/exchange-persisted-fetch]: The Node Crypto and Web Crypto APIs are not available.\nThis is an unexpected error. Please report it by filing a GitHub Issue.");
  }
  return "";
};

var persistedExchange = u => ({forward: p}) => {
  if (!u) {
    u = {};
  }
  var d = !!u.preferGetForPersistedQueries;
  var c = !!u.enforcePersistedQueries;
  var f = u.generateHash || hash;
  var y = !!u.enableForMutation;
  var l = !0;
  var operationFilter = e => l && !e.context.persistAttempt && (y && "mutation" === e.kind || "query" === e.kind);
  return u => {
    var y = e();
    var v = r((e => !operationFilter(e)))(u);
    var x = t(n)(s((async e => {
      var r = o(e.kind, e, {
        ...e.context,
        persistAttempt: !0
      });
      var t = await f(a(e.query), e.query);
      if (t) {
        r.extensions = {
          ...r.extensions,
          persistedQuery: {
            version: 1,
            sha256Hash: t
          }
        };
        if ("query" === r.kind && d) {
          r.context.preferGetMethod = "force";
        }
      }
      return r;
    }))(r(operationFilter)(u)));
    return r((e => !!e))(s((e => {
      if (!c && e.operation.extensions && e.operation.extensions.persistedQuery) {
        if (e.error && e.error.graphQLErrors.some((e => "PersistedQueryNotSupported" === e.message))) {
          l = !1;
          var r = o(e.operation.kind, e.operation);
          if (r.extensions) {
            delete r.extensions.persistedQuery;
          }
          y.next(r);
          return null;
        } else if (e.error && (e => e.graphQLErrors.some((e => "PersistedQueryNotFound" === e.message)))(e.error)) {
          var t = o(e.operation.kind, e.operation);
          t.extensions = {
            ...t.extensions,
            persistedQuery: {
              ...(t.extensions || {}).persistedQuery,
              miss: !0
            }
          };
          y.next(t);
          return null;
        }
      }
      return e;
    }))(p(i([ x, v, y.source ]))));
  };
};

export { persistedExchange };
//# sourceMappingURL=urql-exchange-persisted.mjs.map
