{"version":3,"file":"urql-exchange-persisted.mjs","sources":["../src/sha256.ts","../src/persistedExchange.ts"],"sourcesContent":["const webCrypto = (\n  typeof window !== 'undefined'\n    ? window.crypto\n    : typeof self !== 'undefined'\n    ? self.crypto\n    : null\n) as typeof globalThis.crypto | null;\n\nlet nodeCrypto: Promise<typeof import('crypto') | void> | void;\n\nconst getNodeCrypto = async (): Promise<typeof import('crypto') | void> => {\n  if (!nodeCrypto) {\n    // Indirect eval'd require/import to guarantee no side-effects in module scope\n    // (optimization for minifiers)\n    try {\n      nodeCrypto = new Function('require', 'return require(\"crypto\")')(require);\n    } catch (_error) {\n      try {\n        nodeCrypto = new Function('return import(\"crypto\")')();\n      } catch (_error) {}\n    }\n  }\n  return nodeCrypto;\n};\n\nexport const hash = async (query: string): Promise<string> => {\n  if (webCrypto && webCrypto.subtle) {\n    const digest = await webCrypto.subtle.digest(\n      { name: 'SHA-256' },\n      new TextEncoder().encode(query)\n    );\n    return new Uint8Array(digest).reduce(\n      (prev, byte) => prev + byte.toString(16).padStart(2, '0'),\n      ''\n    );\n  } else if (await getNodeCrypto()) {\n    // Node.js support\n    return (await nodeCrypto)!.createHash('sha256').update(query).digest('hex');\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.warn(\n      '[@urql/exchange-persisted-fetch]: The Node Crypto and Web Crypto APIs are not available.\\n' +\n        'This is an unexpected error. Please report it by filing a GitHub Issue.'\n    );\n  }\n\n  return '';\n};\n","import {\n  map,\n  makeSubject,\n  fromPromise,\n  filter,\n  merge,\n  mergeMap,\n  pipe,\n} from 'wonka';\n\nimport {\n  makeOperation,\n  stringifyDocument,\n  PersistedRequestExtensions,\n  TypedDocumentNode,\n  OperationResult,\n  CombinedError,\n  Exchange,\n  Operation,\n} from '@urql/core';\n\nimport { hash } from './sha256';\n\nconst isPersistedMiss = (error: CombinedError): boolean =>\n  error.graphQLErrors.some(x => x.message === 'PersistedQueryNotFound');\n\nconst isPersistedUnsupported = (error: CombinedError): boolean =>\n  error.graphQLErrors.some(x => x.message === 'PersistedQueryNotSupported');\n\n/** Input parameters for the {@link persistedExchange}. */\nexport interface PersistedExchangeOptions {\n  /** Enforces GET method requests to be made for Persisted Queries.\n   *\n   * @remarks\n   * When enabled, the `persistedExchange` will set\n   * `OperationContext.preferGetMethod` to `'force'` on persisted queries,\n   * which will force requests to be made using a GET request.\n   *\n   * This is frequently used to make GraphQL requests more cacheable\n   * on CDNs.\n   *\n   * @defaultValue `true` - enabled\n   */\n  preferGetForPersistedQueries?: boolean;\n  /** Enforces non-automatic persisted queries by ignoring APQ errors.\n   *\n   * @remarks\n   * When enabled, the `persistedExchange` will ignore `PersistedQueryNotFound`\n   * and `PersistedQueryNotSupported` errors and assume that all persisted\n   * queries are already known to the API.\n   *\n   * This is used to switch from Automatic Persisted Queries to\n   * Persisted Queries. This is commonly used to obfuscate GraphQL\n   * APIs.\n   */\n  enforcePersistedQueries?: boolean;\n  /** Custom hashing function for persisted queries.\n   *\n   * @remarks\n   * By default, `persistedExchange` will create a SHA-256 hash for\n   * persisted queries automatically. If you're instead generating\n   * hashes at compile-time, or need to use a custom SHA-256 function,\n   * you may pass one here.\n   *\n   * Hint: The default SHA-256 function uses the WebCrypto API. This\n   * API is unavailable on React Native, which may require you to\n   * pass a custom function here.\n   */\n  generateHash?(\n    query: string,\n    document: TypedDocumentNode<any, any>\n  ): Promise<string>;\n  /** Enables persisted queries to be used for mutations.\n   *\n   * @remarks\n   * When enabled, the `persistedExchange` will also use the persisted queries\n   * logic for mutation operations.\n   *\n   * This is disabled by default, but often used on APIs that obfuscate\n   * their GraphQL APIs.\n   */\n  enableForMutation?: boolean;\n}\n\n/** Exchange factory that adds support for Persisted Queries.\n *\n * @param options - A {@link PersistedExchangeOptions} configuration object.\n * @returns the created persisted queries {@link Exchange}.\n *\n * @remarks\n * The `persistedExchange` adds support for (Automatic) Persisted Queries\n * to any `fetchExchange`, `subscriptionExchange`, or other API exchanges\n * following it.\n *\n * It does so by adding the `persistedQuery` extensions field to GraphQL\n * requests and handles `PersistedQueryNotFound` and\n * `PersistedQueryNotSupported` errors.\n *\n * @example\n * ```ts\n * import { Client, cacheExchange, fetchExchange } from '@urql/core';\n * import { persistedExchange } from '@urql/exchange-persisted';\n *\n * const client = new Client({\n *   url: 'URL',\n *   exchanges: [\n *     cacheExchange,\n *     persistedExchange({\n *       preferGetForPersistedQueries: true,\n *     }),\n *     fetchExchange\n *   ],\n * });\n * ```\n */\nexport const persistedExchange =\n  (options?: PersistedExchangeOptions): Exchange =>\n  ({ forward }) => {\n    if (!options) options = {};\n\n    const preferGetForPersistedQueries = !!options.preferGetForPersistedQueries;\n    const enforcePersistedQueries = !!options.enforcePersistedQueries;\n    const hashFn = options.generateHash || hash;\n    const enableForMutation = !!options.enableForMutation;\n    let supportsPersistedQueries = true;\n\n    const operationFilter = (operation: Operation) =>\n      supportsPersistedQueries &&\n      !operation.context.persistAttempt &&\n      ((enableForMutation && operation.kind === 'mutation') ||\n        operation.kind === 'query');\n\n    return operations$ => {\n      const retries = makeSubject<Operation>();\n\n      const forwardedOps$ = pipe(\n        operations$,\n        filter(operation => !operationFilter(operation))\n      );\n\n      const persistedOps$ = pipe(\n        operations$,\n        filter(operationFilter),\n        map(async operation => {\n          const persistedOperation = makeOperation(operation.kind, operation, {\n            ...operation.context,\n            persistAttempt: true,\n          });\n\n          const sha256Hash = await hashFn(\n            stringifyDocument(operation.query),\n            operation.query\n          );\n          if (sha256Hash) {\n            persistedOperation.extensions = {\n              ...persistedOperation.extensions,\n              persistedQuery: {\n                version: 1,\n                sha256Hash,\n              },\n            };\n            if (\n              persistedOperation.kind === 'query' &&\n              preferGetForPersistedQueries\n            ) {\n              persistedOperation.context.preferGetMethod = 'force';\n            }\n          }\n\n          return persistedOperation;\n        }),\n        mergeMap(fromPromise)\n      );\n\n      return pipe(\n        merge([persistedOps$, forwardedOps$, retries.source]),\n        forward,\n        map(result => {\n          if (\n            !enforcePersistedQueries &&\n            result.operation.extensions &&\n            result.operation.extensions.persistedQuery\n          ) {\n            if (result.error && isPersistedUnsupported(result.error)) {\n              // Disable future persisted queries if they're not enforced\n              supportsPersistedQueries = false;\n              // Update operation with unsupported attempt\n              const followupOperation = makeOperation(\n                result.operation.kind,\n                result.operation\n              );\n              if (followupOperation.extensions)\n                delete followupOperation.extensions.persistedQuery;\n              retries.next(followupOperation);\n              return null;\n            } else if (result.error && isPersistedMiss(result.error)) {\n              // Update operation with unsupported attempt\n              const followupOperation = makeOperation(\n                result.operation.kind,\n                result.operation\n              );\n              // Mark as missed persisted query\n              followupOperation.extensions = {\n                ...followupOperation.extensions,\n                persistedQuery: {\n                  ...(followupOperation.extensions || {}).persistedQuery,\n                  miss: true,\n                } as PersistedRequestExtensions,\n              };\n              retries.next(followupOperation);\n              return null;\n            }\n          }\n          return result;\n        }),\n        filter((result): result is OperationResult => !!result)\n      );\n    };\n  };\n"],"names":["webCrypto","hash","async","query","subtle","digest","name","encode","TextEncoder","prev","byte","toString","padStart","getNodeCrypto","nodeCrypto","Function","require","_error","createHash","update","process","env","NODE_ENV","console","persistedExchange","options","forward","preferGetForPersistedQueries","enforcePersistedQueries","enableForMutation","hashFn","operation","context","persistAttempt","kind","supportsPersistedQueries","operationFilter","forwardedOps$","filter","operations$","retries","makeSubject","fromPromise","map","persistedOperation","persistedOps$","stringifyDocument","sha256Hash","extensions","version","preferGetMethod","result","persistedQuery","error","makeOperation","followupOperation","next","graphQLErrors","some","x","message","_followupOperation","isPersistedMiss","merge","source"],"mappings":";;;;;;AAAA,IAAAA;;AAuBA,IAAAC,OAAAC;EAEA,IAAAF,KAAAG,EAAAC,QAAA;QACAC,UAAAL,SAAAK,OAAA;MACAC;QACAA,iBAAAC,OAAAJ;IAAA,OACAK,IAAAA,cAAAL,QACA,CAAAM,GAAAC,MAAAD,IAAAC,EAAAC,SAAA,IAAAC,SAAA,GAAA,OAAA;AACA,SAAA,UAvBAV;IAEAW,KAAAA;MAGA;QACAC,IAAA,IAAAC,SAAA,WAAA,2BAAA,CAAAC;QACAF,OAAAG;QACA;UACAH,IAAA,IAAAC,SAAA,0BAAA;AACAD,UAAAA,OAAAA,IAAAC;AACA;;IAEA,OAAAD;AAAA,IAUAD;IAKA,cAAAC,GAAAI,WAAA,UAAAC,OAAAhB,GAAAE,OAAA;;EAEA,IAAA,iBAAAe,QAAAC,IAAAC;IAEAC,aAAA;;EAKA,OAAA;AAAA;;ACoEA,IAAAC,oBAAAC,KAAA,EACAC;EAGAA,KAAAA;IAAAA,IAAAA,CAAAA;;EAAA,IAAAC,MAAAF,EAAAE;EACA,IAAAC,MAAAH,EAAAG;EAEA,IAAAD,sBAAAF;EACA,IAAAG,QAAAC;EACA,IAAAC,KAAA;EACA,IAAAD,kBAAAE,WAAAA,EAAAC,QAAAC,mBAAAJ,KAAA,eAAAE,EAAAG,QAAA,YAAAH,EAAAG;EACA,OAAAC;IAEAC,IAAAA,IAAAA;IAMA,IAAAC,IAAAC,GAAAP,MAAAK,gBAAAL,IAAAO,CAAAC;IACA,IAAAC,IAAAC,EAAAC,EAAAD,CAAAE,GAAAzC;UAEA0C,IAEAb,EAAAK,EAAAF,MAAAH,GAAA;WAGAc,EAAAb;QAIAC,iBAAA;;MAEAA,IAAAA,UAAAH,EAAAgB,EAAAf,EAAA5B,QAAA4B,EAAA5B;MACA,IAAA4C,GAAA;UAEAjB,aACA;eAGAkB;UACAJ,gBAAA;YACAK,SAAA;;;;QAIA,IAAA,YAAAL,EAAAV,QAAAP;UACAiB,EAAAZ,QAAAkB,kBAAA;;AAKAN;MACA,OAAAA;AAAA,OAjCAD,CAkCAL,EAAAF,gBAAAE,CAAAC;IAEA,OAAAD,aAAAA,CAAAK,GAAAQ;MACA,KA5BAb,KADAa,EA+BApB,UAAAiB,cAAAG,EAAApB,UAAAiB,WAAAI;QA2CAd,IAAAA,EAAAa,SAtCAA,EAAAE,6EAAA;UAMAlB,KAAA;UAEAA,IAAAA,IAAAmB,EAAAH,EAAApB,UAAAG,MAAAiB,EAAApB;UACA,IAAAwB,EAAAP;mBAAAO,EAAAP,WAAAI;;UACAZ,EAAAe,KAAAA;UAIA,OAAA;AAEAf,mBAAAgB,EAAAD,SDjJAF,MAAAA,EAAAI,cAAAC,MAAAC,KAAA,6BAAAA,EAAAC,UCiJAL,CAAAJ,EAAAE,QAAA;UAEA,IAAAQ,IAAAC,EAAAX,EAAApB,UAAAG,MAAAiB,EAAApB;UAEA8B,EAAAN,aAAAD;eAIAO,EAAAb;YACAO,gBAAA;kBACAM,EAAAb,cAAA,CAAA,GAAAI;;;;UAIAZ,EAAAgB,KAAAK;iBACA;AACArB;;MAEA,OAAAW;AAAA,OA1CAR,CA2CAjB,EAAAqC,EAAA,EAAAlB,GAAAR,GAAAG,EAAAwB;AAAA;AACA;;SAIAxC"}