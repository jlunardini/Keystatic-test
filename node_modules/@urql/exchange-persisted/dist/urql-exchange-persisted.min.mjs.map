{"version":3,"file":"urql-exchange-persisted.min.mjs","sources":["../src/sha256.ts","../src/persistedExchange.ts"],"sourcesContent":["const webCrypto = (\n  typeof window !== 'undefined'\n    ? window.crypto\n    : typeof self !== 'undefined'\n    ? self.crypto\n    : null\n) as typeof globalThis.crypto | null;\n\nlet nodeCrypto: Promise<typeof import('crypto') | void> | void;\n\nconst getNodeCrypto = async (): Promise<typeof import('crypto') | void> => {\n  if (!nodeCrypto) {\n    // Indirect eval'd require/import to guarantee no side-effects in module scope\n    // (optimization for minifiers)\n    try {\n      nodeCrypto = new Function('require', 'return require(\"crypto\")')(require);\n    } catch (_error) {\n      try {\n        nodeCrypto = new Function('return import(\"crypto\")')();\n      } catch (_error) {}\n    }\n  }\n  return nodeCrypto;\n};\n\nexport const hash = async (query: string): Promise<string> => {\n  if (webCrypto && webCrypto.subtle) {\n    const digest = await webCrypto.subtle.digest(\n      { name: 'SHA-256' },\n      new TextEncoder().encode(query)\n    );\n    return new Uint8Array(digest).reduce(\n      (prev, byte) => prev + byte.toString(16).padStart(2, '0'),\n      ''\n    );\n  } else if (await getNodeCrypto()) {\n    // Node.js support\n    return (await nodeCrypto)!.createHash('sha256').update(query).digest('hex');\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    console.warn(\n      '[@urql/exchange-persisted-fetch]: The Node Crypto and Web Crypto APIs are not available.\\n' +\n        'This is an unexpected error. Please report it by filing a GitHub Issue.'\n    );\n  }\n\n  return '';\n};\n","import {\n  map,\n  makeSubject,\n  fromPromise,\n  filter,\n  merge,\n  mergeMap,\n  pipe,\n} from 'wonka';\n\nimport {\n  makeOperation,\n  stringifyDocument,\n  PersistedRequestExtensions,\n  TypedDocumentNode,\n  OperationResult,\n  CombinedError,\n  Exchange,\n  Operation,\n} from '@urql/core';\n\nimport { hash } from './sha256';\n\nconst isPersistedMiss = (error: CombinedError): boolean =>\n  error.graphQLErrors.some(x => x.message === 'PersistedQueryNotFound');\n\nconst isPersistedUnsupported = (error: CombinedError): boolean =>\n  error.graphQLErrors.some(x => x.message === 'PersistedQueryNotSupported');\n\n/** Input parameters for the {@link persistedExchange}. */\nexport interface PersistedExchangeOptions {\n  /** Enforces GET method requests to be made for Persisted Queries.\n   *\n   * @remarks\n   * When enabled, the `persistedExchange` will set\n   * `OperationContext.preferGetMethod` to `'force'` on persisted queries,\n   * which will force requests to be made using a GET request.\n   *\n   * This is frequently used to make GraphQL requests more cacheable\n   * on CDNs.\n   *\n   * @defaultValue `true` - enabled\n   */\n  preferGetForPersistedQueries?: boolean;\n  /** Enforces non-automatic persisted queries by ignoring APQ errors.\n   *\n   * @remarks\n   * When enabled, the `persistedExchange` will ignore `PersistedQueryNotFound`\n   * and `PersistedQueryNotSupported` errors and assume that all persisted\n   * queries are already known to the API.\n   *\n   * This is used to switch from Automatic Persisted Queries to\n   * Persisted Queries. This is commonly used to obfuscate GraphQL\n   * APIs.\n   */\n  enforcePersistedQueries?: boolean;\n  /** Custom hashing function for persisted queries.\n   *\n   * @remarks\n   * By default, `persistedExchange` will create a SHA-256 hash for\n   * persisted queries automatically. If you're instead generating\n   * hashes at compile-time, or need to use a custom SHA-256 function,\n   * you may pass one here.\n   *\n   * Hint: The default SHA-256 function uses the WebCrypto API. This\n   * API is unavailable on React Native, which may require you to\n   * pass a custom function here.\n   */\n  generateHash?(\n    query: string,\n    document: TypedDocumentNode<any, any>\n  ): Promise<string>;\n  /** Enables persisted queries to be used for mutations.\n   *\n   * @remarks\n   * When enabled, the `persistedExchange` will also use the persisted queries\n   * logic for mutation operations.\n   *\n   * This is disabled by default, but often used on APIs that obfuscate\n   * their GraphQL APIs.\n   */\n  enableForMutation?: boolean;\n}\n\n/** Exchange factory that adds support for Persisted Queries.\n *\n * @param options - A {@link PersistedExchangeOptions} configuration object.\n * @returns the created persisted queries {@link Exchange}.\n *\n * @remarks\n * The `persistedExchange` adds support for (Automatic) Persisted Queries\n * to any `fetchExchange`, `subscriptionExchange`, or other API exchanges\n * following it.\n *\n * It does so by adding the `persistedQuery` extensions field to GraphQL\n * requests and handles `PersistedQueryNotFound` and\n * `PersistedQueryNotSupported` errors.\n *\n * @example\n * ```ts\n * import { Client, cacheExchange, fetchExchange } from '@urql/core';\n * import { persistedExchange } from '@urql/exchange-persisted';\n *\n * const client = new Client({\n *   url: 'URL',\n *   exchanges: [\n *     cacheExchange,\n *     persistedExchange({\n *       preferGetForPersistedQueries: true,\n *     }),\n *     fetchExchange\n *   ],\n * });\n * ```\n */\nexport const persistedExchange =\n  (options?: PersistedExchangeOptions): Exchange =>\n  ({ forward }) => {\n    if (!options) options = {};\n\n    const preferGetForPersistedQueries = !!options.preferGetForPersistedQueries;\n    const enforcePersistedQueries = !!options.enforcePersistedQueries;\n    const hashFn = options.generateHash || hash;\n    const enableForMutation = !!options.enableForMutation;\n    let supportsPersistedQueries = true;\n\n    const operationFilter = (operation: Operation) =>\n      supportsPersistedQueries &&\n      !operation.context.persistAttempt &&\n      ((enableForMutation && operation.kind === 'mutation') ||\n        operation.kind === 'query');\n\n    return operations$ => {\n      const retries = makeSubject<Operation>();\n\n      const forwardedOps$ = pipe(\n        operations$,\n        filter(operation => !operationFilter(operation))\n      );\n\n      const persistedOps$ = pipe(\n        operations$,\n        filter(operationFilter),\n        map(async operation => {\n          const persistedOperation = makeOperation(operation.kind, operation, {\n            ...operation.context,\n            persistAttempt: true,\n          });\n\n          const sha256Hash = await hashFn(\n            stringifyDocument(operation.query),\n            operation.query\n          );\n          if (sha256Hash) {\n            persistedOperation.extensions = {\n              ...persistedOperation.extensions,\n              persistedQuery: {\n                version: 1,\n                sha256Hash,\n              },\n            };\n            if (\n              persistedOperation.kind === 'query' &&\n              preferGetForPersistedQueries\n            ) {\n              persistedOperation.context.preferGetMethod = 'force';\n            }\n          }\n\n          return persistedOperation;\n        }),\n        mergeMap(fromPromise)\n      );\n\n      return pipe(\n        merge([persistedOps$, forwardedOps$, retries.source]),\n        forward,\n        map(result => {\n          if (\n            !enforcePersistedQueries &&\n            result.operation.extensions &&\n            result.operation.extensions.persistedQuery\n          ) {\n            if (result.error && isPersistedUnsupported(result.error)) {\n              // Disable future persisted queries if they're not enforced\n              supportsPersistedQueries = false;\n              // Update operation with unsupported attempt\n              const followupOperation = makeOperation(\n                result.operation.kind,\n                result.operation\n              );\n              if (followupOperation.extensions)\n                delete followupOperation.extensions.persistedQuery;\n              retries.next(followupOperation);\n              return null;\n            } else if (result.error && isPersistedMiss(result.error)) {\n              // Update operation with unsupported attempt\n              const followupOperation = makeOperation(\n                result.operation.kind,\n                result.operation\n              );\n              // Mark as missed persisted query\n              followupOperation.extensions = {\n                ...followupOperation.extensions,\n                persistedQuery: {\n                  ...(followupOperation.extensions || {}).persistedQuery,\n                  miss: true,\n                } as PersistedRequestExtensions,\n              };\n              retries.next(followupOperation);\n              return null;\n            }\n          }\n          return result;\n        }),\n        filter((result): result is OperationResult => !!result)\n      );\n    };\n  };\n"],"names":["webCrypto","hash","async","query","subtle","digest","name","encode","TextEncoder","prev","byte","toString","padStart","getNodeCrypto","nodeCrypto","Function","require","_error","createHash","update","persistedExchange","options","forward","preferGetForPersistedQueries","enforcePersistedQueries","enableForMutation","hashFn","operation","context","persistAttempt","kind","supportsPersistedQueries","operationFilter","forwardedOps$","filter","operations$","retries","makeSubject","fromPromise","map","persistedOperation","persistedOps$","stringifyDocument","sha256Hash","extensions","version","preferGetMethod","result","persistedQuery","error","makeOperation","followupOperation","next","graphQLErrors","some","x","message","_followupOperation","isPersistedMiss","merge","source"],"mappings":"yKAAAA,uFAuBAC,EAAAC,UAEA,GAAAF,GAAAG,EAAAC,OAAA,KACAC,QAAAL,SAAAK,OAAA,CACAC,iBACAA,iBAAAC,OAAAJ,IAAA,OACAK,IAAAA,cAAAL,QACA,CAAAM,EAAAC,IAAAD,EAAAC,EAAAC,SAAA,IAAAC,SAAA,EAAA,MAAA,GACA,CAAA,YAvBAV,WAEAW,IAAAA,EAGA,IACAC,EAAA,IAAAC,SAAA,UAAA,2BAAA,CAAAC,SACAF,MAAAG,GACA,IACAH,EAAA,IAAAC,SAAA,0BAAA,EACAD,CAAAA,MAAAA,GAAAC,CACA,CAEA,OAAAD,CAAA,EAUAD,UAKAC,GAAAI,WAAA,UAAAC,OAAAhB,GAAAE,OAAA,OASA,EAAA,ECoEAe,EAAAC,GAAA,EACAC,cAGAA,IAAAA,EAAAA,CAAAA,GAAA,IAAAC,IAAAF,EAAAE,6BACAC,IAAAH,EAAAG,wBAEAD,kBAAAF,EACAG,MAAAC,kBACAC,GAAA,EACAD,EAAAE,OAAAA,EAAAC,QAAAC,iBAAAJ,GAAA,aAAAE,EAAAG,MAAA,UAAAH,EAAAG,MACA,OAAAC,IAEAC,IAAAA,EAAAA,IAMAC,EAAAC,GAAAP,IAAAK,EAAAL,IAAAO,CAAAC,GACAC,EAAAC,EAAAC,EAAAD,CAAAE,GAAArC,cAEAsC,EAEAb,EAAAK,EAAAF,KAAAH,EAAA,IAGAc,EAAAb,QAIAC,gBAAA,IAEAA,QAAAH,EAAAgB,EAAAf,EAAAxB,OAAAwB,EAAAxB,OAoBA,OAnBAwC,MAEAjB,WACA,MAGAkB,WACAJ,eAAA,CACAK,QAAA,iBAIA,UAAAL,EAAAV,MAAAP,IACAiB,EAAAZ,QAAAkB,gBAAA,UAMAN,CAAA,GAjCAD,CAkCAL,EAAAF,EAAAE,CAAAC,KAEA,OAAAD,WAAAA,CAAAK,GAAAQ,IACA,IA5BAb,GADAa,EA+BApB,UAAAiB,YAAAG,EAAApB,UAAAiB,WAAAI,eAAA,CA2CAd,GAAAA,EAAAa,OAtCAA,EAAAE,wEAAA,CAMAlB,GAAA,EAEAA,IAAAA,EAAAmB,EAAAH,EAAApB,UAAAG,KAAAiB,EAAApB,WAMA,OALAwB,EAAAP,mBAAAO,EAAAP,WAAAI,eACAZ,EAAAe,KAAAA,GAIA,IAEAf,IAAAgB,EAAAD,OAAAJ,EAAAE,MDjJAI,cAAAC,MAAAC,GAAA,2BAAAA,EAAAC,UCiJA,CAEA,IAAAC,EAAAC,EAAAX,EAAApB,UAAAG,KAAAiB,EAAApB,kBAEA8B,EAAAN,WAAAD,IAIAO,EAAAb,WACAO,eAAA,KACAM,EAAAb,YAAA,CAAA,GAAAI,yBAIAZ,EAAAgB,KAAAK,GACA,IACArB,CACA,CACA,OAAAW,CAAA,GA1CAR,CA2CAjB,EAAAqC,EAAA,CAAAlB,EAAAR,EAAAG,EAAAwB,WAAA,CACA,SAIAxC"}